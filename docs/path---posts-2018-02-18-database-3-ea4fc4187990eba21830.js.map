{"version":3,"sources":["webpack:///path---posts-2018-02-18-database-3-ea4fc4187990eba21830.js","webpack:///./.cache/json/posts-2018-02-18-database-3.json"],"names":["webpackJsonp","489","module","exports","data","markdownRemark","html","frontmatter","title","date","tags","pathContext","slug"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,mlHAAq0GC,aAAoVC,MAAA,QAAAC,KAAA,aAAAC,MAAA,SAAoDC,aAAgBC,KAAA","file":"path---posts-2018-02-18-database-3-ea4fc4187990eba21830.js","sourcesContent":["webpackJsonp([109917099093834],{\n\n/***/ 489:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h1>数据库范式</h1>\\n<h2>TODO List</h2>\\n<ul>\\n<li>[√]1ND概念，1ND例子</li>\\n<li>[]2ND概念，2ND</li>\\n<li>[]3ND概念，3ND例子，2ND如何分解得到3ND</li>\\n<li>[]4ND</li>\\n</ul>\\n<p>下面的内容主要来自于课本，互联网资料的整合，在一些难理解的概念处，我加上了自己的白话理解。关于属于第几范式的判断，也有一个逐步骤分析的例子。</p>\\n<p>范式表示一个关系内部各属性之间联系的合理化程度。可以用来表示一个关系结构所符合设计标准的级别。举个并不恰当的例子，比如建筑装饰里面，不同的工程类别需要不同的等级，等级高了，材料的要求就高，越环保，当然，施工难度和成本就更大。范式可以分为5个级别，分别为1ND，2ND，3ND，BCND，4ND，相对而言，低级别的范式都更加粗糙，高级别的范式则更精致。高级别的范式一定满足低级别的范式，低级别的范式一般都难以满足高级别范式的要求。</p>\\n<h2>1ND</h2>\\n<p>最低级别的自然是1ND，只要关系内部的各个属性都是不可再分的，那么就符合第一范式。但仅仅符合1ND是绝对不够的，对于下表</p>\\n<p><img src=\\\"1nd.png\\\" alt=\\\"第一范式初始\\\"></p>\\n<p>可能出现这些问题：</p>\\n<ol>\\n<li>数据冗余：姓名，系名，系主任重复了多次</li>\\n<li>插入异常：下面表内的候选码很容易确定是学号和课程名，也必须这样才能唯一确定一个元组，即当候选码确定后，该表中的其他属性也都随之确定了。一个关系可能有多个候选码，任取一个候选码（这里仅有一个）作为关系的主码（或者叫码），码一定具有实体完整性，即非NULL，唯一，不满足实体完整性便拒绝插入</li>\\n</ol>\\n<p><img src=\\\"insert-error.png\\\" alt=\\\"插入异常\\\"></p>\\n<ol>\\n<li>数据冗余：姓名，系名，系主任重复了多次</li>\\n</ol>\\n<h2>2ND</h2>\\n<p>第二范式要求关系中非主属性对于码没有部分函数依赖</p>\\n<p>这里需要解释一组概念了：</p>\\n<p>函数依赖又可以进一步分为直接函数依赖，传递函数依赖。直接函数依赖可以分为完全函数依赖于部分函数依赖。</p>\\n<ul>\\n<li>\\n<p>函数依赖</p>\\n<ul>\\n<li>\\n<p>直接函数依赖</p>\\n<ul>\\n<li>完全函数依赖</li>\\n<li>部分函数依赖</li>\\n</ul>\\n</li>\\n<li>传递函数依赖</li>\\n</ul>\\n</li>\\n</ul>\\n<h3>函数依赖</h3>\\n<p><code>R(U)</code>是属性集<code>U</code>上的关系模式，<code>X</code>、<code>Y</code>为<code>U</code>的子集，对\\n于<code>R(U)</code>的任何一个关系实例，不存在两个元组在<code>X</code>上的属性相同，在<code>Y</code>上的属性值不同，就称为<code>X</code>决定<code>Y</code>，<code>Y</code>函数依赖于<code>X</code>，记为<code>X->Y</code>。</p>\\n<p>即在一张表内，某个属性或者属性组<code>X</code>确定后，<code>Y</code>就一定可以确定出来，类似于函数<code>Y=F(x)</code>，<code>X</code>是确定的，那么<code>Y</code>也一定可以明确得出，需要注意<code>X</code>,<code>Y</code>都是关系的属性或者属性组。</p>\\n<p><img src=\\\"2018-02-22-14-51-45.png\\\" alt=\\\"函数依赖\\\">\\t</p>\\n<p>上表中的学号确定后，都可以随之确定姓名和班级，并非指一一对应，而是说同一个学号，绝不会对应两个不同的姓名或者班级，这便叫做姓名和班级依赖于学号，学号决定姓名与班级。记为<code>学号->{姓名,班级}</code></p>\\n<h3>候选码、主码、码、主属性、非主属性、全码</h3>\\n<p>定义一个关系模式<code>R(U)</code>，<code>U</code>表示属于这个关系模式的所有属性的集合。</p>\\n<p>比如下面这个关系模式</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-sql\\\"><code>学生<span class=\\\"token punctuation\\\">(</span>学号<span class=\\\"token punctuation\\\">,</span>姓名<span class=\\\"token punctuation\\\">,</span>班级<span class=\\\"token punctuation\\\">,</span>家庭住址<span class=\\\"token punctuation\\\">,</span>电话号码<span class=\\\"token punctuation\\\">)</span>\\n</code></pre>\\n      </div>\\n<p>关系模式学生，它的所有属性的集合<code>U</code>就是</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-sql\\\"><code>u <span class=\\\"token operator\\\">=</span> {学号<span class=\\\"token punctuation\\\">,</span>姓名<span class=\\\"token punctuation\\\">,</span>班级<span class=\\\"token punctuation\\\">,</span>家庭住址<span class=\\\"token punctuation\\\">,</span>电话号码}\\n</code></pre>\\n      </div>\\n<p>有了以上定义，我们就可以开始了。</p>\\n<h4>候选码</h4>\\n<p>如果一个关系内部，有某个属性或者属性组，可以唯一表示它坐在的元组，而它的子集不能，称这个属性或者属性组为<strong>候选码</strong>。</p>\\n<p>如何在复杂的关系中一个不拉的确定候选码是非常重要的一步骤，一会儿来说，先掌握候选码的概念。</p>\\n<h4>主码</h4>\\n<p>一个关系中的候选码可以有多个，任选其中之一，称其为<strong>主码</strong>。</p>\\n<h4>主属性与非主属性</h4>\\n<p>一个关系可能有多个候选码，只要在这些候选码中的属性都称为<strong>主属性</strong>。用<code>U</code>属性集合，减去主属性集合，剩余的就是<strong>非主属性</strong>了。</p>\\n<p>比如下面的例子</p>\\n<p><img src=\\\"2018-02-22-15-27-53.png\\\" alt=\\\"主属性与非主属性\\\"></p>\\n<p>我试图解释的这个例子，仅仅有助于理解主属性和非主属性，前后衔接的话不一定是对的，后续说到与此处有关，能帮忙修正这个解释的概念时，我会特别说明。</p>\\n<p>在这里的学号是唯一的，自然它就是一个候选码了。再看看其他属性还能不能是候选码，在一个学校里面两个同学有相同的名字是很正常的，姓名属性一定不是候选码，班级和家庭住址（不排除双胞胎）也无法唯一确定一个学生。这里候选码就是学号。</p>\\n<p>用属性集合<code>U</code>去掉候选码内的属性，这里只有一个学号，剩余的属性集合<code>{姓名,班级,家庭住址}</code>就是非主属性。</p>\\n<h4>码</h4>\\n<p>主码和候选码都可以简称为码，具体码的所指，需要看上下文。</p>\\n<h3>完全函数依赖与部分函数依赖</h3>\\n<p><code>R(U)</code>为属性集<code>U</code>的关系模式，X决定Y，但对于X的任何一个真子集，都无法决定Y，将此时的函数依赖关系称为完全函数依赖。</p>\\n<p><code>R(u)</code></p>\\n<h2>参考</h2>\\n<ul>\\n<li><a href=\\\"https://www.zhihu.com/question/24696366\\\">解释一下关系数据库的第一第二第三范式？</a></li>\\n</ul>\",\"frontmatter\":{\"title\":\"数据库范式\",\"date\":\"2018-02-22\",\"tags\":[\"DB\"]}}},\"pathContext\":{\"slug\":\"/2018-02-18---database-3/\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---posts-2018-02-18-database-3-ea4fc4187990eba21830.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h1>数据库范式</h1>\\n<h2>TODO List</h2>\\n<ul>\\n<li>[√]1ND概念，1ND例子</li>\\n<li>[]2ND概念，2ND</li>\\n<li>[]3ND概念，3ND例子，2ND如何分解得到3ND</li>\\n<li>[]4ND</li>\\n</ul>\\n<p>下面的内容主要来自于课本，互联网资料的整合，在一些难理解的概念处，我加上了自己的白话理解。关于属于第几范式的判断，也有一个逐步骤分析的例子。</p>\\n<p>范式表示一个关系内部各属性之间联系的合理化程度。可以用来表示一个关系结构所符合设计标准的级别。举个并不恰当的例子，比如建筑装饰里面，不同的工程类别需要不同的等级，等级高了，材料的要求就高，越环保，当然，施工难度和成本就更大。范式可以分为5个级别，分别为1ND，2ND，3ND，BCND，4ND，相对而言，低级别的范式都更加粗糙，高级别的范式则更精致。高级别的范式一定满足低级别的范式，低级别的范式一般都难以满足高级别范式的要求。</p>\\n<h2>1ND</h2>\\n<p>最低级别的自然是1ND，只要关系内部的各个属性都是不可再分的，那么就符合第一范式。但仅仅符合1ND是绝对不够的，对于下表</p>\\n<p><img src=\\\"1nd.png\\\" alt=\\\"第一范式初始\\\"></p>\\n<p>可能出现这些问题：</p>\\n<ol>\\n<li>数据冗余：姓名，系名，系主任重复了多次</li>\\n<li>插入异常：下面表内的候选码很容易确定是学号和课程名，也必须这样才能唯一确定一个元组，即当候选码确定后，该表中的其他属性也都随之确定了。一个关系可能有多个候选码，任取一个候选码（这里仅有一个）作为关系的主码（或者叫码），码一定具有实体完整性，即非NULL，唯一，不满足实体完整性便拒绝插入</li>\\n</ol>\\n<p><img src=\\\"insert-error.png\\\" alt=\\\"插入异常\\\"></p>\\n<ol>\\n<li>数据冗余：姓名，系名，系主任重复了多次</li>\\n</ol>\\n<h2>2ND</h2>\\n<p>第二范式要求关系中非主属性对于码没有部分函数依赖</p>\\n<p>这里需要解释一组概念了：</p>\\n<p>函数依赖又可以进一步分为直接函数依赖，传递函数依赖。直接函数依赖可以分为完全函数依赖于部分函数依赖。</p>\\n<ul>\\n<li>\\n<p>函数依赖</p>\\n<ul>\\n<li>\\n<p>直接函数依赖</p>\\n<ul>\\n<li>完全函数依赖</li>\\n<li>部分函数依赖</li>\\n</ul>\\n</li>\\n<li>传递函数依赖</li>\\n</ul>\\n</li>\\n</ul>\\n<h3>函数依赖</h3>\\n<p><code>R(U)</code>是属性集<code>U</code>上的关系模式，<code>X</code>、<code>Y</code>为<code>U</code>的子集，对\\n于<code>R(U)</code>的任何一个关系实例，不存在两个元组在<code>X</code>上的属性相同，在<code>Y</code>上的属性值不同，就称为<code>X</code>决定<code>Y</code>，<code>Y</code>函数依赖于<code>X</code>，记为<code>X->Y</code>。</p>\\n<p>即在一张表内，某个属性或者属性组<code>X</code>确定后，<code>Y</code>就一定可以确定出来，类似于函数<code>Y=F(x)</code>，<code>X</code>是确定的，那么<code>Y</code>也一定可以明确得出，需要注意<code>X</code>,<code>Y</code>都是关系的属性或者属性组。</p>\\n<p><img src=\\\"2018-02-22-14-51-45.png\\\" alt=\\\"函数依赖\\\">\\t</p>\\n<p>上表中的学号确定后，都可以随之确定姓名和班级，并非指一一对应，而是说同一个学号，绝不会对应两个不同的姓名或者班级，这便叫做姓名和班级依赖于学号，学号决定姓名与班级。记为<code>学号->{姓名,班级}</code></p>\\n<h3>候选码、主码、码、主属性、非主属性、全码</h3>\\n<p>定义一个关系模式<code>R(U)</code>，<code>U</code>表示属于这个关系模式的所有属性的集合。</p>\\n<p>比如下面这个关系模式</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-sql\\\"><code>学生<span class=\\\"token punctuation\\\">(</span>学号<span class=\\\"token punctuation\\\">,</span>姓名<span class=\\\"token punctuation\\\">,</span>班级<span class=\\\"token punctuation\\\">,</span>家庭住址<span class=\\\"token punctuation\\\">,</span>电话号码<span class=\\\"token punctuation\\\">)</span>\\n</code></pre>\\n      </div>\\n<p>关系模式学生，它的所有属性的集合<code>U</code>就是</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-sql\\\"><code>u <span class=\\\"token operator\\\">=</span> {学号<span class=\\\"token punctuation\\\">,</span>姓名<span class=\\\"token punctuation\\\">,</span>班级<span class=\\\"token punctuation\\\">,</span>家庭住址<span class=\\\"token punctuation\\\">,</span>电话号码}\\n</code></pre>\\n      </div>\\n<p>有了以上定义，我们就可以开始了。</p>\\n<h4>候选码</h4>\\n<p>如果一个关系内部，有某个属性或者属性组，可以唯一表示它坐在的元组，而它的子集不能，称这个属性或者属性组为<strong>候选码</strong>。</p>\\n<p>如何在复杂的关系中一个不拉的确定候选码是非常重要的一步骤，一会儿来说，先掌握候选码的概念。</p>\\n<h4>主码</h4>\\n<p>一个关系中的候选码可以有多个，任选其中之一，称其为<strong>主码</strong>。</p>\\n<h4>主属性与非主属性</h4>\\n<p>一个关系可能有多个候选码，只要在这些候选码中的属性都称为<strong>主属性</strong>。用<code>U</code>属性集合，减去主属性集合，剩余的就是<strong>非主属性</strong>了。</p>\\n<p>比如下面的例子</p>\\n<p><img src=\\\"2018-02-22-15-27-53.png\\\" alt=\\\"主属性与非主属性\\\"></p>\\n<p>我试图解释的这个例子，仅仅有助于理解主属性和非主属性，前后衔接的话不一定是对的，后续说到与此处有关，能帮忙修正这个解释的概念时，我会特别说明。</p>\\n<p>在这里的学号是唯一的，自然它就是一个候选码了。再看看其他属性还能不能是候选码，在一个学校里面两个同学有相同的名字是很正常的，姓名属性一定不是候选码，班级和家庭住址（不排除双胞胎）也无法唯一确定一个学生。这里候选码就是学号。</p>\\n<p>用属性集合<code>U</code>去掉候选码内的属性，这里只有一个学号，剩余的属性集合<code>{姓名,班级,家庭住址}</code>就是非主属性。</p>\\n<h4>码</h4>\\n<p>主码和候选码都可以简称为码，具体码的所指，需要看上下文。</p>\\n<h3>完全函数依赖与部分函数依赖</h3>\\n<p><code>R(U)</code>为属性集<code>U</code>的关系模式，X决定Y，但对于X的任何一个真子集，都无法决定Y，将此时的函数依赖关系称为完全函数依赖。</p>\\n<p><code>R(u)</code></p>\\n<h2>参考</h2>\\n<ul>\\n<li><a href=\\\"https://www.zhihu.com/question/24696366\\\">解释一下关系数据库的第一第二第三范式？</a></li>\\n</ul>\",\"frontmatter\":{\"title\":\"数据库范式\",\"date\":\"2018-02-22\",\"tags\":[\"DB\"]}}},\"pathContext\":{\"slug\":\"/2018-02-18---database-3/\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/posts-2018-02-18-database-3.json\n// module id = 489\n// module chunks = 109917099093834"],"sourceRoot":""}