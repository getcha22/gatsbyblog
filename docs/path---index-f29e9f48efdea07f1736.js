webpackJsonp([0x81b8806e4260],{460:function(e,s){e.exports={data:{allMarkdownRemark:{edges:[{node:{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/2018-02-28----c-language-exercises-4/index.md absPath of file >>> MarkdownRemark",excerpt:"C语言习题（四） 关于二维数组的指针问题 a 表示二维数组首元素的地址，即表示了 a[0] 这个数组的首地址，按照常理， a[0] 应该是个指针，存着 a[0][0] 的地址。然后事实上， a[0] 这个值是通过C编译器维护的，并非真实存在的物理地址。 a[0] 存储着 a[0][0] 的地址\n a 存储着整个二维数组首元素 a[0][0] 的地址\n *a 存储着 a[0] 的地址\na和a 0 都存着a 0 的地址，值是相同的。但是指针的基类型不同，a是一个二维数组\n对二维数组a来说，它的元素a…",frontmatter:{title:"C语言习题（四）",date:"2018-03-06",tags:["C"],popular:null,nopublish:!0},wordCount:{paragraphs:7,sentences:7,words:50},fields:{slug:"/2018-02-28----c-language-exercises-4/"}}},{node:{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/2018-02-28----c-language-exercises-3/index.md absPath of file >>> MarkdownRemark",excerpt:"C语言习题（三） 以下谭版C语言（第四版）第三章的习题 3计算多少月可以还清 C语言中没有关于对数的过多函数，只定义的两个函数即 y=log(double x) 和 y=log10(double x) ， log 代表以 e 为底数， log10 则是以10为底数，需要引入math库。 log2(3) 可用换底公式表示为 log(3)/log(2) 。 一般来说，如果需要使用小数则使用 double 类型，如果永远不会使用小数则使用 int…",frontmatter:{title:"C语言习题（三）",date:"2018-02-28",tags:["C"],popular:null,nopublish:null},wordCount:{paragraphs:39,sentences:39,words:139},fields:{slug:"/2018-02-28----c-language-exercises-3/"}}},{node:{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/2018-02-18---database-3/index.md absPath of file >>> MarkdownRemark",excerpt:"数据库范式 TODO List √ 1ND概念，1ND例子 []2ND概念，2ND []3ND概念，3ND例子，2ND如何分解得到3ND []4ND…",frontmatter:{title:"数据库范式",date:"2018-02-22",tags:["DB"],popular:null,nopublish:!0},wordCount:{paragraphs:52,sentences:52,words:192},fields:{slug:"/2018-02-18---database-3/"}}},{node:{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/2018-02-18---database-2/index.md absPath of file >>> MarkdownRemark",excerpt:"数据库学习（二）(待续) 子查询 表达式表示一个计算结果，子查询的结果仍然是一个关系，\n两个关系做笛卡尔积，之后从中选取满足一定条件的子集，就叫做连接。\n连接两个表的操作，会被用在 等值连接查询 自然连接查询 非等值连接查询 自身连接查询 外连接查询 复合条件连接查询 等值连接查询 等值连接和非等值连接是对立的。对两张表做笛卡尔积后，选择其中某些属性相同的元祖，称为等秩连接。 等值连接之后",frontmatter:{title:"数据库学习（二）",date:"2018-02-18",tags:["MySQL","SQL"],popular:null,nopublish:!0},wordCount:{paragraphs:14,sentences:14,words:33},fields:{slug:"/2018-02-18---database-2/"}}},{node:{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/2018-02-17---database-1/index.md absPath of file >>> MarkdownRemark",excerpt:"数据库学习（一）(待续) 选择默认数据库(在MySQL中， schema 是与 database 类似的概念) 基本表 创建基本表 修改基本表 创建基本表 修改基本表 表名： 针对于列的增加，删除，修改数据类型或者列名，在删除列的时候，可以依据在被其他对象引用时是否直接删除做 [cascade|restrict] 的设置，下面的每个分号完成一个操作 表级完整性约束有 primary key|unique|foreign key ， not null…",frontmatter:{title:"数据库学习（一）",date:"2018-02-17",tags:["MySQL","SQL"],popular:null,nopublish:!0},wordCount:{paragraphs:73,sentences:73,words:276},fields:{slug:"/2018-02-17---database-1/"}}},{node:{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/2018-02-12---why-is-gatsby-fast/index.md absPath of file >>> MarkdownRemark",excerpt:"为什么选择GatsbyJS（待完善） 熟悉React技术栈的开发者，应该会喜欢GatsbyJS，它基于React，在此基础之上，有些场景下，可以完全摆脱后端自己处理数据，之后使用React那一套 props 组件传递，将数据逐层分配下去。\nGatsbyJS在2015年中由Kyle Mathews开源，项目后来不断壮大，目前已经拥有了13k的star。 谁也不喜欢对着一个没有交互，加载速度又很慢的网站， 网站的内容多久能被看到（速度指数，Speed Index…",frontmatter:{title:"为什么选择GatsbyJS？",date:"2018-02-12",tags:["React","JavaScript"],popular:!0,nopublish:!0},wordCount:{paragraphs:21,sentences:21,words:88},fields:{slug:"/2018-02-12---why-is-gatsby-fast/"}}},{node:{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/2018-01-12---os-2/index.md absPath of file >>> MarkdownRemark",excerpt:"操作系统（二） 操作系统如何管理物理主存？ 计算机体系结构、主存结构分层 CPU芯片内部有寄存器和Cache，操作系统无法直接访问管理，这一层次的主存容量小但是数据很快。 在主存结构中有一块很大的区域，即主存或者物理主存。这块区域可以用来放置操作系统本身代码以及其他要运行的程序，主存容量大，速度慢。 计算机中可以在主存中存放着多个可运行的程序，若CPU的运行速度很快，且这些可运行的程序都需要很大的主存，那么CPU…",frontmatter:{title:"操作系统（二）",date:"2018-01-12",tags:["os","memory"],popular:null,nopublish:null},wordCount:{paragraphs:40,sentences:40,words:170},fields:{slug:"/2018-01-12---os-2/"}}},{node:{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/2018-01-10---os-1/index.md absPath of file >>> MarkdownRemark",excerpt:"操作系统（一） 按下电源之后，如何加载操作系统？ 操作系统如何与外设、应用程序交互？ BIOS、BootLoader、OS的关系 BIOS即基本输入输出系统，存在CMOS中，OS即操作系统，操作系统存在硬盘中。硬盘中还存另一个简单的小程序BootLoader，它可以将OS从硬盘放到内存中去，使cpu可以执行OS相关的代码。 一开始加电，CPU从一个预先约定的地址处开始执行BIOS程序，进行加电自检（显卡，键鼠，硬盘），检查成功，即外设均可正常工作，接着要将BootLoader…",frontmatter:{title:"操作系统（一）",date:"2018-01-10",tags:["os","Bootloader"],popular:null,nopublish:null},wordCount:{paragraphs:36,sentences:36,words:161},fields:{slug:"/2018-01-10---os-1/"}}},{node:{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-10-02---git-develop-workflow/index.md absPath of file >>> MarkdownRemark",excerpt:"Git 学习小记之开发工作流 经过上面几次学习，再结合日常的使用，现在对于分支已经有了比较细致的了解，今天补充的是利用分支进行开发的工作流，有利于帮助工程更快更安全的开发。 长期分支 浏览GitHub上的仓库，很多都是在 master 分支上保留着稳定代码，这部分可能是需要发布或者已经在使用的代码。在此基础上，可能还会有 dev 开发分支， staging 测试分支等等，这些分支专门用来开发测试，当这些开发分支到达一定程度，可以提供稳定的特性；或者完成了开发任务，就可以合并到 master…",frontmatter:{title:"Git 学习小记之开发工作流",date:"2017-10-02",tags:["Git"],popular:null,nopublish:null},wordCount:{paragraphs:18,sentences:18,words:111},fields:{slug:"/2016-10-02---git-develop-workflow/"}}},{node:{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/2017-04-30---numpy-ndarray/index.md absPath of file >>> MarkdownRemark",excerpt:"numpy入门——ndarray介绍 下文主要围绕ndarray类型，介绍相关运算。 ndarray是numpy支持的数据类型，numpy相关运算的对象都是它。我们知道python已经自带了很多基础类型，比如列表，元组等等，numpy的ndarray可以理解为自由受限，但功能加强版的list类型。之所以抛弃更开放的list…",frontmatter:{title:"numpy入门——ndarray介绍",date:"2017-04-30",tags:["Numpy","ML","Python"],popular:null,nopublish:null},wordCount:{paragraphs:29,sentences:30,words:122},fields:{slug:"/2017-04-30---numpy-ndarray/"}}},{node:{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/2015-07-10---anaconda-introduction/index.md absPath of file >>> MarkdownRemark",excerpt:"Anaconda介绍 Anaconda 是一个第三方开源免费IDE，它本质上是第三方库和主流工具的集成平台。支持市面上主流的第三方库和工具，非常适合数据计算相关领域，且它支持跨平台。\nAnaconda可以直接从官网上面下载，它会随着Python版本的更新不断更新。 conda 很多人听过conda，它是什么？\nconda其实是一个进行用户包管理（类似pip）和Python环境管理（切换Python版本）的工具。日常中我们经常使用conda为旧程序配置Python2，新程序配置Python…",frontmatter:{title:"Anaconda介绍",date:"2017-04-10",tags:["Python","Anaconda"],popular:null,nopublish:null},wordCount:{paragraphs:12,sentences:12,words:52},fields:{slug:"/2015-07-10---anaconda-introduction/"}}},{node:{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/2017-03-10---knn-2/index.md absPath of file >>> MarkdownRemark",excerpt:"机器学习之k-NN算法实战(二) 回顾上文，我们介绍了k-NN算法的原理，以及实例数据的格式，如何加载。万事俱备，下文我们来介绍k-NN算法的代码实现。 首先从store中取出样本数据，存到局部变量中 之后我们利用这些数据来进行k-NN分类 上面的函数，我们需要的参数为测试向量，训练向量集，以及K值。我们将待测试的向量铺成和训练集相同shape的矩阵，之后直接求欧氏距离，按照预设去k…",frontmatter:{title:"机器学习之k-NN算法实战(二)",date:"2017-03-10",tags:["ML","KNN"],popular:null,nopublish:null},wordCount:{paragraphs:19,sentences:19,words:68},fields:{slug:"/2017-03-10---knn-2/"}}},{node:{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/2017-03-04---knn-1/index.md absPath of file >>> MarkdownRemark",excerpt:"机器学习之k-NN算法实战(一) 下文会介绍机器学习的k-NN算法，首先大致介绍k-NN算法的原理，之后我们会通过识别手写体数字这个小项目，来讲解k-NN分类算法的代码实现。 k-NN算法原理 所谓k-NN算法，全名为是一种分类算法，它属于监督式算法，也就是说对于这个算法，必须提前对数据打标签，否则无法完成分类。其次，k-NN又被人们称为是“懒汉”算法，或者说“惰性学习”，这是因为k-NN并不会像神经网络，线性回归那样直接训练出一个模型来，下文会逐步介绍。 使用k-NN…",frontmatter:{title:"机器学习之k-NN算法实战(一)",date:"2017-03-04",tags:["ML","KNN"],popular:!0,nopublish:null},wordCount:{paragraphs:17,sentences:17,words:91},fields:{slug:"/2017-03-04---knn-1/"}}},{node:{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/2017-02-12---mysql-operation/index.md absPath of file >>> MarkdownRemark",excerpt:"MySQL常用操作 下文整理一些常用的操作 初始信息 MySQL默认的端口号码是3306，服务器是本地localhost\n查看MySQL版本 常用规范 关键字函数名一律使用大写（但使用小写不会报错） 数据库名，变量名使用小写 末尾要加分号 数据库 数据库广义上说应该是一个框架，我们针对这个框架创造它所包含的数据库文件。 创建数据库 CREATE DATABASE  IF NOT EXSITS  database name\n[CHARACTER SET character set…",frontmatter:{title:" MySQL常用操作",date:"2017-02-12",tags:["MySQL"],popular:null,nopublish:null},wordCount:{paragraphs:31,sentences:31,words:92},fields:{slug:"/2017-02-12---mysql-operation/"}}},{node:{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/2017-01-22---tmux-operation/index.md absPath of file >>> MarkdownRemark",excerpt:"tmux基本操作 电脑换回了win10系统，使用bash on windows进行开发，有个问题一直很困扰。\n在windows系统下面，少见非常优秀的，类似iTerm2那样的终端软件。使用cmder对于bash的美化确实起到了很大的作用，但是对屏幕的管理依然不方便。最近留意到了tmux这款终端复用工具，简单使用后，发现它的确非常棒，给我带来了不少的便利。 Session 创建一个Session，默认情况下，当在shell中输入 tmux 时，就会自动创建一个名称为 0 的Session…",frontmatter:{title:"tmux日常操作",date:"2017-01-22",tags:["Tmux","Linux"],popular:null,nopublish:null},wordCount:{paragraphs:11,sentences:11,words:42},fields:{slug:"/2017-01-22---tmux-operation/"}}},{node:{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/2017-01-01---final-summary-2016/index.md absPath of file >>> MarkdownRemark",excerpt:"2016年终总结 2016年，已经2…",frontmatter:{title:"2016年终总结",date:"2017-01-01",tags:["summary"],popular:null,nopublish:null},wordCount:{paragraphs:45,sentences:45,words:530},fields:{slug:"/2017-01-01---final-summary-2016/"}}},{node:{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-11-12---node-module-loader/index.md absPath of file >>> MarkdownRemark",excerpt:"Node原生模块加载器 Node.js包含一个简单的模块加载器，在Node.js 中，文件和模块是一一对应的，比如下面这个例子， foo.js 装载在处于相同目录的 circle.js foo.js 中的内容： circle.js 中的内容: circle.js 模块导出了两个函数 area() 和 circumference() 。 为了将函数或者对象添加到模块上，你可以将它们添加给特殊的对象 exports 。 模块中的局部变量是模块私有的，因为模块最终会被包裹在 Node.js…",frontmatter:{title:"Node原生模块加载器",date:"2016-11-12",tags:["Node"],popular:null,nopublish:null},wordCount:{paragraphs:34,sentences:35,words:83},fields:{slug:"/2016-11-12---node-module-loader/"}}},{node:{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-10-01---node-file-system/index.md absPath of file >>> MarkdownRemark",excerpt:"Node文件系统 Node 通过封装基本的 POSIX 函数来提供文件系统，使用 require('fs') 来使用这个模块，所有与文件相关的方法，都提供了异步和同步的形式。 异步的方法通常会将一个可选的回调函数作为最后一个参数，回调函数的第一个参数通常留给意外情况，如果操作是成功的，第一个参数将是 null 或者 undeefined 。 使用同步方法，对于任何意外都会即时抛出，可以使用 try/catch…",frontmatter:{title:"Node文件系统",date:"2016-10-01",tags:["Node","JS"],popular:null,nopublish:null},wordCount:{paragraphs:15,sentences:15,words:107},fields:{slug:"/2016-10-01---node-file-system/"}}},{node:{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-09-10---git-alias/index.md absPath of file >>> MarkdownRemark",excerpt:"Git 学习小记之使用别名 Git 是在开发中需要频繁使用的工具，如何高效使用，除了深刻理解用法之外，还可以利用一些别名来减少操作。 Git 中的省略其实无处不在，事实上在我们 push 的时候使用的  git push origin master ，意思就是 git push origin master:master （将本地的 master 分支推送至远端的 master 分支，如果没有就新建一个），这就是一个省略了。 哈哈，开玩笑的，下面开始进入正题了，想要使用别名，需要先在 Git…",frontmatter:{title:"Git 学习小记之使用别名",date:"2016-09-10",tags:["Git"],popular:!0,nopublish:null},wordCount:{paragraphs:10,sentences:10,words:59},fields:{slug:"/2016-09-10---git-alias/"}}},{node:{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-09-07---js-function-2/index.md absPath of file >>> MarkdownRemark",excerpt:"再探JS函数 函数是JS的核心概念，主要用来封装语句，封装单独的功能。 函数参数 函数不在意它本身到底接收多少参数，不关心最后会使用多少参数。因为函数只会接收一个数组，函数可以通过 arguments 属性来访问这个参数数组。关于这个数组，他其实是个对象，如下: 但是为什么又说它是数组呢，因为它本身很数组很像，可以通过方括号加数字的方法来访问具体的参数，同时还有数组对象有的 length 属性。一个有趣的例子： 这样子依然是有效的，在函数执行的时候，通过 arguments 对象的 length…",frontmatter:{title:"再探JS函数",date:"2016-09-07",tags:["JS","function"],popular:null,nopublish:null},wordCount:{paragraphs:20,sentences:20,words:84},fields:{slug:"/2016-09-07---js-function-2/"}}},{node:{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-06-03---shadowsocks-install/index.md absPath of file >>> MarkdownRemark",excerpt:"ShadowSocks 安装记录 这里使用的是  ubuntu 14.04 ,是我比较喜欢的一个系统。\n首先更新  apt  源，保证获取最新的软件 之后安装  python  相关依赖， pip  包管理器，可能是类似  npm  的一种吧，没有细致研究过 通过  pip  安装  ShadowSocks 配置  ShadowSocks  的配置文件  vim /etc/shadowsocks.json server  表示当前服务器的  ip  地址， password…",frontmatter:{title:"ShadowSocks 安装记录",date:"2016-09-01",tags:["Linux","shadowsocks"],popular:null,nopublish:null},wordCount:{paragraphs:10,sentences:10,words:37},fields:{slug:"/2016-06-03---shadowsocks-install/"}}},{node:{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-09-01---git-branch/index.md absPath of file >>> MarkdownRemark",excerpt:"Git学习小记之分支原理 如果想要熟练使用Git，没有分支理念是绝对行不通的，在用 Git 管理项目的时候，经常需要使用 commit 这个命令，那么这个 commit 到底是指什么呢？ 按照官方的解释，这应该成为一个对象，它包含着一个指向暂存内容(被 add 的文件)快照的指针，包含本次提交的附属信息，比如说作者等等，指向父 commit 对象(如果被 merge 而成，可能有多个父 commit 对象)的指针。 举下面这个例子来分析： add ：暂存操作会对文件计算校验和(SHA-…",frontmatter:{title:"Git学习小记之分支原理",date:"2016-09-01",tags:["Git"],popular:null,nopublish:null},wordCount:{paragraphs:35,sentences:35,words:232},fields:{slug:"/2016-09-01---git-branch/"}}},{node:{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-08-26---js-function-1/index.md absPath of file >>> MarkdownRemark",excerpt:"初探JS函数 有关函数相关的话题在网上讨论的并不够多，因为它比较复杂，这也是为什么现在网上会存在如此多的误解。 在这片文章里面，我会试着去总结有关函数的好的，坏的，丑陋的一面。 函数表达式 VS. 函数声明 在 ECMAScript 中，如果需要使用函数，最常用的两种方法就是通过函数表达式和函数声明。掌握它们区别非常重要，因为在JS 中两者的执行是有差别的，可惜很不爽，至少在看来， 两者之间的差别可以说是相当混乱，只有一件事是 ECMA…",frontmatter:{title:"初探JS函数",date:"2016-08-26",tags:["JS","function"],popular:null,nopublish:null},wordCount:{paragraphs:12,sentences:13,words:92},fields:{slug:"/2016-08-26---js-function-1/"}}},{node:{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-08-20---git-add/index.md absPath of file >>> MarkdownRemark",excerpt:"Git 学习小记之 add 所谓 add 操作，就是 add file into staged area 。下面针对两种情况进行讨论： 新建的文件 旧文件 新建的文件 我们了解 add 是一个重要的操作。假设有一个空目录，此时里面没有任何文件。\n我们新建一个文件，这个文件就是处于 untrack 状态的，可以理解为未被跟踪状态。 此时修改这个文件，依然是处于 untrack 状态。在此时使用 add 操作，有两个作用： 将新文件添加到暂存区( staged ) 将文件标记为  track…",frontmatter:{title:"Git 学习小记之 add",date:"2016-08-20",tags:["Git"],popular:!0,nopublish:null},wordCount:{paragraphs:21,sentences:21,words:94},fields:{slug:"/2016-08-20---git-add/"}}},{node:{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-08-12---pixel-layout/index.md absPath of file >>> MarkdownRemark",excerpt:"布局像素的辨析 下文主要介绍了一些关于分辨率的基础概念。 物理分辨率 所谓物理分辨率，是指一块屏幕上，横向有多少个像素点，纵向有多少个像素点，比如苹果5的分辨率是640x1136，代表它横向有640个像素点，纵向拥有1136个像素点。看官也听出来了，这个物理分辨率是屏幕自带的固定参数，无法更改。 屏幕尺寸 屏幕尺寸指屏幕对角线的长度，根据横向长度和纵向长度进一步计算得到，使用英寸为单位，比如苹果5的尺寸为4.…",frontmatter:{title:"布局像素的辨析",date:"2016-08-12",tags:["CSS"],popular:!0,nopublish:null},wordCount:{paragraphs:21,sentences:21,words:119},fields:{slug:"/2016-08-12---pixel-layout/"}}},{node:{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-07-03---es6-string/index.md absPath of file >>> MarkdownRemark",excerpt:"ES6中的字符串 在ES6中， Iterator 也被添加给了字符串，这样代表字符串可以使用 for ... of 循环了。 字符串查找 接下来介绍一些可以通过 ES5 PolyFill的方法，但是现在 ES6 原生实现了 Method Param Return Description includes() 需要验证是否被包含的字符串 Boolean 表示是否调用此方法的字符串是否包含参数中的字符串 startsWith() 需要被验证的字符串 Boolean…",frontmatter:{title:"ES6中的字符串",date:"2016-07-03",tags:["ES6","JS"],popular:null,nopublish:null},wordCount:{paragraphs:14,sentences:14,words:44},fields:{slug:"/2016-07-03---es6-string/"}}},{node:{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-05-07---js-logic-operation/index.md absPath of file >>> MarkdownRemark",excerpt:"JS 中的逻辑运算总结，FOR效率 在编程中，布尔操作符占了很大一部分，判断语句除了依赖相等操作符，还严重依赖这些布尔操作符，逻辑运算中的布尔操作符也有很多“奇淫巧计”。最近我抱着学习的态度不断浏览一些简单开源的项目，发现对于这一块太不熟练了，急需做个学习整理。 在正式开始之前，先需要区分 && 、 ||  与 if 语句，他们完全是没有关联， if…",frontmatter:{title:"JS 中的逻辑运算总结，FOR效率",date:"2016-05-07",tags:["JS"],popular:null,nopublish:null},wordCount:{paragraphs:11,sentences:11,words:80},fields:{slug:"/2016-05-07---js-logic-operation/"}}},{node:{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-05-03---opensauce/index.md absPath of file >>> MarkdownRemark",excerpt:"opensauce单元测试 为开源项目提供免费的云测试\n https://saucelabs.com/opensauce/ 推荐文章 https://philipwalton.com/articles/learning-how-to-set-up-automated-cross-browser-javascript-unit-testing/ 中文版\n http://www.jianshu.com/p/d079b9c61450",frontmatter:{title:"opensauce单元测试",date:"2016-05-03",tags:["opensauce","unit testing"],popular:null,nopublish:null},wordCount:{paragraphs:6,sentences:6,words:22},fields:{slug:"/2016-05-03---opensauce/"}}},{node:{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-04-21---react-summary/index.md absPath of file >>> MarkdownRemark",excerpt:"React学习总结 参考官方文档，整理一些应该被重视的知识点 React中的事件相关 类似HTML中事件的使用方法，可以直接将事件处理函数作为属性值，赋给用驼峰式命名的事件属性。之后的事情交给React，React自己有一个事件系统，它可以保证事件在所有浏览器中的一致性，React知道如何去冒泡和捕获事件，这个实现是根据w3c的规范，不管使用的是什么浏览器 State 相关 State是可以用来动态渲染，和props是一对好基友。 State 的异步工作方式 setState…",frontmatter:{title:"React学习总结",date:"2016-04-21",tags:["React","JS"],popular:null,nopublish:null},wordCount:{paragraphs:20,sentences:20,words:136},fields:{slug:"/2016-04-21---react-summary/"}}},{node:{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-04-06---regular-expression-2/index.md absPath of file >>> MarkdownRemark",excerpt:"正则表达式进阶 接上一篇内容，上一篇主要介绍了正则表达式的核心内容，非常的简单易懂，现在对核心内容进行拓展。 界定符 表示正则表达式的开始和结束，具体的由解析器决定 /[0-9]/ #[0-9]# 元字符 元字符定义了原子的筛选方式，可以将某一类原子归类，并且给出缩写，简化正则： | 匹配两个或者多个分支 [] 中括号内部的任意一个原子 [^] 匹配除括号内部原子之外的任何字符 原子的筛选 使用 [] 可以进行原子的筛选，代表或者的关系， [^] 代表非的关系 [Dd]uang (D|d…",frontmatter:{title:"正则表达式进阶",date:"2016-04-06",tags:["regular expression"],popular:null,nopublish:null},wordCount:{paragraphs:43,sentences:43,words:84},fields:{slug:"/2016-04-06---regular-expression-2/"}}},{node:{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-04-05---regular-expression-1/index.md absPath of file >>> MarkdownRemark",excerpt:"正则表达式核心 若有多个字符串，其中一个字符串中包含部分内容，我们使用正则来进行匹配，匹配的结果到底什么？是包含匹配内容的那个字符串？还是只有匹配的内容？ Go Ahead~ 正则表达式的核心概念就是元字符，它一点也不复杂，掌握了元字符，就可以正则表达式的能力有所了解。 接下来的每一节，我都会介绍数个元字符，最终本文结束时，读者就会对正则表达式的核心元字符有大概的了解。 从 hi, Hao 开始 hi, Hao 这样一个字符串，如果使用正则表达式匹配到 hi ？这非常简单，我们使用 js…",frontmatter:{title:"正则表达式核心",date:"2016-04-05",tags:["regular expression"],popular:!0,nopublish:null},wordCount:{paragraphs:38,sentences:39,words:203},fields:{slug:"/2016-04-05---regular-expression-1/"}}},{node:{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-02-07---js-in/index.md absPath of file >>> MarkdownRemark",excerpt:"JavaScript 中的 in 关键字 在 JavaScript 中,我经常会使用 for(key in ..) 语句来遍历对象的 key  ,这是一种很常用的方式.\n这里需要留意, 其实 for(.. in ..) 语句也可以用来遍历数组,其中的 key 就是数组的 index (索引值,0开始) 。\n除了在 for(.. in ..) 语句中使用, in 也可以作为一个单独的关键字使用,用来判断某个属性或者元素是否存在与数组或者对象.一般会用在判断语句中,下面进行说明。 数组 通过 in…",frontmatter:{title:"JavaScript 中的 in 关键字",date:"2016-02-07",tags:["JS"],popular:!0,nopublish:null},wordCount:{paragraphs:13,sentences:13,words:69},fields:{slug:"/2016-02-07---js-in/"}}},{node:{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/2015-10-05---css-summary/index.md absPath of file >>> MarkdownRemark",excerpt:"CSS 总结 计划总结常用的CSS知识 基本布局 下面汇总了传统的绝对，浮动，表格与凝胶等布局方式的优缺点 绝对布局 优点：主内容随页面宽度，固定边栏 缺点：浏览器变宽的时候，页脚可能会遮住边栏，同时浏览器变宽后，主内容区和边栏的比例会不协调。 表格显示布局 优点：使用 table 标签，随窗口缩放 缺点：对于语义化不利 凝胶布局 优点：主内容区建立后，设置左右margin为…",frontmatter:{title:"CSS 总结",date:"2015-10-5",tags:["css"],popular:null,nopublish:null},wordCount:{paragraphs:22,sentences:22,words:67},fields:{slug:"/2015-10-05---css-summary/"}}},{node:{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/2015-07-10---rails-install/index.md absPath of file >>> MarkdownRemark",excerpt:"Rails 安装记录 本文 ubuntu 版本为 14.04stl 64bit ，参考教程： http://rails-practice.com/content/Chapter_1/1.1.html，  需要翻墙 Git ubuntu安装完毕之后，首先安装git，以便之后会用到： 配置身份信息： 核实信息是否有误： 此时已经能通过 http 正常拉去git上的内容，若想进一步配置 ssh ，可以参考 https://help.github.com/articles/generating-ssh…",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"],popular:null,nopublish:null},wordCount:{paragraphs:29,sentences:30,words:116},fields:{slug:"/2015-07-10---rails-install/"}}}],totalCount:34}},pathContext:{}}}});
//# sourceMappingURL=path---index-f29e9f48efdea07f1736.js.map