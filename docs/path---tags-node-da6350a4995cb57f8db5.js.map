{"version":3,"sources":["webpack:///path---tags-node-da6350a4995cb57f8db5.js","webpack:///./.cache/json/tags-node.json"],"names":["webpackJsonp","447","module","exports","pathContext","posts","Ruby","id","excerpt","frontmatter","title","date","tags","html","fields","slug","Rails","installtion-record","os","Bootloader","opensauce","unit testing","CSS","memory","React","JS","Git","css","regular expression","function","Linux","shadowsocks","ML","KNN","Node","Tmux","summary","post","tag"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,aAAeC,OAASC,OAASC,GAAA,kGAAAC,QAAA,GAAAC,aAAmIC,MAAA,aAAAC,KAAA,aAAAC,MAAA,sCAAsFC,KAAA,GAAAC,QAAqBC,KAAA,kBAAyBR,GAAA,4GAAAC,QAAA,GAAAC,aAA6IC,MAAA,aAAAC,KAAA,aAAAC,MAAA,sCAAsFC,KAAA,GAAAC,QAAqBC,KAAA,4BAAmCR,GAAA,0GAAAC,QAAA,GAAAC,aAA2IC,MAAA,aAAAC,KAAA,aAAAC,MAAA,sCAAsFC,KAAA,GAAAC,QAAqBC,KAAA,0BAAiCR,GAAA,uGAAAC,QAAA,GAAAC,aAAwIC,MAAA,aAAAC,KAAA,aAAAC,MAAA,sCAAsFC,KAAA,GAAAC,QAAqBC,KAAA,uBAA8BR,GAAA,qGAAAC,QAAA,GAAAC,aAAsIC,MAAA,aAAAC,KAAA,aAAAC,MAAA,sCAAsFC,KAAA,GAAAC,QAAqBC,KAAA,qBAA4BR,GAAA,0GAAAC,QAAA,GAAAC,aAA2IC,MAAA,aAAAC,KAAA,aAAAC,MAAA,sCAAsFC,KAAA,GAAAC,QAAqBC,KAAA,0BAAiCR,GAAA,qGAAAC,QAAA,uIAAAC,aAA0QC,MAAA,aAAAC,KAAA,aAAAC,MAAA,sCAAsFC,KAAA,+tJAAAC,QAAwxJC,KAAA,qBAA4BR,GAAA,gIAAAC,QAAA,GAAAC,aAAiKC,MAAA,aAAAC,KAAA,aAAAC,MAAA,sCAAsFC,KAAA,GAAAC,QAAqBC,KAAA,0CAA+CC,QAAYT,GAAA,kGAAAC,QAAA,GAAAC,aAAmIC,MAAA,aAAAC,KAAA,aAAAC,MAAA,sCAAsFC,KAAA,GAAAC,QAAqBC,KAAA,kBAAyBR,GAAA,4GAAAC,QAAA,GAAAC,aAA6IC,MAAA,aAAAC,KAAA,aAAAC,MAAA,sCAAsFC,KAAA,GAAAC,QAAqBC,KAAA,4BAAmCR,GAAA,0GAAAC,QAAA,GAAAC,aAA2IC,MAAA,aAAAC,KAAA,aAAAC,MAAA,sCAAsFC,KAAA,GAAAC,QAAqBC,KAAA,0BAAiCR,GAAA,uGAAAC,QAAA,GAAAC,aAAwIC,MAAA,aAAAC,KAAA,aAAAC,MAAA,sCAAsFC,KAAA,GAAAC,QAAqBC,KAAA,uBAA8BR,GAAA,qGAAAC,QAAA,GAAAC,aAAsIC,MAAA,aAAAC,KAAA,aAAAC,MAAA,sCAAsFC,KAAA,GAAAC,QAAqBC,KAAA,qBAA4BR,GAAA,0GAAAC,QAAA,GAAAC,aAA2IC,MAAA,aAAAC,KAAA,aAAAC,MAAA,sCAAsFC,KAAA,GAAAC,QAAqBC,KAAA,0BAAiCR,GAAA,qGAAAC,QAAA,uIAAAC,aAA0QC,MAAA,aAAAC,KAAA,aAAAC,MAAA,sCAAsFC,KAAA,+tJAAAC,QAAwxJC,KAAA,qBAA4BR,GAAA,gIAAAC,QAAA,GAAAC,aAAiKC,MAAA,aAAAC,KAAA,aAAAC,MAAA,sCAAsFC,KAAA,GAAAC,QAAqBC,KAAA,0CAA+CE,uBAAyBV,GAAA,kGAAAC,QAAA,GAAAC,aAAmIC,MAAA,aAAAC,KAAA,aAAAC,MAAA,sCAAsFC,KAAA,GAAAC,QAAqBC,KAAA,kBAAyBR,GAAA,4GAAAC,QAAA,GAAAC,aAA6IC,MAAA,aAAAC,KAAA,aAAAC,MAAA,sCAAsFC,KAAA,GAAAC,QAAqBC,KAAA,4BAAmCR,GAAA,0GAAAC,QAAA,GAAAC,aAA2IC,MAAA,aAAAC,KAAA,aAAAC,MAAA,sCAAsFC,KAAA,GAAAC,QAAqBC,KAAA,0BAAiCR,GAAA,uGAAAC,QAAA,GAAAC,aAAwIC,MAAA,aAAAC,KAAA,aAAAC,MAAA,sCAAsFC,KAAA,GAAAC,QAAqBC,KAAA,uBAA8BR,GAAA,qGAAAC,QAAA,GAAAC,aAAsIC,MAAA,aAAAC,KAAA,aAAAC,MAAA,sCAAsFC,KAAA,GAAAC,QAAqBC,KAAA,qBAA4BR,GAAA,0GAAAC,QAAA,GAAAC,aAA2IC,MAAA,aAAAC,KAAA,aAAAC,MAAA,sCAAsFC,KAAA,GAAAC,QAAqBC,KAAA,0BAAiCR,GAAA,qGAAAC,QAAA,uIAAAC,aAA0QC,MAAA,aAAAC,KAAA,aAAAC,MAAA,sCAAsFC,KAAA,+tJAAAC,QAAwxJC,KAAA,qBAA4BR,GAAA,gIAAAC,QAAA,GAAAC,aAAiKC,MAAA,aAAAC,KAAA,aAAAC,MAAA,sCAAsFC,KAAA,GAAAC,QAAqBC,KAAA,0CAA+CG,KAASX,GAAA,4FAAAC,QAAA,4IAAAC,aAAsQC,MAAA,UAAAC,KAAA,aAAAC,MAAA,oBAAiEC,KAAA,yhGAAAC,QAA2jGC,KAAA,YAAmBR,GAAA,4FAAAC,QAAA,0DAAAC,aAAoLC,MAAA,UAAAC,KAAA,aAAAC,MAAA,gBAA6DC,KAAA,4mFAAAC,QAA8nFC,KAAA,YAAiBI,aAAiBZ,GAAA,4FAAAC,QAAA,4IAAAC,aAAsQC,MAAA,UAAAC,KAAA,aAAAC,MAAA,oBAAiEC,KAAA,yhGAAAC,QAA2jGC,KAAA,YAAiBK,YAAgBb,GAAA,iGAAAC,QAAA,gJAAAC,aAA+QC,MAAA,gBAAAC,KAAA,aAAAC,MAAA,6BAAgFC,KAAA,qdAAAC,QAA6eC,KAAA,iBAAsBM,iBAAmBd,GAAA;AAAAC,QAAA,gJAAAC,aAA+QC,MAAA,gBAAAC,KAAA,aAAAC,MAAA,6BAAgFC,KAAA,qdAAAC,QAA6eC,KAAA,iBAAsBO,MAAUf,GAAA,oGAAAC,QAAA,mHAAAC,aAAqPC,MAAA,UAAAC,KAAA,aAAAC,MAAA,QAAqDC,KAAA,g4CAAAC,QAAk5CC,KAAA,oBAAyBQ,SAAahB,GAAA,4FAAAC,QAAA,0DAAAC,aAAoLC,MAAA,UAAAC,KAAA,aAAAC,MAAA,gBAA6DC,KAAA,4mFAAAC,QAA8nFC,KAAA,YAAiBS,QAAYjB,GAAA,qGAAAC,QAAA,+GAAAC,aAAkPC,MAAA,YAAAC,KAAA,aAAAC,MAAA,eAA8DC,KAAA,i3DAAgvCC,QAAupBC,KAAA,qBAA0BU,KAASlB,GAAA,qGAAAC,QAAA,+GAAAC,aAAkPC,MAAA,YAAAC,KAAA,aAAAC,MAAA,eAA8DC,KAAA,i3DAAgvCC,QAAupBC,KAAA,qBAA4BR,GAAA,yHAAAC,QAAA,wGAAAC,aAA+PC,MAAA,SAAAC,KAAA,aAAAC,MAAA,kBAA8DC,KAAA,k9DAAq3CC,QAA6nBC,KAAA,mCAA0CR,GAAA,gHAAAC,QAAA,sIAAAC,aAAoRC,MAAA,uBAAAC,KAAA,aAAAC,MAAA,OAAiEC,KAAA,szCAAoiCC,QAAoSC,KAAA,0BAAiCR,GAAA,wHAAAC,QAAA,wHAAAC,aAA8QC,MAAA,SAAAC,KAAA,aAAAC,MAAA,kBAA8DC,KAAA,osEAA2rEC,QAA2BC,KAAA,kCAAyCR,GAAA,2HAAAC,QAAA,wDAAAC,aAAiNC,MAAA,WAAAC,KAAA,aAAAC,MAAA,cAA4DC,KAAA,67HAAo7HC,QAA2BC,KAAA,qCAA0CW,MAAUnB,GAAA,kHAAAC,QAAA,gGAAAC,aAAgPC,MAAA,gBAAAC,KAAA,aAAAC,MAAA,QAA2DC,KAAA,80CAAAC,QAAg2CC,KAAA,4BAAmCR,GAAA,qHAAAC,QAAA,sIAAAC,aAAyRC,MAAA,eAAAC,KAAA,aAAAC,MAAA,QAA0DC,KAAA,8vBAAAC,QAAkxBC,KAAA,+BAAsCR,GAAA,oHAAAC,QAAA,+IAAAC,aAAiSC,MAAA,gBAAAC,KAAA,aAAAC,MAAA,QAA2DC,KAAA,0wCAAmbC,QAA22BC,KAAA,8BAAmCY,MAAUpB,GAAA,sHAAAC,QAAA,qBAAAC,aAAyKC,MAAA,SAAAC,KAAA,YAAAC,MAAA,QAAmDC,KAAA,mzBAAAC,QAAq0BC,KAAA,gCAAqCa,uBAAyBrB,GAAA,+HAAAC,QAAA,0FAAAC,aAAuPC,MAAA,UAAAC,KAAA,aAAAC,MAAA,uBAAoEC,KAAA;AAA6wJC,QAAyhBC,KAAA,yCAAgDR,GAAA,+HAAAC,QAAA,mGAAAC,aAAgQC,MAAA,UAAAC,KAAA,aAAAC,MAAA,uBAAoEC,KAAA,ouDAAq9CC,QAAiSC,KAAA,yCAA8Cc,WAAetB,GAAA,yHAAAC,QAAA,wGAAAC,aAA+PC,MAAA,SAAAC,KAAA,aAAAC,MAAA,kBAA8DC,KAAA,k9DAAq3CC,QAA6nBC,KAAA,mCAA0CR,GAAA,wHAAAC,QAAA,wHAAAC,aAA8QC,MAAA,SAAAC,KAAA,aAAAC,MAAA,kBAA8DC,KAAA,osEAA2rEC,QAA2BC,KAAA,kCAAuCe,QAAYvB,GAAA,8HAAAC,QAAA,8IAAAC,aAA0SC,MAAA,mBAAAC,KAAA,aAAAC,MAAA,wBAA8EC,KAAA,wuCAA80BC,QAA0cC,KAAA,wCAA+CR,GAAA,yHAAAC,QAAA,8GAAAC,aAAqQC,MAAA,WAAAC,KAAA,aAAAC,MAAA,iBAA+DC,KAAA,ogDAA+vCC,QAAqSC,KAAA,mCAAwCgB,cAAkBxB,GAAA,8HAAAC,QAAA,8IAAAC,aAA0SC,MAAA,mBAAAC,KAAA,aAAAC,MAAA,wBAA8EC,KAAA,wuCAA80BC,QAA0cC,KAAA,wCAA6CiB,KAASzB,GAAA,gHAAAC,QAAA,0HAAAC,aAAwQC,MAAA,mBAAAC,KAAA,aAAAC,MAAA,aAAmEC,KAAA,olFAAsgEC,QAAgoBC,KAAA,0BAAiCR,GAAA,gHAAAC,QAAA,2GAAAC,aAAyPC,MAAA,mBAAAC,KAAA,aAAAC,MAAA,aAAmEC,KAAA,snEAAq+DC,QAAiLC,KAAA,0BAA+BkB,MAAU1B,GAAA,gHAAAC,QAAA,0HAAAC,aAAwQC,MAAA,mBAAAC,KAAA,aAAAC,MAAA,aAAmEC,KAAA,olFAAsgEC,QAAgoBC,KAAA,0BAAiCR,GAAA,gHAAAC,QAAA,2GAAAC,aAAyPC,MAAA,mBAAAC,KAAA,aAAAC,MAAA,aAAmEC,KAAA,snEAAq+DC,QAAiLC,KAAA,0BAA+BmB,OAAW3B,GAAA,2HAAAC,QAAA,wDAAAC,aAAiNC,MAAA,WAAAC,KAAA,aAAAC,MAAA,cAA4DC,KAAA,67HAAo7HC,QAA2BC,KAAA,qCAA0CoB,OAAW5B,GAAA,yHAAAC,QAAA,8GAAAC,aAAqQC,MAAA,WAAAC,KAAA,aAAAC,MAAA,iBAA+DC,KAAA,ogDAA+vCC,QAAqSC,KAAA,mCAAwCqB,UAAc7B,GAAA,6HAAAC,QAAA,sBAAAC,aAAiLC,MAAA,WAAAC,KAAA,aAAAC,MAAA,YAA0DC,KAAA;AAAAC,QAAswMC,KAAA,wCAA8CsB,OAAU9B,GAAA,2HAAAC,QAAA,wDAAAC,aAAiNC,MAAA,WAAAC,KAAA,aAAAC,MAAA,cAA4DC,KAAA,67HAAo7HC,QAA2BC,KAAA,qCAA0CuB,IAAA","file":"path---tags-node-da6350a4995cb57f8db5.js","sourcesContent":["webpackJsonp([71230123872026],{\n\n/***/ 447:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"pathContext\":{\"posts\":{\"Ruby\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/es6-string.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"\",\"fields\":{\"slug\":\"/es6-string/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/git-develop-workflow.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"\",\"fields\":{\"slug\":\"/git-develop-workflow/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/js-logic-operation.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"\",\"fields\":{\"slug\":\"/js-logic-operation/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/mysql-operation.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"\",\"fields\":{\"slug\":\"/mysql-operation/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/numpy-ndarray.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"\",\"fields\":{\"slug\":\"/numpy-ndarray/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/node-module-loader.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"\",\"fields\":{\"slug\":\"/node-module-loader/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/rails-install.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"Rails 安装记录 本文 ubuntu 版本为 14.04stl 64bit ，参考教程： http://rails-practice.com/content/Chapter_1/1.1.html，  需要翻墙 Git ubuntu安装完毕之后，首先安装git…\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"<h1>Rails 安装记录</h1>\\n<blockquote>\\n<p>本文<code>ubuntu</code>版本为<code>14.04stl 64bit</code>，参考教程：<a href=\\\"http://rails-practice.com/content/Chapter_1/1.1.html%EF%BC%8C\\\">http://rails-practice.com/content/Chapter_1/1.1.html，</a> 需要翻墙</p>\\n</blockquote>\\n<h2>Git</h2>\\n<p>ubuntu安装完毕之后，首先安装git，以便之后会用到：</p>\\n<pre><code class=\\\"language-bash\\\">sudo apt-get update\\nsudo apt-get install git-core\\n</code></pre>\\n<p>配置身份信息：</p>\\n<pre><code class=\\\"language-bash\\\">git config --global user.name \\\"xxx\\\"\\ngit config --global user.email \\\"xx@gmail.com\\\"\\n</code></pre>\\n<p>核实信息是否有误：</p>\\n<pre><code class=\\\"language-bash\\\">git config --list\\n</code></pre>\\n<p>此时已经能通过<code>http</code>正常拉去git上的内容，若想进一步配置<code>ssh</code>，可以参考<a href=\\\"https://help.github.com/articles/generating-ssh-keys/1323\\\">https://help.github.com/articles/generating-ssh-keys/1323</a></p>\\n<h2>RVM</h2>\\n<p><code>rails</code>需要先安装<code>Ruby</code>环境，<code>RVM</code>是<code>Ruby</code>管理工具，可以方便的安装、管理、切换多个<code>Ruby</code>，管理<code>Gemset</code>。</p>\\n<pre><code class=\\\"language-bash\\\">curl -sSL https://get.rvm.io | bash -s stable\\n</code></pre>\\n<p>此时会有如下提示：</p>\\n<pre><code class=\\\"language-bash\\\">getcha22@ubuntu:~/Desktop$ curl -sSL https://get.rvm.io | bash -s stable\\nDownloading https://github.com/rvm/rvm/archive/1.26.11.tar.gz\\nDownloading https://github.com/rvm/rvm/releases/download/1.26.11/1.26.11.tar.gz.asc\\ngpg: Signature made Mon 30 Mar 2015 02:52:13 PM PDT using RSA key ID BF04FF17\\ngpg: Can't check signature: public key not found\\nWarning, RVM 1.26.0 introduces signed releases and automated check of signatures when GPG software found.\\nAssuming you trust Michal Papis import the mpapis public key (downloading the signatures).\\nGPG signature verification failed for '/home/getcha22/.rvm/archives/rvm-1.26.11.tgz' - 'https://github.com/rvm/rvm/releases/download/1.26.11/1.26.11.tar.gz.asc'!\\ntry downloading the signatures:\\n    gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3\\nor if it fails:\\n    command curl -sSL https://rvm.io/mpapis.asc | gpg --import -\\nthe key can be compared with:\\n    https://rvm.io/mpapis.asc\\n    https://keybase.io/mpapi\\n</code></pre>\\n<p>按照提示，执行：</p>\\n<pre><code class=\\\"language-bash\\\">gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0\\n</code></pre>\\n<p>依然warring，继续按照提示</p>\\n<pre><code class=\\\"language-bash\\\">sudo curl -sSL https://rvm.io/mpapis.asc | gpg --import -\\n</code></pre>\\n<p>提示Thank you for using RVM!，OK，安装成功</p>\\n<h2>Ruby</h2>\\n<p>重启终端，开始安装<code>Ruby</code>，先使用<code>rvm list known</code>来查看可以按照的<code>Ruby</code>列表，按照参考的教程，我选择使用<code>2.2.0</code></p>\\n<pre><code class=\\\"language-bash\\\">rvm install 2.2.0123\\n</code></pre>\\n<p>在我安装的过程中，由于vpn不算稳定，出现了404的提示，我尝试重新安装，这次安装成功。 通过下面的命令检查当前的版本：</p>\\n<pre><code class=\\\"language-bash\\\">rvm list\\n</code></pre>\\n<p>提示结果：</p>\\n<pre><code class=\\\"language-bash\\\">rvm rubies\\n   ruby-2.2.0 [ x86_64 ]\\n</code></pre>\\n<p>再进一步核实<code>ruby</code>的版本， 此时由于<code>ubuntu</code>存在其他版本的<code>ruby</code>，需要制定默认的<code>ruby</code>版本，此时可以使用:</p>\\n<pre><code class=\\\"language-bash\\\">rvm --default use 2.2.0\\n</code></pre>\\n<p>发现有错误提示<code>RVM is not a function</code>,这个问题是由于<code>ubuntu</code>系统的终端导致 ，为了解决这个问题，需要<code>Run command as login shell</code>，参考这个链接进行解决：<a href=\\\"https://rvm.io/integration/gnome-terminal\\\">https://rvm.io/integration/gnome-terminal</a> ，之后重新制定默认版本，提示OK。</p>\\n<pre><code class=\\\"language-bash\\\">ruby 2.2.0p0 (2014-12-25 revision 49005) [x86_64-linux]\\n</code></pre>\\n<p>到此为止，<code>ruby</code>的安装告一段落，开始进行<code>Rails</code>的安装。</p>\\n<h2>Rails</h2>\\n<p>先设置<code>Gemset</code>。<code>Gemset</code> 是一个独立的 <code>Gem</code> 集合，可以为每个项目设置自己的 <code>Gemset</code>，而不会相互干扰：</p>\\n<pre><code class=\\\"language-bash\\\">rvm gemset create rails4.2\\nrvm use 2.2.0@rails4.2 --default\\ngem install rails -v 4.2.0 --no-ri --no-rdoc\\n</code></pre>\\n<p>出现如下问题:</p>\\n<pre><code class=\\\"language-bash\\\">ERROR:  While executing gem ... (Gem::RemoteFetcher::FetchError)\\n    Errno::ECONNRESET: Connection reset by peer - connect(2) for \\\"rubygems.global.ssl.fastly.net\\\" port 443 (https://api.rubygems.org/quick/Marshal.4.8/rails-4.2.4.gemspec.rz)\\n</code></pre>\\n<p>遇到这个问题，还提示端口是443.可能是<code>gem</code>源导致的网络问题，尝试修改https为http。通过以下命令:</p>\\n<pre><code class=\\\"language-bash\\\">gem sources\\ngem sources -a url //添加\\ngem sources -r url  //删除\\n更新source cache\\ngem sources -u\\n// other :\\ngem sources --add https://ruby.taobao.org/ --remove https://rubygems.org/\\ngem sources -l\\n</code></pre>\\n<p>之后重新进行安装，最后结束安装</p>\\n<pre><code class=\\\"language-bash\\\">Successfully installed rails-4.2.0\\n30 gems installed\\n</code></pre>\\n<h2>其他情况</h2>\\n<ul>\\n<li><code>bundle install</code>如果遇到问题，可以先把<code>gemfile</code>中的<code>source</code>修改成<code>http</code>开头即可，如果在操作时提示需要<code>javascript run time</code>，只要安装<code>Node.js</code>即可</li>\\n</ul>\",\"fields\":{\"slug\":\"/rails-install/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2015-07-10---anaconda-introduction/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"\",\"fields\":{\"slug\":\"/2015-07-10---anaconda-introduction/\"}}],\"Rails\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/es6-string.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"\",\"fields\":{\"slug\":\"/es6-string/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/git-develop-workflow.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"\",\"fields\":{\"slug\":\"/git-develop-workflow/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/js-logic-operation.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"\",\"fields\":{\"slug\":\"/js-logic-operation/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/mysql-operation.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"\",\"fields\":{\"slug\":\"/mysql-operation/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/numpy-ndarray.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"\",\"fields\":{\"slug\":\"/numpy-ndarray/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/node-module-loader.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"\",\"fields\":{\"slug\":\"/node-module-loader/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/rails-install.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"Rails 安装记录 本文 ubuntu 版本为 14.04stl 64bit ，参考教程： http://rails-practice.com/content/Chapter_1/1.1.html，  需要翻墙 Git ubuntu安装完毕之后，首先安装git…\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"<h1>Rails 安装记录</h1>\\n<blockquote>\\n<p>本文<code>ubuntu</code>版本为<code>14.04stl 64bit</code>，参考教程：<a href=\\\"http://rails-practice.com/content/Chapter_1/1.1.html%EF%BC%8C\\\">http://rails-practice.com/content/Chapter_1/1.1.html，</a> 需要翻墙</p>\\n</blockquote>\\n<h2>Git</h2>\\n<p>ubuntu安装完毕之后，首先安装git，以便之后会用到：</p>\\n<pre><code class=\\\"language-bash\\\">sudo apt-get update\\nsudo apt-get install git-core\\n</code></pre>\\n<p>配置身份信息：</p>\\n<pre><code class=\\\"language-bash\\\">git config --global user.name \\\"xxx\\\"\\ngit config --global user.email \\\"xx@gmail.com\\\"\\n</code></pre>\\n<p>核实信息是否有误：</p>\\n<pre><code class=\\\"language-bash\\\">git config --list\\n</code></pre>\\n<p>此时已经能通过<code>http</code>正常拉去git上的内容，若想进一步配置<code>ssh</code>，可以参考<a href=\\\"https://help.github.com/articles/generating-ssh-keys/1323\\\">https://help.github.com/articles/generating-ssh-keys/1323</a></p>\\n<h2>RVM</h2>\\n<p><code>rails</code>需要先安装<code>Ruby</code>环境，<code>RVM</code>是<code>Ruby</code>管理工具，可以方便的安装、管理、切换多个<code>Ruby</code>，管理<code>Gemset</code>。</p>\\n<pre><code class=\\\"language-bash\\\">curl -sSL https://get.rvm.io | bash -s stable\\n</code></pre>\\n<p>此时会有如下提示：</p>\\n<pre><code class=\\\"language-bash\\\">getcha22@ubuntu:~/Desktop$ curl -sSL https://get.rvm.io | bash -s stable\\nDownloading https://github.com/rvm/rvm/archive/1.26.11.tar.gz\\nDownloading https://github.com/rvm/rvm/releases/download/1.26.11/1.26.11.tar.gz.asc\\ngpg: Signature made Mon 30 Mar 2015 02:52:13 PM PDT using RSA key ID BF04FF17\\ngpg: Can't check signature: public key not found\\nWarning, RVM 1.26.0 introduces signed releases and automated check of signatures when GPG software found.\\nAssuming you trust Michal Papis import the mpapis public key (downloading the signatures).\\nGPG signature verification failed for '/home/getcha22/.rvm/archives/rvm-1.26.11.tgz' - 'https://github.com/rvm/rvm/releases/download/1.26.11/1.26.11.tar.gz.asc'!\\ntry downloading the signatures:\\n    gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3\\nor if it fails:\\n    command curl -sSL https://rvm.io/mpapis.asc | gpg --import -\\nthe key can be compared with:\\n    https://rvm.io/mpapis.asc\\n    https://keybase.io/mpapi\\n</code></pre>\\n<p>按照提示，执行：</p>\\n<pre><code class=\\\"language-bash\\\">gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0\\n</code></pre>\\n<p>依然warring，继续按照提示</p>\\n<pre><code class=\\\"language-bash\\\">sudo curl -sSL https://rvm.io/mpapis.asc | gpg --import -\\n</code></pre>\\n<p>提示Thank you for using RVM!，OK，安装成功</p>\\n<h2>Ruby</h2>\\n<p>重启终端，开始安装<code>Ruby</code>，先使用<code>rvm list known</code>来查看可以按照的<code>Ruby</code>列表，按照参考的教程，我选择使用<code>2.2.0</code></p>\\n<pre><code class=\\\"language-bash\\\">rvm install 2.2.0123\\n</code></pre>\\n<p>在我安装的过程中，由于vpn不算稳定，出现了404的提示，我尝试重新安装，这次安装成功。 通过下面的命令检查当前的版本：</p>\\n<pre><code class=\\\"language-bash\\\">rvm list\\n</code></pre>\\n<p>提示结果：</p>\\n<pre><code class=\\\"language-bash\\\">rvm rubies\\n   ruby-2.2.0 [ x86_64 ]\\n</code></pre>\\n<p>再进一步核实<code>ruby</code>的版本， 此时由于<code>ubuntu</code>存在其他版本的<code>ruby</code>，需要制定默认的<code>ruby</code>版本，此时可以使用:</p>\\n<pre><code class=\\\"language-bash\\\">rvm --default use 2.2.0\\n</code></pre>\\n<p>发现有错误提示<code>RVM is not a function</code>,这个问题是由于<code>ubuntu</code>系统的终端导致 ，为了解决这个问题，需要<code>Run command as login shell</code>，参考这个链接进行解决：<a href=\\\"https://rvm.io/integration/gnome-terminal\\\">https://rvm.io/integration/gnome-terminal</a> ，之后重新制定默认版本，提示OK。</p>\\n<pre><code class=\\\"language-bash\\\">ruby 2.2.0p0 (2014-12-25 revision 49005) [x86_64-linux]\\n</code></pre>\\n<p>到此为止，<code>ruby</code>的安装告一段落，开始进行<code>Rails</code>的安装。</p>\\n<h2>Rails</h2>\\n<p>先设置<code>Gemset</code>。<code>Gemset</code> 是一个独立的 <code>Gem</code> 集合，可以为每个项目设置自己的 <code>Gemset</code>，而不会相互干扰：</p>\\n<pre><code class=\\\"language-bash\\\">rvm gemset create rails4.2\\nrvm use 2.2.0@rails4.2 --default\\ngem install rails -v 4.2.0 --no-ri --no-rdoc\\n</code></pre>\\n<p>出现如下问题:</p>\\n<pre><code class=\\\"language-bash\\\">ERROR:  While executing gem ... (Gem::RemoteFetcher::FetchError)\\n    Errno::ECONNRESET: Connection reset by peer - connect(2) for \\\"rubygems.global.ssl.fastly.net\\\" port 443 (https://api.rubygems.org/quick/Marshal.4.8/rails-4.2.4.gemspec.rz)\\n</code></pre>\\n<p>遇到这个问题，还提示端口是443.可能是<code>gem</code>源导致的网络问题，尝试修改https为http。通过以下命令:</p>\\n<pre><code class=\\\"language-bash\\\">gem sources\\ngem sources -a url //添加\\ngem sources -r url  //删除\\n更新source cache\\ngem sources -u\\n// other :\\ngem sources --add https://ruby.taobao.org/ --remove https://rubygems.org/\\ngem sources -l\\n</code></pre>\\n<p>之后重新进行安装，最后结束安装</p>\\n<pre><code class=\\\"language-bash\\\">Successfully installed rails-4.2.0\\n30 gems installed\\n</code></pre>\\n<h2>其他情况</h2>\\n<ul>\\n<li><code>bundle install</code>如果遇到问题，可以先把<code>gemfile</code>中的<code>source</code>修改成<code>http</code>开头即可，如果在操作时提示需要<code>javascript run time</code>，只要安装<code>Node.js</code>即可</li>\\n</ul>\",\"fields\":{\"slug\":\"/rails-install/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2015-07-10---anaconda-introduction/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"\",\"fields\":{\"slug\":\"/2015-07-10---anaconda-introduction/\"}}],\"installtion-record\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/es6-string.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"\",\"fields\":{\"slug\":\"/es6-string/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/git-develop-workflow.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"\",\"fields\":{\"slug\":\"/git-develop-workflow/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/js-logic-operation.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"\",\"fields\":{\"slug\":\"/js-logic-operation/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/mysql-operation.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"\",\"fields\":{\"slug\":\"/mysql-operation/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/numpy-ndarray.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"\",\"fields\":{\"slug\":\"/numpy-ndarray/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/node-module-loader.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"\",\"fields\":{\"slug\":\"/node-module-loader/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/rails-install.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"Rails 安装记录 本文 ubuntu 版本为 14.04stl 64bit ，参考教程： http://rails-practice.com/content/Chapter_1/1.1.html，  需要翻墙 Git ubuntu安装完毕之后，首先安装git…\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"<h1>Rails 安装记录</h1>\\n<blockquote>\\n<p>本文<code>ubuntu</code>版本为<code>14.04stl 64bit</code>，参考教程：<a href=\\\"http://rails-practice.com/content/Chapter_1/1.1.html%EF%BC%8C\\\">http://rails-practice.com/content/Chapter_1/1.1.html，</a> 需要翻墙</p>\\n</blockquote>\\n<h2>Git</h2>\\n<p>ubuntu安装完毕之后，首先安装git，以便之后会用到：</p>\\n<pre><code class=\\\"language-bash\\\">sudo apt-get update\\nsudo apt-get install git-core\\n</code></pre>\\n<p>配置身份信息：</p>\\n<pre><code class=\\\"language-bash\\\">git config --global user.name \\\"xxx\\\"\\ngit config --global user.email \\\"xx@gmail.com\\\"\\n</code></pre>\\n<p>核实信息是否有误：</p>\\n<pre><code class=\\\"language-bash\\\">git config --list\\n</code></pre>\\n<p>此时已经能通过<code>http</code>正常拉去git上的内容，若想进一步配置<code>ssh</code>，可以参考<a href=\\\"https://help.github.com/articles/generating-ssh-keys/1323\\\">https://help.github.com/articles/generating-ssh-keys/1323</a></p>\\n<h2>RVM</h2>\\n<p><code>rails</code>需要先安装<code>Ruby</code>环境，<code>RVM</code>是<code>Ruby</code>管理工具，可以方便的安装、管理、切换多个<code>Ruby</code>，管理<code>Gemset</code>。</p>\\n<pre><code class=\\\"language-bash\\\">curl -sSL https://get.rvm.io | bash -s stable\\n</code></pre>\\n<p>此时会有如下提示：</p>\\n<pre><code class=\\\"language-bash\\\">getcha22@ubuntu:~/Desktop$ curl -sSL https://get.rvm.io | bash -s stable\\nDownloading https://github.com/rvm/rvm/archive/1.26.11.tar.gz\\nDownloading https://github.com/rvm/rvm/releases/download/1.26.11/1.26.11.tar.gz.asc\\ngpg: Signature made Mon 30 Mar 2015 02:52:13 PM PDT using RSA key ID BF04FF17\\ngpg: Can't check signature: public key not found\\nWarning, RVM 1.26.0 introduces signed releases and automated check of signatures when GPG software found.\\nAssuming you trust Michal Papis import the mpapis public key (downloading the signatures).\\nGPG signature verification failed for '/home/getcha22/.rvm/archives/rvm-1.26.11.tgz' - 'https://github.com/rvm/rvm/releases/download/1.26.11/1.26.11.tar.gz.asc'!\\ntry downloading the signatures:\\n    gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3\\nor if it fails:\\n    command curl -sSL https://rvm.io/mpapis.asc | gpg --import -\\nthe key can be compared with:\\n    https://rvm.io/mpapis.asc\\n    https://keybase.io/mpapi\\n</code></pre>\\n<p>按照提示，执行：</p>\\n<pre><code class=\\\"language-bash\\\">gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0\\n</code></pre>\\n<p>依然warring，继续按照提示</p>\\n<pre><code class=\\\"language-bash\\\">sudo curl -sSL https://rvm.io/mpapis.asc | gpg --import -\\n</code></pre>\\n<p>提示Thank you for using RVM!，OK，安装成功</p>\\n<h2>Ruby</h2>\\n<p>重启终端，开始安装<code>Ruby</code>，先使用<code>rvm list known</code>来查看可以按照的<code>Ruby</code>列表，按照参考的教程，我选择使用<code>2.2.0</code></p>\\n<pre><code class=\\\"language-bash\\\">rvm install 2.2.0123\\n</code></pre>\\n<p>在我安装的过程中，由于vpn不算稳定，出现了404的提示，我尝试重新安装，这次安装成功。 通过下面的命令检查当前的版本：</p>\\n<pre><code class=\\\"language-bash\\\">rvm list\\n</code></pre>\\n<p>提示结果：</p>\\n<pre><code class=\\\"language-bash\\\">rvm rubies\\n   ruby-2.2.0 [ x86_64 ]\\n</code></pre>\\n<p>再进一步核实<code>ruby</code>的版本， 此时由于<code>ubuntu</code>存在其他版本的<code>ruby</code>，需要制定默认的<code>ruby</code>版本，此时可以使用:</p>\\n<pre><code class=\\\"language-bash\\\">rvm --default use 2.2.0\\n</code></pre>\\n<p>发现有错误提示<code>RVM is not a function</code>,这个问题是由于<code>ubuntu</code>系统的终端导致 ，为了解决这个问题，需要<code>Run command as login shell</code>，参考这个链接进行解决：<a href=\\\"https://rvm.io/integration/gnome-terminal\\\">https://rvm.io/integration/gnome-terminal</a> ，之后重新制定默认版本，提示OK。</p>\\n<pre><code class=\\\"language-bash\\\">ruby 2.2.0p0 (2014-12-25 revision 49005) [x86_64-linux]\\n</code></pre>\\n<p>到此为止，<code>ruby</code>的安装告一段落，开始进行<code>Rails</code>的安装。</p>\\n<h2>Rails</h2>\\n<p>先设置<code>Gemset</code>。<code>Gemset</code> 是一个独立的 <code>Gem</code> 集合，可以为每个项目设置自己的 <code>Gemset</code>，而不会相互干扰：</p>\\n<pre><code class=\\\"language-bash\\\">rvm gemset create rails4.2\\nrvm use 2.2.0@rails4.2 --default\\ngem install rails -v 4.2.0 --no-ri --no-rdoc\\n</code></pre>\\n<p>出现如下问题:</p>\\n<pre><code class=\\\"language-bash\\\">ERROR:  While executing gem ... (Gem::RemoteFetcher::FetchError)\\n    Errno::ECONNRESET: Connection reset by peer - connect(2) for \\\"rubygems.global.ssl.fastly.net\\\" port 443 (https://api.rubygems.org/quick/Marshal.4.8/rails-4.2.4.gemspec.rz)\\n</code></pre>\\n<p>遇到这个问题，还提示端口是443.可能是<code>gem</code>源导致的网络问题，尝试修改https为http。通过以下命令:</p>\\n<pre><code class=\\\"language-bash\\\">gem sources\\ngem sources -a url //添加\\ngem sources -r url  //删除\\n更新source cache\\ngem sources -u\\n// other :\\ngem sources --add https://ruby.taobao.org/ --remove https://rubygems.org/\\ngem sources -l\\n</code></pre>\\n<p>之后重新进行安装，最后结束安装</p>\\n<pre><code class=\\\"language-bash\\\">Successfully installed rails-4.2.0\\n30 gems installed\\n</code></pre>\\n<h2>其他情况</h2>\\n<ul>\\n<li><code>bundle install</code>如果遇到问题，可以先把<code>gemfile</code>中的<code>source</code>修改成<code>http</code>开头即可，如果在操作时提示需要<code>javascript run time</code>，只要安装<code>Node.js</code>即可</li>\\n</ul>\",\"fields\":{\"slug\":\"/rails-install/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2015-07-10---anaconda-introduction/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"\",\"fields\":{\"slug\":\"/2015-07-10---anaconda-introduction/\"}}],\"os\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/os-1.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"操作系统（一） 按下电源之后，如何加载操作系统？ 操作系统如何与外设、应用程序交互？ BIOS、BootLoader、OS的关系 BIOS即基本输入输出系统，存在CMOS中，OS即操作系统，操作系统存在硬盘中。硬盘中还存另一个简单的小程序BootLoader，它可以将OS…\",\"frontmatter\":{\"title\":\"操作系统（一）\",\"date\":\"2018-01-10\",\"tags\":[\"os\",\"Bootloader\"]},\"html\":\"<h1>操作系统（一）</h1>\\n<ol>\\n<li>按下电源之后，如何加载操作系统？</li>\\n<li>操作系统如何与外设、应用程序交互？</li>\\n</ol>\\n<h2>BIOS、BootLoader、OS的关系</h2>\\n<p>BIOS即基本输入输出系统，存在CMOS中，OS即操作系统，操作系统存在硬盘中。硬盘中还存另一个简单的小程序BootLoader，它可以将OS从硬盘放到内存中去，使cpu可以执行OS相关的代码。</p>\\n<ol>\\n<li>一开始加电，CPU从一个预先约定的地址处开始执行BIOS程序，进行加电自检（显卡，键鼠，硬盘），检查成功，即外设均可正常工作，接着要将BootLoader程序放到内存中去。</li>\\n<li>BootLoader放在硬盘内的某个指定位置，BIOS从这位置开始，连续读取其后的512B的代码和数据，放入内存之中，CPU按照BootLoader的代码开始执行。</li>\\n<li>此时CPU的控制权由BootLoader掌控，该程序会找到硬盘中OS程序的起始扇区和长度，将这块区域从硬盘中读到内存中去，CPU调到OS的起始代码处开始。</li>\\n</ol>\\n<h2>操作系统如何与设备和程序交互</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>对象</th>\\n<th>交互方式</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>面向外设</td>\\n<td>中断、I/O</td>\\n</tr>\\n<tr>\\n<td>面向程序</td>\\n<td>系统调用、异常</td>\\n</tr>\\n</tbody>\\n</table>\\n<h3>基本概念</h3>\\n<ul>\\n<li>系统调用：系统的资源由操作系统统一掌控，应用程序需要这些资源时，要向系统主动提出服务请求，之后由操作系统来完成相应的功能。</li>\\n<li>异常：同样由应用程序产生的，但是并非主动产生，而是在执行过程中，出现了意想不到的事情，必须由操作系统解救。</li>\\n<li>中断：来源于外设，当外设执行完上一轮CPU分配的任务后，请求下一轮的任务，通过中断机制，使操作系统能感知外设发出的请求。</li>\\n</ul>\\n<h3>为什么应用程序不能直接找外设？</h3>\\n<ul>\\n<li>安全：操作系统是特殊的软件，是可信程序，而应用程序则不是。</li>\\n<li>抽象：操作系统为应用提供简单一致的接口，不需要针对不同的外设开发不同的软件，屏蔽底层设备的差异性，提供统一的接口。</li>\\n</ul>\\n<h3>区别联系</h3>\\n<table>\\n<thead>\\n<tr>\\n<th align=\\\"left\\\">源头</th>\\n<th></th>\\n<th align=\\\"left\\\">处理时间</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td align=\\\"left\\\">中  断</td>\\n<td>非CPU执行指令时产生的，由设备产生，例如设备上一轮的I/O处理完成了，希望再为分配下一轮的任务</td>\\n<td align=\\\"left\\\">异步,即不知道外设什么时候发出中断，什么时候返回给外设下一轮任务也未知</td>\\n</tr>\\n<tr>\\n<td align=\\\"left\\\">异  常</td>\\n<td>CPU执行应用程序的指令时产生，被动产生的，举例：越界访问，非法操作码等</td>\\n<td align=\\\"left\\\">同步，即执行到特定的指令一定会发生，且要立即处理</td>\\n</tr>\\n<tr>\\n<td align=\\\"left\\\">系统调用</td>\\n<td>CPU执行应用程序的指令时产生，主动产生的，举例：对文件的增删改查</td>\\n<td align=\\\"left\\\">同步和异步，即执行到特定的指令，应用程序发出调用，比如网络请求这是同步的，但之后可以继续执行其余指令，不必一直等待</td>\\n</tr>\\n</tbody>\\n</table>\\n<h3>处理过程</h3>\\n<h4>中断处理过程</h4>\\n<ol>\\n<li>外设完成任务，在某个寄存器或者某个特定的位置设置一个中断标记。</li>\\n<li>CPU在下一个时间片开始之前会先检测这个位置，CPU发现标记后便可判断为哪种中断，得出中断号，根据中断表查出这类中断对应的处理程序地址。</li>\\n<li>带着参数执行这个地址处的程序。</li>\\n<li>操作系统在跳转前还需要保存被打断程序的现场状态，以便后续恢复后能继续运行，在执行完后同样要继续恢复。</li>\\n</ol>\\n<p><strong>特点</strong>：对于正在执行的应用程序来说是透明的，应用程序无感知</p>\\n<h4>异常处理过程</h4>\\n<ol>\\n<li>CPU正在执行应用程序代码时，发现了非法指令，CPU无法继续执行了，产生一个异常ID（硬件实现：改变某个寄存器的值），转而执行操作系统的代码。</li>\\n<li>操作系统通过异常ID确定异常号，保存好当前上下文，再确定异常处理程序的地址。</li>\\n<li>异常处理判断直接杀死当前程序，还是为其分配必要的资源后重新执行一次（这种情况下对应用程序是透明的，好像不曾产生异常）。</li>\\n</ol>\\n<h4>系统调用过程</h4>\\n<p>应用程序无法直接完成某项任务，需要操作系统作为中介提供服务。</p>\\n<blockquote>\\n<p>windows系统提供了Win32 API，应用程序可以为这些接口提供参数来申请系统调用。\\nPOSIX-based systems系统（Linux，MacOS等系统）提供了POSIX API，可以实现应用程序的系统调用。\\n人们都知道JAVA虚拟机会提供JAVA API，通过JAVA API实现的是库函数的调用，再通过JAVA虚拟机来代为实现系统调用，其实是多了一层封装的，但也就是因为多了一层JAVA虚拟机，所以JAVA程序有非常好的跨平台性，JAVA虚拟机实现了对不同操作系统差异的屏蔽。不过这并没有什么了不起的，现在大部分编程语言都是跨平台的，社区或者公司都提供了不同平台的解释或者编译程序，也可以一次编写到处运行。\\n应用程序编写时，只要掌握对应OS提供的API与API具有的功能即可。</p>\\n</blockquote>\\n<p>应用程序直接或者间接（通过库函数）访问OS系统提供的API，会触发了CPU从用户态到内核态的切换。\\n用户态就是CPU执行应用程序的状态，仅能执行有限指令，不能直接操纵外设，无法完全控制整个计算机。\\n内核态指CPU执行OS程序的状态，可以执行特权和访问I/O的指令，可以完全控制整个计算机。\\n完成转换后就将控制权交到了操作系统，操作系统可以对系统调用做标识，识别，完成服务。</p>\\n<h4>函数调用与系统调用的区别</h4>\\n<p>函数调用其实是在一个栈空间完成了参数的传递和返回。而系统调用时，应用程序和内核程序有各自的堆栈，发出系统调用，要切换执行内核程序，就要先切换堆栈，同时转换特权集（用户态到内核态），切换堆栈和转换是有开销的，还包括系统调用的参数检查，两个堆栈之间的拷贝（堆栈的切换不能仅仅通过修改指针）。总体而言开销大很多，但换来的回报是安全。</p>\",\"fields\":{\"slug\":\"/os-1/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/os-2.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"操作系统（二） 操作系统如何管理物理主存？ 计算机体系结构、主存结构分层 CPU芯片内部有寄存器和Cache…\",\"frontmatter\":{\"title\":\"操作系统（二）\",\"date\":\"2018-01-12\",\"tags\":[\"os\",\"memory\"]},\"html\":\"<h1>操作系统（二）</h1>\\n<ol>\\n<li>操作系统如何管理物理主存？</li>\\n</ol>\\n<h2>计算机体系结构、主存结构分层</h2>\\n<ol>\\n<li>CPU芯片内部有寄存器和Cache，操作系统无法直接访问管理，这一层次的主存容量小但是数据很快。</li>\\n<li>在主存结构中有一块很大的区域，即主存或者物理主存。这块区域可以用来放置操作系统本身代码以及其他要运行的程序，主存容量大，速度慢。</li>\\n<li>计算机中可以在主存中存放着多个可运行的程序，若CPU的运行速度很快，且这些可运行的程序都需要很大的主存，那么CPU运行完主存中可运行的程序（假想当前主存中的可运行的所有程序都需要接收到网络响应后才能恢复运行），那么CPU就闲置下来了。为了避免CPU浪费，操作系统就需要发挥作用，将临时用不到的程序和数据放到硬盘中。</li>\\n<li>主存在计算机掉电之后其内的数据就丢失了，在主存结构的底层，就是硬盘，它用来保存数据。</li>\\n</ol>\\n<p><strong>特点</strong>：上述主存结构分层，从上到下速度依次降低，存储容量依次增大。数据访问很快，数据的存储空间很大。有了操作系统的帮助，操作系统如何管理物理主存，如何完成这个任务？</p>\\n<h2>操作系统为配合应用程序需要完成的任务</h2>\\n<p>为了配合程序，操作系统需要完成以下任务：</p>\\n<ul>\\n<li>抽象：我们希望应用程序在主存中运行时，不需要考虑物理主存和外设在什么地方，只需要访问一个连续的地址空间（逻辑地址空间）即可。</li>\\n<li>保护：在主存中可以运行多个不同的应用程序，某个程序可能会访问别的程序的地址空间，这时就需要一种机制来隔离和保护被访问程序的地址空间。</li>\\n<li>共享：除了隔离外，程序之间如何交互、共享各自的数据。</li>\\n<li>虚拟化：当需要在主存中运行的应用程序很多时，会出现主存不够用的情况。我们将暂时不用的数据临时放入硬盘，用的时候再拿出来，整个过程要对应用程序透明，这也是操作系统的任务。</li>\\n</ul>\\n<p><strong>注</strong>：上面提到了两个地址空间，主存和硬盘是物理地址空间，而应用程序在操作系统的作用下看到的是逻辑地址空间。</p>\\n<h2>地址空间与地址生成</h2>\\n<h3>地址空间定义</h3>\\n<p>地址空间分为物理地址空间和逻辑地址空间。</p>\\n<ul>\\n<li>物理地址空间：与硬件直接对应，主存条代表的主存和硬盘代表的另一种存储空间，物理地址空间的管理由硬件来完成。</li>\\n<li>逻辑地址空间：是运行程序所见到的一维线性的地址空间，应用程序非常容易控制和访问逻辑地址空间。</li>\\n<li>两者对应关系：某条程序指令指向某个一维逻辑地址，这个逻辑地址可能是该程序堆栈的某个位置，但最终这个位置可能是主存中甚至是硬盘中，操作系统完成了两者的映射关系。</li>\\n</ul>\\n<h3>逻辑地址生成</h3>\\n<ol>\\n<li>C程序通过编译变为汇编程序，在C程序中，函数的位置和变量的名字就是地址，只不过以一种更容易人理解的方式存在。</li>\\n<li>汇编程序更贴近机器语言，但是函数和变量仍然通过符号表示，相比机器语言，汇编语言更易让人阅读。</li>\\n<li>将汇编程序汇编成机器语言，即.o程序，.o程序的起始地址从0开始，此时变量和函数已经被转成了特定的地址。</li>\\n<li>一个大程序会由多个小程序组成，小程序之间往往具有复杂的依赖关系，通过链接可以将多个.o小程序最终变成一个单一的可执行程序.exe，.exe程序已经可以在主存中执行的，但是目前还放在硬盘中。</li>\\n<li>多个点.o程序中地址已经在.exe程序中有了相应的映射，但这个定义并非主存中的位置，再通过载入程序，将.exe程序放入到主存中执行，这一步为.exe程序分配在主存中的逻辑地址，使得应用程序在主存中正常的跑，.exe程序的地址做了相应的偏远，通过这个偏移量，程序就会依照这个偏移量进行执行。</li>\\n</ol>\\n<p><strong>特点</strong>：从函数和变量到最终可以在主存中执行的逻辑地址，通过了很多步骤，但这些步骤基本都不需要操作系统做任何的帮助，最终放入内存后，应用程序看到的地址仍然不是物理地址。</p>\\n<p><strong>题目</strong>\\n在内存管理中，地址变换机构将逻辑地址变为物理地址，形成该逻辑地址的阶段是编辑、编译、链接还是装载？\\n答：链接。在编译、汇编后，一个程序可能形成了多个.o文件，这是已经具有了逻辑地址，但只是相对于该模块的逻辑地址，并不能直接用于后续的地址变换。多个.h文件再经过链接，组合为.exe文件，便形成了相对于整个程序的逻辑地址。这个地址可用于后续的地址变换。</p>\\n<h3><del>逻辑地址如何对应物理地址（需要组成原理的内容做铺垫）</del></h3>\\n<p>指令放在物理内存的什么地方，指令的逻辑地址在什么地方，CPU有MMU，它有一块区域存着映射关系，查表可以完成具体的物理地址，硬件就可以从相应的物理地址中取出。</p>\\n<p>操作系统先生成一个逻辑地址和物理地址的映射关系，将该映射关系存在内存中，CPU可以在MMU中缓存这个映射关系。（<strong>如何完成预先生成，后续谈</strong>）</p>\\n<ol>\\n<li>CPU执行某条指令，ALU需要得到该指令逻辑地址上的内容，ALU首先将该逻辑地址作为参数，向存储管理单元MMU发出查物理地址的请求。</li>\\n<li>CPU的MMU查找对应的映射表，判断是否有对应的物理地址。</li>\\n<li>若没有这个物理地址，就到内存中的映射表上找</li>\\n<li>找到后CPU的控制器向主存发出请求，需要某个物理地址的内容，主存将内存的内容通过总线传给CPU，CPU拿到内容就可以进行执行了</li>\\n</ol>\\n<h2>如何确保内存中的程序不相互干扰</h2>\\n<p>操作系统首先确认每个程序可以访问的地址空间，第一部分是起始地址，第二个部分是该程序可访问的区域。这张表由操作系统建立和维护，CPU在执行某条指令时，CPU要查表确定是否合法，合法之后才根据地址取指令。</p>\",\"fields\":{\"slug\":\"/os-2/\"}}],\"Bootloader\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/os-1.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"操作系统（一） 按下电源之后，如何加载操作系统？ 操作系统如何与外设、应用程序交互？ BIOS、BootLoader、OS的关系 BIOS即基本输入输出系统，存在CMOS中，OS即操作系统，操作系统存在硬盘中。硬盘中还存另一个简单的小程序BootLoader，它可以将OS…\",\"frontmatter\":{\"title\":\"操作系统（一）\",\"date\":\"2018-01-10\",\"tags\":[\"os\",\"Bootloader\"]},\"html\":\"<h1>操作系统（一）</h1>\\n<ol>\\n<li>按下电源之后，如何加载操作系统？</li>\\n<li>操作系统如何与外设、应用程序交互？</li>\\n</ol>\\n<h2>BIOS、BootLoader、OS的关系</h2>\\n<p>BIOS即基本输入输出系统，存在CMOS中，OS即操作系统，操作系统存在硬盘中。硬盘中还存另一个简单的小程序BootLoader，它可以将OS从硬盘放到内存中去，使cpu可以执行OS相关的代码。</p>\\n<ol>\\n<li>一开始加电，CPU从一个预先约定的地址处开始执行BIOS程序，进行加电自检（显卡，键鼠，硬盘），检查成功，即外设均可正常工作，接着要将BootLoader程序放到内存中去。</li>\\n<li>BootLoader放在硬盘内的某个指定位置，BIOS从这位置开始，连续读取其后的512B的代码和数据，放入内存之中，CPU按照BootLoader的代码开始执行。</li>\\n<li>此时CPU的控制权由BootLoader掌控，该程序会找到硬盘中OS程序的起始扇区和长度，将这块区域从硬盘中读到内存中去，CPU调到OS的起始代码处开始。</li>\\n</ol>\\n<h2>操作系统如何与设备和程序交互</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>对象</th>\\n<th>交互方式</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>面向外设</td>\\n<td>中断、I/O</td>\\n</tr>\\n<tr>\\n<td>面向程序</td>\\n<td>系统调用、异常</td>\\n</tr>\\n</tbody>\\n</table>\\n<h3>基本概念</h3>\\n<ul>\\n<li>系统调用：系统的资源由操作系统统一掌控，应用程序需要这些资源时，要向系统主动提出服务请求，之后由操作系统来完成相应的功能。</li>\\n<li>异常：同样由应用程序产生的，但是并非主动产生，而是在执行过程中，出现了意想不到的事情，必须由操作系统解救。</li>\\n<li>中断：来源于外设，当外设执行完上一轮CPU分配的任务后，请求下一轮的任务，通过中断机制，使操作系统能感知外设发出的请求。</li>\\n</ul>\\n<h3>为什么应用程序不能直接找外设？</h3>\\n<ul>\\n<li>安全：操作系统是特殊的软件，是可信程序，而应用程序则不是。</li>\\n<li>抽象：操作系统为应用提供简单一致的接口，不需要针对不同的外设开发不同的软件，屏蔽底层设备的差异性，提供统一的接口。</li>\\n</ul>\\n<h3>区别联系</h3>\\n<table>\\n<thead>\\n<tr>\\n<th align=\\\"left\\\">源头</th>\\n<th></th>\\n<th align=\\\"left\\\">处理时间</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td align=\\\"left\\\">中  断</td>\\n<td>非CPU执行指令时产生的，由设备产生，例如设备上一轮的I/O处理完成了，希望再为分配下一轮的任务</td>\\n<td align=\\\"left\\\">异步,即不知道外设什么时候发出中断，什么时候返回给外设下一轮任务也未知</td>\\n</tr>\\n<tr>\\n<td align=\\\"left\\\">异  常</td>\\n<td>CPU执行应用程序的指令时产生，被动产生的，举例：越界访问，非法操作码等</td>\\n<td align=\\\"left\\\">同步，即执行到特定的指令一定会发生，且要立即处理</td>\\n</tr>\\n<tr>\\n<td align=\\\"left\\\">系统调用</td>\\n<td>CPU执行应用程序的指令时产生，主动产生的，举例：对文件的增删改查</td>\\n<td align=\\\"left\\\">同步和异步，即执行到特定的指令，应用程序发出调用，比如网络请求这是同步的，但之后可以继续执行其余指令，不必一直等待</td>\\n</tr>\\n</tbody>\\n</table>\\n<h3>处理过程</h3>\\n<h4>中断处理过程</h4>\\n<ol>\\n<li>外设完成任务，在某个寄存器或者某个特定的位置设置一个中断标记。</li>\\n<li>CPU在下一个时间片开始之前会先检测这个位置，CPU发现标记后便可判断为哪种中断，得出中断号，根据中断表查出这类中断对应的处理程序地址。</li>\\n<li>带着参数执行这个地址处的程序。</li>\\n<li>操作系统在跳转前还需要保存被打断程序的现场状态，以便后续恢复后能继续运行，在执行完后同样要继续恢复。</li>\\n</ol>\\n<p><strong>特点</strong>：对于正在执行的应用程序来说是透明的，应用程序无感知</p>\\n<h4>异常处理过程</h4>\\n<ol>\\n<li>CPU正在执行应用程序代码时，发现了非法指令，CPU无法继续执行了，产生一个异常ID（硬件实现：改变某个寄存器的值），转而执行操作系统的代码。</li>\\n<li>操作系统通过异常ID确定异常号，保存好当前上下文，再确定异常处理程序的地址。</li>\\n<li>异常处理判断直接杀死当前程序，还是为其分配必要的资源后重新执行一次（这种情况下对应用程序是透明的，好像不曾产生异常）。</li>\\n</ol>\\n<h4>系统调用过程</h4>\\n<p>应用程序无法直接完成某项任务，需要操作系统作为中介提供服务。</p>\\n<blockquote>\\n<p>windows系统提供了Win32 API，应用程序可以为这些接口提供参数来申请系统调用。\\nPOSIX-based systems系统（Linux，MacOS等系统）提供了POSIX API，可以实现应用程序的系统调用。\\n人们都知道JAVA虚拟机会提供JAVA API，通过JAVA API实现的是库函数的调用，再通过JAVA虚拟机来代为实现系统调用，其实是多了一层封装的，但也就是因为多了一层JAVA虚拟机，所以JAVA程序有非常好的跨平台性，JAVA虚拟机实现了对不同操作系统差异的屏蔽。不过这并没有什么了不起的，现在大部分编程语言都是跨平台的，社区或者公司都提供了不同平台的解释或者编译程序，也可以一次编写到处运行。\\n应用程序编写时，只要掌握对应OS提供的API与API具有的功能即可。</p>\\n</blockquote>\\n<p>应用程序直接或者间接（通过库函数）访问OS系统提供的API，会触发了CPU从用户态到内核态的切换。\\n用户态就是CPU执行应用程序的状态，仅能执行有限指令，不能直接操纵外设，无法完全控制整个计算机。\\n内核态指CPU执行OS程序的状态，可以执行特权和访问I/O的指令，可以完全控制整个计算机。\\n完成转换后就将控制权交到了操作系统，操作系统可以对系统调用做标识，识别，完成服务。</p>\\n<h4>函数调用与系统调用的区别</h4>\\n<p>函数调用其实是在一个栈空间完成了参数的传递和返回。而系统调用时，应用程序和内核程序有各自的堆栈，发出系统调用，要切换执行内核程序，就要先切换堆栈，同时转换特权集（用户态到内核态），切换堆栈和转换是有开销的，还包括系统调用的参数检查，两个堆栈之间的拷贝（堆栈的切换不能仅仅通过修改指针）。总体而言开销大很多，但换来的回报是安全。</p>\",\"fields\":{\"slug\":\"/os-1/\"}}],\"opensauce\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/opensauce.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"opensauce单元测试 为开源项目提供免费的云测试\\n https://saucelabs.com/opensauce/ 推荐文章 https://philipwalton.com/articles/learning-how-to-set-up-automated-cross…\",\"frontmatter\":{\"title\":\"opensauce单元测试\",\"date\":\"2016-05-03\",\"tags\":[\"opensauce\",\"unit testing\"]},\"html\":\"<h1>opensauce单元测试</h1>\\n<p>为开源项目提供免费的云测试\\n<a href=\\\"https://saucelabs.com/opensauce/\\\">https://saucelabs.com/opensauce/</a></p>\\n<p>推荐文章<a href=\\\"https://philipwalton.com/articles/learning-how-to-set-up-automated-cross-browser-javascript-unit-testing/\\\">https://philipwalton.com/articles/learning-how-to-set-up-automated-cross-browser-javascript-unit-testing/</a></p>\\n<p>中文版\\n<a href=\\\"http://www.jianshu.com/p/d079b9c61450\\\">http://www.jianshu.com/p/d079b9c61450</a></p>\",\"fields\":{\"slug\":\"/opensauce/\"}}],\"unit testing\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/opensauce.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"opensauce单元测试 为开源项目提供免费的云测试\\n https://saucelabs.com/opensauce/ 推荐文章 https://philipwalton.com/articles/learning-how-to-set-up-automated-cross…\",\"frontmatter\":{\"title\":\"opensauce单元测试\",\"date\":\"2016-05-03\",\"tags\":[\"opensauce\",\"unit testing\"]},\"html\":\"<h1>opensauce单元测试</h1>\\n<p>为开源项目提供免费的云测试\\n<a href=\\\"https://saucelabs.com/opensauce/\\\">https://saucelabs.com/opensauce/</a></p>\\n<p>推荐文章<a href=\\\"https://philipwalton.com/articles/learning-how-to-set-up-automated-cross-browser-javascript-unit-testing/\\\">https://philipwalton.com/articles/learning-how-to-set-up-automated-cross-browser-javascript-unit-testing/</a></p>\\n<p>中文版\\n<a href=\\\"http://www.jianshu.com/p/d079b9c61450\\\">http://www.jianshu.com/p/d079b9c61450</a></p>\",\"fields\":{\"slug\":\"/opensauce/\"}}],\"CSS\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/pixel-layout.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"布局像素的辨析 下文主要介绍了一些关于分辨率的基础概念。 物理分辨率 所谓物理分辨率，是指一块屏幕上，横向有多少个像素点，纵向有多少个像素点，比如苹果5的分辨率是640x1136，代表它横向有640个像素点，纵向拥有113…\",\"frontmatter\":{\"title\":\"布局像素的辨析\",\"date\":\"2016-08-12\",\"tags\":[\"CSS\"]},\"html\":\"<h1>布局像素的辨析</h1>\\n<p>下文主要介绍了一些关于分辨率的基础概念。</p>\\n<h2>物理分辨率</h2>\\n<p>所谓物理分辨率，是指一块屏幕上，横向有多少个像素点，纵向有多少个像素点，比如苹果5的分辨率是640x1136，代表它横向有640个像素点，纵向拥有1136个像素点。看官也听出来了，这个物理分辨率是屏幕自带的固定参数，无法更改。</p>\\n<h2>屏幕尺寸</h2>\\n<p>屏幕尺寸指屏幕对角线的长度，根据横向长度和纵向长度进一步计算得到，使用英寸为单位，比如苹果5的尺寸为4.0英寸。</p>\\n<h2>像素密度</h2>\\n<p>像素密度是一个重要的概念，指每英寸上有多少像素点，通过这个参数可以很明确的表示屏幕清晰程度。计算公式为屏幕上所有的物理像素点，除以屏幕尺寸(对角线长度，英寸)。</p>\\n<p>常见的一个临界值是300ppi，这个数字来自于苹果4发布会，乔布斯宣称达到这个分辨率的手机，如果正常距离使用，人眼已经无法分辨屏幕上细微的方格了，苹果一向是善于包装旧概念的，retina display 一词就是被乔布斯创造出来，翻译过来就是这几年经常听到的视网膜显示屏。</p>\\n<h2>逻辑像素</h2>\\n<p>逻辑像素对于开发人员极其重要，是开发过程中表示界面尺寸的一种尺寸，这个需要和物理像素，即物理分辨率做区分。经常听到的一句话就是——物理像素是设备硬件支持的，逻辑像素是软件可以达到的。</p>\\n<p>这句话很好理解，举个简单的例子，之前的苹果3gs，分辨率是480x320，3.5英寸，风靡世界的苹果4，分辨率为它的2倍，960x640。注意，这里表达的分辨率就是指物理像素。</p>\\n<p>在苹果4上，纵向有960个像素点组成，横向则为640个像素点。\\n此时如果在这两部手机上开发，继续使用px布局，即使用物理像素进行开发，就会遇到一些问题，在苹果3gs上开发的布局，在苹果4上无法充满屏幕。</p>\\n<p>苹果此时引入一个概念，pt，即点(point)，在这之前，1pt是等于一个像素的，逻辑像素与物理像素是相同的。</p>\\n<p>在苹果4上出现了不同，1pt = 2px，也就是说，一个英寸上的物理像素数目，是逻辑像素的二倍。举个例子，在开发过程中，我们使用14pt的高度，在3gs上面，显示就是14px，也即上面说的物理像素和逻辑像素是相同的，但是在苹果4上面，显示为28px，他们所占的物理尺寸是相同的(我们肉眼看到的尺寸)，我们可以可以看到14pt的逻辑尺寸，既充满了3gs，也充满了苹果4，但事实上每单位物理尺寸上的物理像素已经不同了。\\n物理分辨率可以不同，但是他们通过逻辑像素这个概念(pt)，在显示结果上得到了统一。</p>\\n<h2>DPI</h2>\\n<p>如果明确了上面的这些概念，那么对于dpi的概念就手到擒来了，所谓dpi，是指每英寸上点的数目，这里的点自然是指pt了，于是很容易理解这样的现象：</p>\\n<p>在3gs上，使用20x20个像素来表示20x20个点，但是到了4上，使用40x40个像素来表示这20x20个点，他们所用到的物理像素数量不同，但是表示点的数目是相同的，而dpi是指每英寸上具有点的数目，于是我们可以得到3gs和4的dpi是相同的，均为162dpi。</p>\\n<p>以上</p>\",\"fields\":{\"slug\":\"/pixel-layout/\"}}],\"memory\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/os-2.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"操作系统（二） 操作系统如何管理物理主存？ 计算机体系结构、主存结构分层 CPU芯片内部有寄存器和Cache…\",\"frontmatter\":{\"title\":\"操作系统（二）\",\"date\":\"2018-01-12\",\"tags\":[\"os\",\"memory\"]},\"html\":\"<h1>操作系统（二）</h1>\\n<ol>\\n<li>操作系统如何管理物理主存？</li>\\n</ol>\\n<h2>计算机体系结构、主存结构分层</h2>\\n<ol>\\n<li>CPU芯片内部有寄存器和Cache，操作系统无法直接访问管理，这一层次的主存容量小但是数据很快。</li>\\n<li>在主存结构中有一块很大的区域，即主存或者物理主存。这块区域可以用来放置操作系统本身代码以及其他要运行的程序，主存容量大，速度慢。</li>\\n<li>计算机中可以在主存中存放着多个可运行的程序，若CPU的运行速度很快，且这些可运行的程序都需要很大的主存，那么CPU运行完主存中可运行的程序（假想当前主存中的可运行的所有程序都需要接收到网络响应后才能恢复运行），那么CPU就闲置下来了。为了避免CPU浪费，操作系统就需要发挥作用，将临时用不到的程序和数据放到硬盘中。</li>\\n<li>主存在计算机掉电之后其内的数据就丢失了，在主存结构的底层，就是硬盘，它用来保存数据。</li>\\n</ol>\\n<p><strong>特点</strong>：上述主存结构分层，从上到下速度依次降低，存储容量依次增大。数据访问很快，数据的存储空间很大。有了操作系统的帮助，操作系统如何管理物理主存，如何完成这个任务？</p>\\n<h2>操作系统为配合应用程序需要完成的任务</h2>\\n<p>为了配合程序，操作系统需要完成以下任务：</p>\\n<ul>\\n<li>抽象：我们希望应用程序在主存中运行时，不需要考虑物理主存和外设在什么地方，只需要访问一个连续的地址空间（逻辑地址空间）即可。</li>\\n<li>保护：在主存中可以运行多个不同的应用程序，某个程序可能会访问别的程序的地址空间，这时就需要一种机制来隔离和保护被访问程序的地址空间。</li>\\n<li>共享：除了隔离外，程序之间如何交互、共享各自的数据。</li>\\n<li>虚拟化：当需要在主存中运行的应用程序很多时，会出现主存不够用的情况。我们将暂时不用的数据临时放入硬盘，用的时候再拿出来，整个过程要对应用程序透明，这也是操作系统的任务。</li>\\n</ul>\\n<p><strong>注</strong>：上面提到了两个地址空间，主存和硬盘是物理地址空间，而应用程序在操作系统的作用下看到的是逻辑地址空间。</p>\\n<h2>地址空间与地址生成</h2>\\n<h3>地址空间定义</h3>\\n<p>地址空间分为物理地址空间和逻辑地址空间。</p>\\n<ul>\\n<li>物理地址空间：与硬件直接对应，主存条代表的主存和硬盘代表的另一种存储空间，物理地址空间的管理由硬件来完成。</li>\\n<li>逻辑地址空间：是运行程序所见到的一维线性的地址空间，应用程序非常容易控制和访问逻辑地址空间。</li>\\n<li>两者对应关系：某条程序指令指向某个一维逻辑地址，这个逻辑地址可能是该程序堆栈的某个位置，但最终这个位置可能是主存中甚至是硬盘中，操作系统完成了两者的映射关系。</li>\\n</ul>\\n<h3>逻辑地址生成</h3>\\n<ol>\\n<li>C程序通过编译变为汇编程序，在C程序中，函数的位置和变量的名字就是地址，只不过以一种更容易人理解的方式存在。</li>\\n<li>汇编程序更贴近机器语言，但是函数和变量仍然通过符号表示，相比机器语言，汇编语言更易让人阅读。</li>\\n<li>将汇编程序汇编成机器语言，即.o程序，.o程序的起始地址从0开始，此时变量和函数已经被转成了特定的地址。</li>\\n<li>一个大程序会由多个小程序组成，小程序之间往往具有复杂的依赖关系，通过链接可以将多个.o小程序最终变成一个单一的可执行程序.exe，.exe程序已经可以在主存中执行的，但是目前还放在硬盘中。</li>\\n<li>多个点.o程序中地址已经在.exe程序中有了相应的映射，但这个定义并非主存中的位置，再通过载入程序，将.exe程序放入到主存中执行，这一步为.exe程序分配在主存中的逻辑地址，使得应用程序在主存中正常的跑，.exe程序的地址做了相应的偏远，通过这个偏移量，程序就会依照这个偏移量进行执行。</li>\\n</ol>\\n<p><strong>特点</strong>：从函数和变量到最终可以在主存中执行的逻辑地址，通过了很多步骤，但这些步骤基本都不需要操作系统做任何的帮助，最终放入内存后，应用程序看到的地址仍然不是物理地址。</p>\\n<p><strong>题目</strong>\\n在内存管理中，地址变换机构将逻辑地址变为物理地址，形成该逻辑地址的阶段是编辑、编译、链接还是装载？\\n答：链接。在编译、汇编后，一个程序可能形成了多个.o文件，这是已经具有了逻辑地址，但只是相对于该模块的逻辑地址，并不能直接用于后续的地址变换。多个.h文件再经过链接，组合为.exe文件，便形成了相对于整个程序的逻辑地址。这个地址可用于后续的地址变换。</p>\\n<h3><del>逻辑地址如何对应物理地址（需要组成原理的内容做铺垫）</del></h3>\\n<p>指令放在物理内存的什么地方，指令的逻辑地址在什么地方，CPU有MMU，它有一块区域存着映射关系，查表可以完成具体的物理地址，硬件就可以从相应的物理地址中取出。</p>\\n<p>操作系统先生成一个逻辑地址和物理地址的映射关系，将该映射关系存在内存中，CPU可以在MMU中缓存这个映射关系。（<strong>如何完成预先生成，后续谈</strong>）</p>\\n<ol>\\n<li>CPU执行某条指令，ALU需要得到该指令逻辑地址上的内容，ALU首先将该逻辑地址作为参数，向存储管理单元MMU发出查物理地址的请求。</li>\\n<li>CPU的MMU查找对应的映射表，判断是否有对应的物理地址。</li>\\n<li>若没有这个物理地址，就到内存中的映射表上找</li>\\n<li>找到后CPU的控制器向主存发出请求，需要某个物理地址的内容，主存将内存的内容通过总线传给CPU，CPU拿到内容就可以进行执行了</li>\\n</ol>\\n<h2>如何确保内存中的程序不相互干扰</h2>\\n<p>操作系统首先确认每个程序可以访问的地址空间，第一部分是起始地址，第二个部分是该程序可访问的区域。这张表由操作系统建立和维护，CPU在执行某条指令时，CPU要查表确定是否合法，合法之后才根据地址取指令。</p>\",\"fields\":{\"slug\":\"/os-2/\"}}],\"React\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/react-summary.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"React学习总结 参考官方文档，整理一些应该被重视的知识点 React中的事件相关 类似HTML中事件的使用方法，可以直接将事件处理函数作为属性值，赋给用驼峰式命名的事件属性。之后的事情交给React，React…\",\"frontmatter\":{\"title\":\"React学习总结\",\"date\":\"2016-04-21\",\"tags\":[\"React\",\"JS\"]},\"html\":\"<h1>React学习总结</h1>\\n<p>参考官方文档，整理一些应该被重视的知识点</p>\\n<h2>React中的事件相关</h2>\\n<p>类似HTML中事件的使用方法，可以直接将事件处理函数作为属性值，赋给用驼峰式命名的事件属性。之后的事情交给React，React自己有一个事件系统，它可以保证事件在所有浏览器中的一致性，React知道如何去冒泡和捕获事件，这个实现是根据w3c的规范，不管使用的是什么浏览器</p>\\n<h2>State 相关</h2>\\n<p>State是可以用来动态渲染，和props是一对好基友。</p>\\n<h3>State 的异步工作方式</h3>\\n<p><code>setState</code> 方法本身是异步的，有一种常见的方式是当React数据改变时，通过 setState(data,callback) 这个方法会将新数据合并到this.state对象上，之后重新渲染组件。当组件结束了重新渲染(re-render），可选的第二个参数callback会被执行。</p>\\n<h3>组件在什么时候需要State</h3>\\n<p>大多数的组件应该简单的通过props获取数据，之后渲染组件，然而有时候会需要一些复杂的数据处理，比如说响应用户的操作，一个请求，此时需要用到state。但尽可能多的让组件无状态话，减少冗余。一种常见的模式是创建许多无状态的组件，它们仅仅负责渲染数据，有一个拥有状态组件在它们层级之上，经过一系列的逻辑处理，通过props将state传递给它的子组件。有状态的组件囊括了尽可能多的逻辑，而无状态的组件仅仅负责渲染数据。</p>\\n<h3>哪些数据应该作为State</h3>\\n<p>尽量使用 props 作为唯一的数据源，事件处理函数会响应用户的事件，此时可能会更新影响用户界面的数据，这些数据应该被 State 包含。真实环境下，这个数据应该很小且可以被 JSON 序列化 。\\n在创建包含状态的组件时，让它尽可能少的包含状态，并且将这些状态存入 this.state 对象中，后续的 render 方法再根据可能有的状态来计算出需要的其他数据，逻辑处理在 render ，通过状态来计算 render 的内容。</p>\\n<h2>组件复用</h2>\\n<p>React 因为新的 render 而导致 DOM 发生更新的过程称为组件校正，这个校正过程是根据组件的顺序决定，比如</p>\\n<pre><code class=\\\"language-html\\\">// Render Pass 1\\n&#x3C;Card>\\n    &#x3C;p>Paragraph 1&#x3C;/p>\\n    &#x3C;p>Paragraph 2&#x3C;/p>\\n&#x3C;/Card>\\n// Render Pass 2\\n&#x3C;Card>\\n    &#x3C;p>Paragraph 2&#x3C;/p>\\n&#x3C;/Card>\\n</code></pre>\\n<p>看起来像是 React 通过 diff 删除了第一个标签，但实际上 React 按照组件的顺序，修改了第一个标签的文本，删除了第二个组件。考虑一个组件由很多状态决定，内部的DOM需要来回的切换，由于组件校正的原理，可能会有些性能问题。此时可以选择为组件添加 <code>display: none</code> ，而不是直接选择删除。有些情况可能比较复杂，比如说有一个很长的列表，需要不断的重排序或者向首尾插入删除新子组件，这种情况如果按照顺序来校正，可能会出现性能问题，此时可以为这些子组件指定独一无二的key。当 React 校正这些组件的时候，就会直接重排序或者销毁，而不是按照顺序，修改子组件的内容来校正。</p>\\n<h2>PropTypes</h2>\\n<p>当项目越来越大，组件的复用越来越频繁，为了确保每次复用接收到的 props 是可用的，需要指定PropTypes。</p>\\n<p>类似于 export，React.PropTypes 对象导出很多验证器，这些验证器可以保证传递来的 props 是正确的。\\n当一个不可用的值被传递给当前组件的 props，那么在控制台中就会显示异常。\\n具体的属性可以参考这个<a href=\\\"http://facebook.github.io/react/docs/reusable-components.html\\\">页面</a>，可以为对象或者数组指定具体的内部 Child。</p>\",\"fields\":{\"slug\":\"/react-summary/\"}}],\"JS\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/react-summary.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"React学习总结 参考官方文档，整理一些应该被重视的知识点 React中的事件相关 类似HTML中事件的使用方法，可以直接将事件处理函数作为属性值，赋给用驼峰式命名的事件属性。之后的事情交给React，React…\",\"frontmatter\":{\"title\":\"React学习总结\",\"date\":\"2016-04-21\",\"tags\":[\"React\",\"JS\"]},\"html\":\"<h1>React学习总结</h1>\\n<p>参考官方文档，整理一些应该被重视的知识点</p>\\n<h2>React中的事件相关</h2>\\n<p>类似HTML中事件的使用方法，可以直接将事件处理函数作为属性值，赋给用驼峰式命名的事件属性。之后的事情交给React，React自己有一个事件系统，它可以保证事件在所有浏览器中的一致性，React知道如何去冒泡和捕获事件，这个实现是根据w3c的规范，不管使用的是什么浏览器</p>\\n<h2>State 相关</h2>\\n<p>State是可以用来动态渲染，和props是一对好基友。</p>\\n<h3>State 的异步工作方式</h3>\\n<p><code>setState</code> 方法本身是异步的，有一种常见的方式是当React数据改变时，通过 setState(data,callback) 这个方法会将新数据合并到this.state对象上，之后重新渲染组件。当组件结束了重新渲染(re-render），可选的第二个参数callback会被执行。</p>\\n<h3>组件在什么时候需要State</h3>\\n<p>大多数的组件应该简单的通过props获取数据，之后渲染组件，然而有时候会需要一些复杂的数据处理，比如说响应用户的操作，一个请求，此时需要用到state。但尽可能多的让组件无状态话，减少冗余。一种常见的模式是创建许多无状态的组件，它们仅仅负责渲染数据，有一个拥有状态组件在它们层级之上，经过一系列的逻辑处理，通过props将state传递给它的子组件。有状态的组件囊括了尽可能多的逻辑，而无状态的组件仅仅负责渲染数据。</p>\\n<h3>哪些数据应该作为State</h3>\\n<p>尽量使用 props 作为唯一的数据源，事件处理函数会响应用户的事件，此时可能会更新影响用户界面的数据，这些数据应该被 State 包含。真实环境下，这个数据应该很小且可以被 JSON 序列化 。\\n在创建包含状态的组件时，让它尽可能少的包含状态，并且将这些状态存入 this.state 对象中，后续的 render 方法再根据可能有的状态来计算出需要的其他数据，逻辑处理在 render ，通过状态来计算 render 的内容。</p>\\n<h2>组件复用</h2>\\n<p>React 因为新的 render 而导致 DOM 发生更新的过程称为组件校正，这个校正过程是根据组件的顺序决定，比如</p>\\n<pre><code class=\\\"language-html\\\">// Render Pass 1\\n&#x3C;Card>\\n    &#x3C;p>Paragraph 1&#x3C;/p>\\n    &#x3C;p>Paragraph 2&#x3C;/p>\\n&#x3C;/Card>\\n// Render Pass 2\\n&#x3C;Card>\\n    &#x3C;p>Paragraph 2&#x3C;/p>\\n&#x3C;/Card>\\n</code></pre>\\n<p>看起来像是 React 通过 diff 删除了第一个标签，但实际上 React 按照组件的顺序，修改了第一个标签的文本，删除了第二个组件。考虑一个组件由很多状态决定，内部的DOM需要来回的切换，由于组件校正的原理，可能会有些性能问题。此时可以选择为组件添加 <code>display: none</code> ，而不是直接选择删除。有些情况可能比较复杂，比如说有一个很长的列表，需要不断的重排序或者向首尾插入删除新子组件，这种情况如果按照顺序来校正，可能会出现性能问题，此时可以为这些子组件指定独一无二的key。当 React 校正这些组件的时候，就会直接重排序或者销毁，而不是按照顺序，修改子组件的内容来校正。</p>\\n<h2>PropTypes</h2>\\n<p>当项目越来越大，组件的复用越来越频繁，为了确保每次复用接收到的 props 是可用的，需要指定PropTypes。</p>\\n<p>类似于 export，React.PropTypes 对象导出很多验证器，这些验证器可以保证传递来的 props 是正确的。\\n当一个不可用的值被传递给当前组件的 props，那么在控制台中就会显示异常。\\n具体的属性可以参考这个<a href=\\\"http://facebook.github.io/react/docs/reusable-components.html\\\">页面</a>，可以为对象或者数组指定具体的内部 Child。</p>\",\"fields\":{\"slug\":\"/react-summary/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-09-01----js-function-2/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"再探JS函数 函数是JS的核心概念，主要用来封装语句，封装单独的功能。 函数参数 函数不在意它本身到底接收多少参数，不关心最后会使用多少参数。因为函数只会接收一个数组，函数可以通过 arguments…\",\"frontmatter\":{\"title\":\"再探JS函数\",\"date\":\"2016-09-07\",\"tags\":[\"JS\",\"function\"]},\"html\":\"<h1>再探JS函数</h1>\\n<p>函数是JS的核心概念，主要用来封装语句，封装单独的功能。</p>\\n<h2>函数参数</h2>\\n<p>函数不在意它本身到底接收多少参数，不关心最后会使用多少参数。因为函数只会接收一个数组，函数可以通过<code>arguments</code>属性来访问这个参数数组。关于这个数组，他其实是个对象，如下:</p>\\n<pre><code class=\\\"language-js\\\">var a = function () {var b= 1; var c = 0} //a是一个函数\\ntypeof a.arguments  // Object\\n</code></pre>\\n<p>但是为什么又说它是数组呢，因为它本身很数组很像，可以通过方括号加数字的方法来访问具体的参数，同时还有数组对象有的<code>length</code>属性。一个有趣的例子：</p>\\n<pre><code class=\\\"language-js\\\">function a (){\\n  console.log(\\\"hello\\\" +　arguments[0] + arguments[1]);\\n}\\na(\\\"hao\\\",\\\"xiang\\\"); //hellohaoxiang\\n</code></pre>\\n<p>这样子依然是有效的，在函数执行的时候，通过<code>arguments</code>对象的<code>length</code>属性可以知道被传递的参数个数，还有个更有趣的例子，是关于<code>arguments</code>的同步性的：</p>\\n<pre><code class=\\\"language-js\\\">function doAdd (num1,num2){\\n  arguments[1]=10;\\n  alert(arguments[0] + num2);\\n  }\\n  doAdd(1,1); //11，arguments[1]和num2是同步的\\n</code></pre>\\n<p>参数就是局部变量，对于函数来说，传递参数是按值的，基本类型的很好理解，相当于变量的复制。对于引用类型来说，还需要留意到此时依然是按值传递的，这个值依然是指引用的内存地址值。证明方法：需要先创建一个对象，传递函数中，此时在函数内部修改对象的属性，此时内外是一致的，因为他们是一种的一个对象。但是此时如果将参数重新初始化为一个对象，那么也就是说此时参数已经指向另一个变量了，和之前的一切无关。</p>\\n<h2>函数相关属性</h2>\\n<p><code>arguments</code>属性有一个叫做<code>callee</code>的指针，这个指针指向拥有这个<code>arguments</code>对象的函数。主要用来解除耦合，下面是关于递归算法的例子</p>\\n<pre><code class=\\\"language-js\\\">function fac (num) {\\n    switch (num){\\n        case 1 :\\n        return 1;\\n        default: return num * arguments.callee(num-1);\\n    }\\n}\\n</code></pre>\\n<p>函数的另外一个内部属性是<code>this</code>对象，<code>this</code>引用的是函数据以执行的环境对象，<code>this</code>是包含它的函数作为方法被调用是所属的对象 = 包含它的函数 + 作为方法被调用时 + 所属的对象。</p>\\n<h2>函数的方法</h2>\\n<p>主要有<code>apply</code>,<code>call</code>与<code>bind</code></p>\\n<h3><code>apply()</code>与<code>call()</code>：</h3>\\n<p>表示在特定的作用域内调用函数，与<code>call()</code>的区别在于<code>call</code>在使用时必须指定参数。</p>\\n<h2><code>bind()</code></h2>\\n<p>这个方法可以用来创建一个新的实例，实例的<code>this</code>值会被绑定到传给<code>bind()</code>的值上</p>\\n<h2>细碎的小点</h2>\\n<ul>\\n<li><code>return</code>语句，一旦<code>return</code>，后续的语句不会继续执行了，不加<code>return</code>的话，函数默认的返回值是<code>undefined</code>。</li>\\n</ul>\",\"fields\":{\"slug\":\"/2016-09-01----js-function-2/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-02-07---js-in/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"JavaScript 中的 in 关键字 在 JavaScript 中,我经常会使用 for(key in ..) 语句来遍历对象的 key  ,这是一种很常用的方式.\\n这里需要留意, 其实 for(.. in ..) 语句也可以用来遍历数组,其中的 key…\",\"frontmatter\":{\"title\":\"JavaScript 中的 in 关键字\",\"date\":\"2016-02-07\",\"tags\":[\"JS\"]},\"html\":\"<h1>JavaScript 中的 in 关键字</h1>\\n<p>在<code>JavaScript</code>中,我经常会使用<code>for(key in ..)</code>语句来遍历对象的<code>key</code> ,这是一种很常用的方式.\\n这里需要留意, 其实<code>for(.. in ..)</code>语句也可以用来遍历数组,其中的<code>key</code>就是数组的<code>index</code>(索引值,0开始) 。\\n除了在<code>for(.. in ..)</code>语句中使用,<code>in</code>也可以作为一个单独的关键字使用,用来判断某个属性或者元素是否存在与数组或者对象.一般会用在判断语句中,下面进行说明。</p>\\n<h2>数组</h2>\\n<pre><code class=\\\"language-js\\\">var pig = ['head', 'hand', 'leg'];\\nconsole.log('head' in pig); // false\\nconsole.log('0' in pig); // true\\nconsole.log(4 in pig); // false\\n</code></pre>\\n<p>通过<code>in</code>操作判断数组是否存在某个索引,逐个分析：</p>\\n<ol>\\n<li>判断<code>head</code>字符串是否为<code>pig</code>的索引,很明显,索引应该是数字,所以<code>false</code>。</li>\\n<li>判断<code>pig</code>是否有索引为字符串 '0',可以看到最后判断结果为 true, 这是因为执行<code>in</code>关键字判断时, <code>JS</code>引擎进行了隐式转换。</li>\\n<li>判断数字<code>4</code>是否为<code>pig</code>数组的索引,结果<code>false</code>。</li>\\n</ol>\\n<h2>对象</h2>\\n<pre><code class=\\\"language-js\\\">var pig = {head: 'head', hand: 'head', leg: 'leg'};\\nconsole.log(head in pig); // false\\nconsole.log('head' in pig); // true\\n</code></pre>\\n<p>通过<code>in</code>操作判断对象是否有某个键名,逐个分析：</p>\\n<ol>\\n<li>判断变量<code>head</code>是否为<code>pig</code>的键名, <code>head</code>是一个未声明未赋值的变量,当然不会是<code>pig</code>的键名,返回<code>false</code>。\\n判断字符串<code>head</code>是否为<code>pig</code>的键名,返回<code>true</code>。</li>\\n</ol>\",\"fields\":{\"slug\":\"/2016-02-07---js-in/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-08-26---js-function-1/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"初探JS函数 有关函数相关的话题在网上讨论的并不够多，因为它比较复杂，这也是为什么现在网上会存在如此多的误解。 在这片文章里面，我会试着去总结有关函数的好的，坏的，丑陋的一面。 函数表达式 VS. 函数声明 在 ECMAScript…\",\"frontmatter\":{\"title\":\"初探JS函数\",\"date\":\"2016-08-26\",\"tags\":[\"JS\",\"function\"]},\"html\":\"<h1>初探JS函数</h1>\\n<p>有关函数相关的话题在网上讨论的并不够多，因为它比较复杂，这也是为什么现在网上会存在如此多的误解。 在这片文章里面，我会试着去总结有关函数的好的，坏的，丑陋的一面。</p>\\n<h2>函数表达式 VS. 函数声明</h2>\\n<p>在 ECMAScript 中，如果需要使用函数，最常用的两种方法就是通过函数表达式和函数声明。掌握它们区别非常重要，因为在JS 中两者的执行是有差别的，可惜很不爽，至少在看来， 两者之间的差别可以说是相当混乱，只有一件事是 ECMA 规范中讲清楚的—-函数声明必须要有一个函数名(规范中称为 identifier (标识)），函数表达式可以忽略函数名：</p>\\n<pre><code class=\\\"language-js\\\">// FunctionDeclaration :\\nfunction Identifier ( FormalParameterList &#x3C;opt> ){ FunctionBody }\\n// FunctionExpression :\\nfunction Identifier&#x3C;opt> ( FormalParameterList &#x3C;opt> ){ FunctionBody }\\n</code></pre>\\n<p>我们可以仔细瞧瞧，当忽略函数名时，只能是函数表达式，这个是没有争议的，因为规范中有说，函数表达式可以忽略函数名，但是如果加上函数名呢？这两种方式一模一样，我们别人说这是一个函数声明，还是一个函数表达式呢？</p>\\n<h2>区分函数表达式和函数声明</h2>\\n<p>看起来 ECMAScript 判断两者的不同是基于整个上下文的，如果<code>function foo () {}</code>是一行语句的某个部分，比如说赋值表达式的一部分，它应该是一个函数表达式，可以理解为当前赋值表达式有函数的参与。 如果<code>function foo () {}</code>被包含在一个函数体内或者直接暴露在最上层的作用域下，它就是一个函数声明。</p>\\n<pre><code class=\\\"language-js\\\">function foo(){} // 声明，因为它暴露在全局作用域下\\nvar bar = function foo () {} // 表达式，因为它是构成赋值表达式的一部分\\n new function bar () {} // 表达式，因为它是 new 语句的一部分\\n (funciton () {\\n     function bar () {} // 声明，因为它在函数体内\\n })();\\n</code></pre>\\n<p>上面的例子有个需要留意的地方，(function () {})这个函数应该算作哪一种。可以明确的说它是一个函数表达式，因为前后的两个()括号。两个括号组成一个分组运算符，而分组运算符可以包含表达式的，所以按照上面的说明，它是一部分，是一个函数表达式(注意区分编程中的语句和表达式，参考文章<a href=\\\"http://www.2ality.com/2012/09/expressions-vs-statements.html\\\">http://www.2ality.com/2012/09/expressions-vs-statements.html</a>。</p>\\n<p>区分清楚之后，来看他们之间的不同，首先在其他语句还没有执行之前，函数声明将会先被解析和执行。即便它的位置在整个页面资源的最底部，它会被在作用域中出现的时间将会先于其他的任何表达式。下面的例子演示了fn 函数声明的位置靠后，但是依然可以在声明的位置之前被调用。</p>\\n<pre><code class=\\\"language-js\\\">alert(fn());\\nfunction fn () {\\nreturn \\\"hello world~\\\"\\n}\\n</code></pre>\\n<p>另外一个绝对需要注意的特点，不要在条件语句声明函数，在不同的环境下，会有不同的处理结果，所以当遇到要依据不同条件来新建函数时，一定要使用函数表达式代替，看下面的例子：</p>\\n<pre><code class=\\\"language-js\\\">// 绝对不要这样做，由于函数声明会在其他语句没有执行之前就声明完毕，所以这里的处理逻辑比较混乱\\n// 某些浏览器会直接使用第一个声明，返回 'first'\\n// 某些会使用第二个声明 'second'\\nif (true) {\\n  function foo() {\\n    return 'first';\\n  }\\n}\\nelse {\\n  function foo() {\\n    return 'second';\\n  }\\n}\\nfoo();\\n// 当一定需要依据不同情况创建函数时，使用函数表达式的方法来代替\\nvar foo;\\nif (true) {\\n  foo = function() {\\n    return 'first';\\n  };\\n}\\nelse {\\n  foo = function() {\\n    return 'second';\\n  };\\n}\\nfoo();\\n</code></pre>\",\"fields\":{\"slug\":\"/2016-08-26---js-function-1/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-10-01---node-file-system/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"Node文件系统 Node 通过封装基本的 POSIX 函数来提供文件系统，使用 require('fs…\",\"frontmatter\":{\"title\":\"Node文件系统\",\"date\":\"2016-10-01\",\"tags\":[\"Node\",\"JS\"]},\"html\":\"<h1>Node文件系统</h1>\\n<p><code>Node</code>通过封装基本的<code>POSIX</code>函数来提供文件系统，使用<code>require('fs')</code>来使用这个模块，所有与文件相关的方法，都提供了异步和同步的形式。 异步的方法通常会将一个可选的回调函数作为最后一个参数，回调函数的第一个参数通常留给意外情况，如果操作是成功的，第一个参数将是<code>null</code>或者<code>undeefined</code>。 使用同步方法，对于任何意外都会即时抛出，可以使用<code>try/catch</code>语句来处理意外情况，或者让错误时间向上冒泡。 下面是一个有关异步方法的基本例子：</p>\\n<pre><code class=\\\"language-js\\\">const fs = require('fs');\\nfs.unlink('/tmp/hello', (err) => {\\n  if (err) throw err;\\n  console.log('sucessfully deleted /tmp/hello');\\n}\\n</code></pre>\\n<p>再跟着一个同步的例子：</p>\\n<pre><code class=\\\"language-js\\\">const fs = require('fs');\\nfs.unlink('/tmp/hello');\\nconsole.log('successfully deleted /tmp/hello');\\n</code></pre>\\n<p>使用异步方法时，需要注意异步方法的执行不一定按照书写顺序，比如下面这种写法很容易出错：</p>\\n<pre><code class=\\\"language-js\\\">fs.rename('/tmp/hello', '/tmp/world', (err) => {\\n   if (err) throw err;\\n   console.log('renamed compelte');\\n});\\nfs.stat('/tmp/world', (err, stats) => {if (err) throw err;\\nconsole.log(`stats: ${JSON.stringify(stats)}`)});\\n</code></pre>\\n<p>在这里，很可能<code>fs.stat</code>函数先于<code>fs.rename</code>，这样会出现一些不必要的错误，正确的方法应该是写在回调函数中:</p>\\n<pre><code class=\\\"language-js\\\">fs.rename('/tmp/hello/', '/tmp/world', (err) ss=> {\\n    if (err) throw err;\\n    fs.stat('/tmp/world'),(err, stats) => {\\n        console.log(`stats: ${JSON.stringfy(stats)});\\n    });\\n});\\n</code></pre>\\n<p>执行复杂耗时的方法，强烈建议使用异步版本，同步方法在它们执行结束之前，会一直锁住当前线程，阻断所有操作。 在<code>fs</code>模块中，可以使用相对路径，但是需要留意参照的路径来自于<code>process.cwd()</code>的返回值。 很多<code>fs</code>函数可以忽略掉回调参数，如果这样进行使用，默认会抛出错误，为了跟踪到函数调用的位置，可以设置<code>NODE_DEBUG</code>环境变量：</p>\\n<pre><code class=\\\"language-bash\\\">$ cat script.js\\nfunction bad() {\\n  require('fs').readFile('/');\\n}\\nbad();\\n$ env NODE_DEBUG=fs node script.js\\nfs.js:66\\n        throw err;\\n              ^\\nError: EISDIR, read\\n    at rethrow (fs.js:61:21)\\n    at maybeCallback (fs.js:79:42)\\n    at Object.fs.readFile (fs.js:153:18)\\n    at bad (/path/to/script.js:2:17)\\n    at Object.&#x3C;anonymous> (/path/to/script.js:5:1)\\n    &#x3C;etc.>\\n</code></pre>\\n<p><code>fs.watch(filename[, options][, listener])</code>监听制定文件或者目录的变化情况，<code>filename</code>参数可以是文件或者目录，这个方法返回一个<code>fs.FSWather</code>对象。 第二个参数是可选的，提供的<code>options</code>参数应该是一个对象，里面要求的成员是<code>persistent</code>和<code>recursive</code>，这个两个成员都是布尔类型的值。 用做监听的回调函数有两个参数，分别是(<code>event</code>, <code>filename</code>)，<code>event</code>的值视情况，返回字符串<code>change</code>，<code>rename</code>，文件名指的是触发事件的这个文件。看下面的这个例子：</p>\\n<pre><code class=\\\"language-js\\\">// node.md\\n// 被监听的文件\\nthis is cat.\\n// app.js\\n// 用来监听文件改变\\n    fs.watch('./node.md', (event, filename) => {\\n        console.log('下面是event参数，event参数的类型，filename');\\n        console.log(typeof event);\\n        console.log(filename);\\n    });\\n// node.md\\n// 这里修改了监听的node.md文件\\nthis is dog.\\n// console\\n// 执行结果\\n下面是event参数，event参数的类型，filename\\nchange\\nstring\\nnode.md\\n// node.md => node1.md\\n// 修改文件的名字\\n// console\\n// 执行结果\\n下面是event参数，event参数的类型，filename\\nrename\\nstring\\nnode1.md\\n</code></pre>\\n<p>注意事项： <code>fs.watch</code>并不是跨所有平台的，在某些常见下不一定可用。 第二个参数中的布尔值<code>recursive</code>只在<code>osx</code>和<code>window</code>下可以使用。</p>\\n<h2>可用性</h2>\\n<ul>\\n<li><code>fs.watch</code>依赖于操作系统底层模块，由操作系统底层模块通知Node文件的变化。</li>\\n<li>如果某个操作系统底层模块对于文件的监听本身就有问题，那么<code>fs.watch</code>是无法发挥作用的，比如监听了一些不可靠的目录和文件，网络文件系统，虚拟机系统中的文件。</li>\\n<li>在<code>Linux</code>，<code>osx</code>系统中，<code>fs.watch</code>解析路径成一个索引节点，并且监听这个节点，但是如果监听的节点被删除或者重新创建，那么此时它就成了一个新节点了，<code>watch</code>将会发送一个<code>delete</code>事件，但是仍然监听原来的节点，原来的事件不会响应新节点的改变，这种处理是符合预期的。</li>\\n<li><code>filename</code>参数只支持在<code>Linux</code>和<code>windows</code>上面指定(<code>osx</code>也可以，但是有些情况可能会有异常)，事实上，即便是在可以使用的平台上，也不建议直接使用这个参数，因为在回调函数内部，建议增加一些逻辑判断，看一下<code>filename</code>是否为<code>null</code>，如下面的例子：</li>\\n</ul>\\n<pre><code class=\\\"language-js\\\">fs.watch('somedir', (event, filename) => {\\n    console.log(`event is: ${event}`);\\n    if (filename) {\\n         console.log(`filename provided: ${filename}`);\\n     } else {\\n         console.log('filename not provided');\\n     }\\n});\\n</code></pre>\",\"fields\":{\"slug\":\"/2016-10-01---node-file-system/\"}}],\"Git\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-08-20---git-add/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"Git 学习小记之 add 所谓 add 操作，就是 add file into staged area 。下面针对两种情况进行讨论： 新建的文件 旧文件 新建的文件 我们了解 add…\",\"frontmatter\":{\"title\":\"Git 学习小记之 add\",\"date\":\"2016-08-20\",\"tags\":[\"Git\"]},\"html\":\"<h1>Git 学习小记之 add</h1>\\n<p>所谓<code>add</code>操作，就是<code>add file into staged area</code>。下面针对两种情况进行讨论：</p>\\n<ul>\\n<li>新建的文件</li>\\n<li>旧文件</li>\\n</ul>\\n<h2>新建的文件</h2>\\n<p>我们了解<code>add</code>是一个重要的操作。假设有一个空目录，此时里面没有任何文件。\\n我们新建一个文件，这个文件就是处于<code>untrack</code>状态的，可以理解为未被跟踪状态。</p>\\n<p>此时修改这个文件，依然是处于<code>untrack</code>状态。在此时使用<code>add</code>操作，有两个作用：</p>\\n<ol>\\n<li>将新文件添加到暂存区(<code>staged</code>)</li>\\n<li>将文件标记为 <code>track</code></li>\\n</ol>\\n<p>我们再使用<code>commit</code>操作，生成快照，同时<code>clean</code>暂存区，初始化一切。</p>\\n<h2>旧文件</h2>\\n<p>另外一种情况，假设已经有了旧文件，文件处于<code>track</code>状态。</p>\\n<p>此时修改文件，如果使用<code>status</code>命令查看，会提示<code>Changes not staged for commit</code>，大意就是此时已经更新文件了，但是更新的内容还没有暂存起来，提示使用<code>add</code>操作进行暂存。</p>\\n<p>按照提示使用<code>add</code>操作后，使用<code>status</code>命令查看，会发现处于已暂存状态。<code>Changes to be committed</code>，如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。</p>\\n<h2>与 <code>commit</code> 搭配使用</h2>\\n<p>如果发现不断的<code>add</code>、<code>commit</code>比较麻烦，可以使用<code>commit</code>命令加<code>-a</code>参数，Git会自动更新已经跟踪过的文件，更新暂存区。但这里有个地方需要留意，<code>-a</code> 参数并不会更新未跟踪的文件。</p>\\n<h2>总结</h2>\\n<p>关于<code>add</code>，最值得留意的就是一旦修改文件，必须重新暂存，否则生成快照(<code>commit</code>)的依然是上次<code>add</code>时的状态，快照只从暂存区来。</p>\\n<p>总结起来，对于新文件，<code>add</code>会跟踪文件，同时将文件存入暂存区，如果是旧文件，可以按照本地文件更新暂存区的文件。除了上面提到的，还有一种常见的情况，当文件出现冲突时，经常需要人为解决冲突，在修改之后，可以使用<code>add</code>操作将有冲突的文件标记为已经解决状态。</p>\",\"fields\":{\"slug\":\"/2016-08-20---git-add/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-09-01---git-branch/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"Git学习小记之分支原理 如果想要熟练使用 Git，没有分支理念是绝对行不通的，在用 Git 管理项目的时候，经常需要使用 commit 这个命令，那么这个 commit 到底是指什么呢？ 按照官方的解释，这应该成为一个对象，它包含着一个指向暂存内容(被add…\",\"frontmatter\":{\"title\":\"Git学习小记之分支原理\",\"date\":\"2016-09-01\",\"tags\":[\"Git\"]},\"html\":\"<h1>Git学习小记之分支原理</h1>\\n<p>如果想要熟练使用 Git，没有分支理念是绝对行不通的，在用 Git 管理项目的时候，经常需要使用 commit 这个命令，那么这个 commit 到底是指什么呢？</p>\\n<p>按照官方的解释，这应该成为一个对象，它包含着一个指向暂存内容(被add的文件)快照的指针，包含本次提交的附属信息，比如说作者等等，指向父 commit 对象(如果被 merge 而成，可能有多个父 commit 对象)的指针。</p>\\n<p>举下面这个例子来分析：</p>\\n<pre><code class=\\\"language-bash\\\">git add README test.rb LICENSE\\ngit commit -m 'initial commit of my project'\\n</code></pre>\\n<ul>\\n<li>add：暂存操作会对文件计算校验和(SHA-1哈希字串)，然后与当前版本的文件快照(用 blob 对象存储)一起存入到暂存区域中。</li>\\n<li>commit：正式建立提交对象前：Git 先计算出每一个子目录的校验和，然后在 Git 仓库中，将这些目录保存为树对象。</li>\\n</ul>\\n<p>建立提交对象的过程主要如下：\\n携带相关提交信息，包含一个指向该树的指针，这样就代表如果将来需要，可以重现此次快照内容。\\n来看看现在仓库中有什么：\\n一个表示文件快照内容的 blob 对象，一个记录着目录树内容，以及其中各个文件具体对应哪个 blob 对象的索引 tree 对象。以及一个包含着指向索引 tree 对象，以及其他提交信息元数据的 commit 对象。如图：</p>\\n<p><img src=\\\"a.png\\\"></p>\",\"fields\":{\"slug\":\"/2016-09-01---git-branch/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-09-10---git-alias/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"Git 学习小记之使用别名 Git 是在开发中需要频繁使用的工具，如何高效使用，除了深刻理解用法之外，还可以利用一些别名来减少操作。 Git 中的省略其实无处不在，事实上在我们 push 的时候使用的  git push origin master ，意思就是 git push…\",\"frontmatter\":{\"title\":\"Git 学习小记之使用别名\",\"date\":\"2016-09-10\",\"tags\":[\"Git\"]},\"html\":\"<h1>Git 学习小记之使用别名</h1>\\n<p>Git 是在开发中需要频繁使用的工具，如何高效使用，除了深刻理解用法之外，还可以利用一些别名来减少操作。</p>\\n<p>Git 中的省略其实无处不在，事实上在我们<code>push</code>的时候使用的 <code>git push origin master</code>，意思就是<code>git push origin master:master</code>（将本地的<code>master</code>分支推送至远端的<code>master</code>分支，如果没有就新建一个），这就是一个省略了。</p>\\n<p>哈哈，开玩笑的，下面开始进入正题了，想要使用别名，需要先在 Git 中进行配置，命令如下：</p>\\n<pre><code class=\\\"language-bash\\\">git config --global alias.&#x3C;缩写> &#x3C;全称>\\n</code></pre>\\n<p>举个例子</p>\\n<pre><code class=\\\"language-bash\\\">git config --global alias.co checkout\\n</code></pre>\\n<p>这里代表的例子就是指用<code>co</code>命令代替<code>checkout</code>命令，输入这个命令后，后续如果需要切换分支，那么就可以直接使用</p>\\n<pre><code class=\\\"language-bash\\\">git co haoxiangQ2\\nSwitched to branch 'haoxiangQ2'\\n</code></pre>\\n<p>在使用 Git 的时候，我们会 add 追踪文件，但是有时候需要取消对文件的追踪，就会用的 reset 命令，对于这个命令，经常会有人抱怨不好记，太长，那么可以使用下面的配置</p>\\n<pre><code class=\\\"language-bash\\\">git config --global alias.unstage 'reset HEAD --'\\ngit unstage fileA\\n</code></pre>\\n<p>方便快捷，哈哈，下面有些官方推荐的别名配置，可以灵活使用</p>\\n<pre><code class=\\\"language-bash\\\">git config --global alias.co checkout\\ngit config --global alias.br branch\\ngit config --global alias.ci commit\\ngit config --global alias.st status\\ngit config --global alias.unstage 'reset HEAD --'\\ngit config --global alias.last 'log -1 HEAD'\\n</code></pre>\",\"fields\":{\"slug\":\"/2016-09-10---git-alias/\"}}],\"css\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2015-10-05---css-summary/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"CSS 总结 计划总结常用的CSS…\",\"frontmatter\":{\"title\":\"CSS 总结\",\"date\":\"2015-10-5\",\"tags\":[\"css\"]},\"html\":\"<h1>CSS 总结</h1>\\n<p>计划总结常用的CSS知识</p>\\n<h2>基本布局</h2>\\n<p>下面汇总了传统的绝对，浮动，表格与凝胶等布局方式的优缺点</p>\\n<h3>绝对布局</h3>\\n<ul>\\n<li>优点：主内容随页面宽度，固定边栏</li>\\n<li>缺点：浏览器变宽的时候，页脚可能会遮住边栏，同时浏览器变宽后，主内容区和边栏的比例会不协调。</li>\\n</ul>\\n<h3>表格显示布局</h3>\\n<ul>\\n<li>优点：使用<code>table</code>标签，随窗口缩放</li>\\n<li>缺点：对于语义化不利</li>\\n</ul>\\n<h3>凝胶布局</h3>\\n<ul>\\n<li>优点：主内容区建立后，设置左右margin为0</li>\\n<li>缺点：对于页面的利用率不充足</li>\\n</ul>\\n<h2>盒子模型</h2>\\n<p>边框折叠指两个垂直外边距相遇时，会碰到一起，即便是元素嵌套也不例外会进行折叠，下面有一些特殊情况：</p>\\n<ol>\\n<li>\\n<p>上面的div有20px的边距，下面的有10px的边距，此时折叠，依然是20px的边距。但是如果此时把下面的元素设置为float，那么两者的边框不会折叠。</p>\\n</li>\\n<li>\\n<p>考虑这种情况，一个元素嵌套一个元素，此时依然是折叠的，但如果此时为外边的元素设置了边框，那么内外元素边距不折叠</p>\\n</li>\\n<li>\\n<p>box-sizing的用法</p>\\n</li>\\n</ol>\\n<h2>选择器优先级</h2>\\n<p>计算方法如下：计算模型分三个位置，其中，选择器若包含id，则计算模型第一位加一，第二个位置为class、伪类则加一。第三个位置为元素名，每个元素名加一，最后按照结果大小排序，对于依然冲突的规则，按照先后顺序，后出现的覆盖之前的。</p>\",\"fields\":{\"slug\":\"/2015-10-05---css-summary/\"}}],\"regular expression\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-04-05---regular-expression-1/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"正则表达式核心 若有多个字符串，其中一个字符串中包含部分内容，我们使用正则来进行匹配，匹配的结果到底什么？是包含匹配内容的那个字符串？还是只有匹配的内容？ Go Ahead…\",\"frontmatter\":{\"title\":\"正则表达式核心\",\"date\":\"2016-04-05\",\"tags\":[\"regular expression\"]},\"html\":\"<h1>正则表达式核心</h1>\\n<p>若有多个字符串，其中一个字符串中包含部分内容，我们使用正则来进行匹配，匹配的结果到底什么？是包含匹配内容的那个字符串？还是只有匹配的内容？</p>\\n<p>Go Ahead~</p>\\n<p>正则表达式的核心概念就是元字符，它一点也不复杂，掌握了元字符，就可以正则表达式的能力有所了解。</p>\\n<p>接下来的每一节，我都会介绍数个元字符，最终本文结束时，读者就会对正则表达式的核心元字符有大概的了解。</p>\\n<h2>从 hi, Hao 开始</h2>\\n<p><code>hi, Hao</code>这样一个字符串，如果使用正则表达式匹配到<code>hi</code>？这非常简单，我们使用<code>js</code>来作为实现语言：</p>\\n<pre><code class=\\\"language-js\\\">let p = /hi/;\\nlet s = `hi, HAO`;\\ns.match(p); // [\\\"hi\\\", index: 0, input: \\\"hi,Hao\\\"]\\n</code></pre>\\n<p>逐行分析：</p>\\n<ol>\\n<li>使用<code>/code/</code>这样的语法，告诉<code>js</code>解释引擎，这是一个正则表达式，其中的<code>hi</code>就是正则表达式的实际内容</li>\\n<li>声明赋值一个字符串</li>\\n<li>使用<code>match</code>方法匹配，它将返回一个数组，其中存放了与它找到的匹配文本有关的信息。该数组的第<code>0</code>个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本。除了这些常规的数组元素之外，返回的数组还含有两个对象属性。<code>index</code>属性声明的是匹配文本的起始字符在原字符串中的位置，<code>input</code>属性声明的是对原字符串的引用。</li>\\n</ol>\\n<p>上面太简单了，但如果遇到这样的情况呢？</p>\\n<pre><code class=\\\"language-js\\\">let s = `hi,this is Hao. hi, this is Liu.`;\\n</code></pre>\\n<p>这里面的<code>hi</code>，我全都要，该如何匹配？之前的正则表达式是否可行呢？</p>\\n<pre><code class=\\\"language-js\\\">s.match(/hi/) // [\\\"hi\\\", index: 0, input: \\\"hi,this is Hao. hi, this is Liu.\\\"]\\n</code></pre>\\n<p>很明显，没有用了，仍然只捕捉到一个结果。为了解决这个问题，我们引入全局标志<code>g</code>，使用<code>g</code>，<code>match</code>方法将执行全局检索，找到原字符串中所有匹配子字符串。若没有找到任何匹配的子串，则返回<code>null</code>。如果找到了一个或多个匹配子串，则返回一个数组。不过全局匹配返回的数组的内容与前者大不相同，它的数组元素中存放的是原字符串中所有的匹配子串，而且也没有<code>index</code>属性和<code>input</code>属性。</p>\\n<pre><code class=\\\"language-js\\\">s.match(/hi/g) // (4) [\\\"hi\\\", \\\"hi\\\", \\\"hi\\\", \\\"hi\\\"]\\n</code></pre>\\n<p>成功了。</p>\\n<p>挑剔的人来了，如果只想匹配到下面这个字符串最中间的<code>hi</code>呢？</p>\\n<pre><code class=\\\"language-js\\\">let s = `this is Hao. hi this is Liu.`;\\n</code></pre>\\n<p>我们这里就需要用正则表达式的核心内容，元字符了，直接看例子，</p>\\n<pre><code class=\\\"language-js\\\">s.match(/hi/) // [\\\"hi\\\", index: 1, input: \\\"this is Hao. hi this is Liu.\\\"]\\ns.match(/\\\\bhi\\\\b/) //[\\\"hi\\\", index: 13, input: \\\"this is Hao. hi this is Liu.\\\"]\\n</code></pre>\\n<p>逐行分析：</p>\\n<ol>\\n<li>第一行使用了老方法妄图匹配中间的<code>hi</code>，但在遇到索引位置<code>1</code>开始的<code>hi</code>时，就匹配完成了，老方法显然无法满足要求</li>\\n<li>第二种方法从结果上看匹配成功了，匹配到了索引位置<code>13</code>处开始的<code>hi</code>，我们分析一下这个正则表达式中有什么。抛除熟悉的<code>\\\\ hi \\\\</code>，我们发现了<code>hi</code>左右的<code>\\\\b \\\\b</code>，这便是元字符，<code>\\\\</code>用来告诉计算机这是元字符，区别于普通的字符串。<code>b</code>元字符可以匹配这样的位置，这个位置的前一个字符和后一个字符不全是字母、数字、下划线、汉字。分析一下会发现第一个<code>hi</code>在<code>this</code>中，很明显，子串<code>hi</code>的前后字符都是字母，不满足要求。到了索引为<code>13</code>出的<code>hi</code>，它的前后是空格，不是字母、数字、下划线或者汉字，<code>b</code>元字符要求<code>hi</code>的前一个字符和后一个字符不全是字母、数字、下划线、汉字。这里都是空格，这可高于要求的<code>不全是</code>，都已经<code>全都不是</code>了，当然满足了，匹配成功。</li>\\n</ol>\\n<table>\\n<thead>\\n<tr>\\n<th>元字符</th>\\n<th>作用</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>b</td>\\n<td>所匹配的位置，前一个字符和后一个字符不全是\\n<code>w</code>\\n(\\n<code>w</code>\\n用来匹配字母、数字、下划线、汉字)</td>\\n</tr>\\n</tbody>\\n</table>\\n<h2>.*元字符</h2>\\n<p>匹配<code>hi</code>还是容易的，但如果想匹配一大段内容呢？比如</p>\\n<pre><code class=\\\"language-js\\\">let s = `hi! .................... I'm Lucy! I may be a pink ostrich but I'm still a kid just like you! I love  tell jokes, laugh, sing, watch cartoons and learn! And I get to do all these things in class with Sr. Grace! She's my favorite teacher in the whole world. `;\\n</code></pre>\\n<p>上面的省略号代表非常多的内容。假如我想要匹配<code>hi</code>与<code>Lucy</code>连同它中间的内容呢？我总不能都放到正则表达式吧，那多丑！\\n我们这里又要使用元字符了</p>\\n<pre><code class=\\\"language-js\\\">s.match(/\\\\bhi\\\\b.*\\\\bLucy\\\\b/) //succ\\n</code></pre>\\n<p>这里面的有两三点要说明：</p>\\n<ol>\\n<li><code>.*</code>也算元字符？是的，这是两个元字符，只不过他们没有加<code>\\\\</code>而已。</li>\\n<li>为什么不加<code>\\\\</code>标志符？因为他们太常用了，干脆就省略<code>\\\\</code>了，反而专门要匹配字符串<code>.</code>与<code>*</code>的场合却很少，干脆将正则表达式与字符串的表示反一下，如果想要匹配<code>.</code>这个字符串，那么为它加上<code>\\\\</code>，即<code>\\\\.</code>，<code>\\\\*</code>也是同理。</li>\\n<li><code>.*</code>代表什么含义？请看下面的表格</li>\\n</ol>\\n<table>\\n<thead>\\n<tr>\\n<th>元字符</th>\\n<th>作用</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>.</td>\\n<td>匹配除了换行符之外的任何字符</td>\\n</tr>\\n<tr>\\n<td>*</td>\\n<td>用来指定这个元字符 * 前面的内容可以连续重复使用任意多次，可以使得整个表达式得到匹配</td>\\n</tr>\\n</tbody>\\n</table>\\n<p>看到这个表格你应该明了了，<code>.*</code>用来表示任何数量的字符，只要字符里边不包括换行，于是 \\\\bhi\\\\b.*\\\\bLucy\\\\b 就表示先有个单词<code>hi</code>，接着允许出现很多字符，除了换行，之后有一个单词<code>Lucy</code>。</p>\\n<h2>电话号码的匹配实例</h2>\\n<p><code>0\\\\d\\\\d\\\\d-\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d</code> 用来匹配<code>0</code>开头，之后3位数字加<code>-</code>，之后8位数字的电话号码。使用这么多的<code>\\\\d</code>是一件很让人上头的事情，可以使用这样的写法：<code>0\\\\d{3}-\\\\d{8}</code>。</p>\\n<table>\\n<thead>\\n<tr>\\n<th>元字符</th>\\n<th>作用</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>d</td>\\n<td>匹配一位数字,比如 0 ，1 ，2 等任意的一位数字</td>\\n</tr>\\n<tr>\\n<td>{n}</td>\\n<td>用来指定这个元字符\\n<code>*</code>\\n前面的内容可以连续重复使用任意多次，可以使得整个表达式得到匹配</td>\\n</tr>\\n</tbody>\\n</table>\\n<h2>其他常用元字符</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>元字符</th>\\n<th>作用</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>/s</td>\\n<td>匹配任意多的空白符</td>\\n</tr>\\n<tr>\\n<td>/w</td>\\n<td>代表着可用文字，包含字母，数字，下划线，汉字</td>\\n</tr>\\n<tr>\\n<td>/s</td>\\n<td>匹配任意多的空白符</td>\\n</tr>\\n<tr>\\n<td>+</td>\\n<td>与\\n<code>{n}</code>\\n、\\n<code>*</code>\\n类似，指定当前元字符前面的内容重复多次，\\n<code>+</code>\\n专指重复\\n<code>1</code>\\n次以上</td>\\n</tr>\\n</tbody>\\n</table>\\n<h2>番外</h2>\\n<p>现在好多内容在讲正则的时候都不注意区分哪些是核心内容，在很多环境下，编程语言会对正则做出拓展，引入了很多新符号，引入了很多的复杂度，对初学者不友好。下面推荐一些文章</p>\\n<ul>\\n<li>谷歌大牛的文章：<a href=\\\"http://blog.youxu.info/2009/03/05/ree1/\\\">编程珠玑番外篇-C.正则表达式精义-1</a></li>\\n<li>进阶：<a href=\\\"http://www.cppblog.com/vczh/archive/2014/01/19/205468.html\\\">跟vczh看实例学编译原理——零：序言</a></li>\\n<li>这是一个图形化的在线正则展示网页，可以用来测试正则：<a href=\\\"https://regexper.com/\\\">Regexper</a></li>\\n</ul>\",\"fields\":{\"slug\":\"/2016-04-05---regular-expression-1/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-04-06---regular-expression-2/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"正则表达式进阶 接上一篇内容，上一篇主要介绍了正则表达式的核心内容，非常的简单易懂，现在对核心内容进行拓展。 界定符 表示正则表达式的开始和结束，具体的由解析器决定 /[0-9]/ #[0-…\",\"frontmatter\":{\"title\":\"正则表达式进阶\",\"date\":\"2016-04-06\",\"tags\":[\"regular expression\"]},\"html\":\"<h1>正则表达式进阶</h1>\\n<p>接上一篇内容，上一篇主要介绍了正则表达式的核心内容，非常的简单易懂，现在对核心内容进行拓展。</p>\\n<h2>界定符</h2>\\n<p>表示正则表达式的开始和结束，具体的由解析器决定</p>\\n<ul>\\n<li><code>/[0-9]/</code></li>\\n<li><code>#[0-9]#</code></li>\\n</ul>\\n<h2>元字符</h2>\\n<p>元字符定义了原子的筛选方式，可以将某一类原子归类，并且给出缩写，简化正则：</p>\\n<ul>\\n<li><code>|</code>匹配两个或者多个分支</li>\\n<li><code>[]</code>中括号内部的任意一个原子</li>\\n<li><code>[^]</code>匹配除括号内部原子之外的任何字符</li>\\n</ul>\\n<h3>原子的筛选</h3>\\n<p>使用<code>[]</code>可以进行原子的筛选，代表或者的关系，<code>[^]</code>代表非的关系</p>\\n<ul>\\n<li><code>[Dd]uang</code></li>\\n<li><code>(D|d)uang</code></li>\\n</ul>\\n<p>这两种方法都可以匹配到想要的内容，但具体有什么区别呢？\\n请注意在<code>[]</code>中出现的，只能是单个原子，每个原子之间都是或的关系，而使用<code>|</code>元字符，两边可以由多个原子组成来进行匹配。</p>\\n<h3>原子集合</h3>\\n<p>之所以定义了原子集合，主要是为了用来简化书写，一般原子集合，都可以通过原子筛选的方式给出，除了换行符的原子:</p>\\n<ul>\\n<li><code>\\\\d</code>数字<code>[0-9]</code></li>\\n<li><code>\\\\D</code>非数字<code>[^0-9]</code></li>\\n<li><code>\\\\s</code>不可见原子<code>[\\\\f\\\\n\\\\r\\\\t]</code></li>\\n<li><code>\\\\S</code>可见的原子</li>\\n<li><code>\\\\w</code>数字字母下划线<code>[0-9a-zA-Z_]</code></li>\\n<li><code>\\\\W</code>任意一个非下划线，数字字母<code>[^0-9a-zA-Z_]</code></li>\\n</ul>\\n<h2>量词</h2>\\n<p>所谓量词，就是表示它前面的原子重复多少次</p>\\n<ul>\\n<li><code>{d}</code>重复<code>d</code>次</li>\\n<li><code>{d,}</code> 最少重复<code>d</code>次</li>\\n<li><code>{d,b}</code> 重复<code>d</code>到<code>b</code>次</li>\\n</ul>\\n<h3>量词集合</h3>\\n<p>参考原子集合，是为了简化筛选元素。量词集合的出现也是同样的道理</p>\\n<ul>\\n<li><code>{0,}</code> 最少重复<code>0</code>次，包含<code>0</code>次</li>\\n<li><code>{1,}</code> 最少重复<code>1</code>次，包含<code>1</code>次</li>\\n<li><code>{0,1}</code> 重复<code>0</code>次或者<code>1</code>次</li>\\n</ul>\\n<h3>修正模式</h3>\\n<ul>\\n<li><code>U</code>表示贪婪模式</li>\\n<li><code>i</code>忽略大小写，用在正则中</li>\\n<li><code>x</code>忽略正则中的空格，<code>tab</code>制表符</li>\\n</ul>\\n<h2>转义</h2>\\n<p>转译，当正则占用了需要的输入</p>\\n<ul>\\n<li><code>\\\\</code></li>\\n</ul>\",\"fields\":{\"slug\":\"/2016-04-06---regular-expression-2/\"}}],\"function\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-09-01----js-function-2/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"再探JS函数 函数是JS的核心概念，主要用来封装语句，封装单独的功能。 函数参数 函数不在意它本身到底接收多少参数，不关心最后会使用多少参数。因为函数只会接收一个数组，函数可以通过 arguments…\",\"frontmatter\":{\"title\":\"再探JS函数\",\"date\":\"2016-09-07\",\"tags\":[\"JS\",\"function\"]},\"html\":\"<h1>再探JS函数</h1>\\n<p>函数是JS的核心概念，主要用来封装语句，封装单独的功能。</p>\\n<h2>函数参数</h2>\\n<p>函数不在意它本身到底接收多少参数，不关心最后会使用多少参数。因为函数只会接收一个数组，函数可以通过<code>arguments</code>属性来访问这个参数数组。关于这个数组，他其实是个对象，如下:</p>\\n<pre><code class=\\\"language-js\\\">var a = function () {var b= 1; var c = 0} //a是一个函数\\ntypeof a.arguments  // Object\\n</code></pre>\\n<p>但是为什么又说它是数组呢，因为它本身很数组很像，可以通过方括号加数字的方法来访问具体的参数，同时还有数组对象有的<code>length</code>属性。一个有趣的例子：</p>\\n<pre><code class=\\\"language-js\\\">function a (){\\n  console.log(\\\"hello\\\" +　arguments[0] + arguments[1]);\\n}\\na(\\\"hao\\\",\\\"xiang\\\"); //hellohaoxiang\\n</code></pre>\\n<p>这样子依然是有效的，在函数执行的时候，通过<code>arguments</code>对象的<code>length</code>属性可以知道被传递的参数个数，还有个更有趣的例子，是关于<code>arguments</code>的同步性的：</p>\\n<pre><code class=\\\"language-js\\\">function doAdd (num1,num2){\\n  arguments[1]=10;\\n  alert(arguments[0] + num2);\\n  }\\n  doAdd(1,1); //11，arguments[1]和num2是同步的\\n</code></pre>\\n<p>参数就是局部变量，对于函数来说，传递参数是按值的，基本类型的很好理解，相当于变量的复制。对于引用类型来说，还需要留意到此时依然是按值传递的，这个值依然是指引用的内存地址值。证明方法：需要先创建一个对象，传递函数中，此时在函数内部修改对象的属性，此时内外是一致的，因为他们是一种的一个对象。但是此时如果将参数重新初始化为一个对象，那么也就是说此时参数已经指向另一个变量了，和之前的一切无关。</p>\\n<h2>函数相关属性</h2>\\n<p><code>arguments</code>属性有一个叫做<code>callee</code>的指针，这个指针指向拥有这个<code>arguments</code>对象的函数。主要用来解除耦合，下面是关于递归算法的例子</p>\\n<pre><code class=\\\"language-js\\\">function fac (num) {\\n    switch (num){\\n        case 1 :\\n        return 1;\\n        default: return num * arguments.callee(num-1);\\n    }\\n}\\n</code></pre>\\n<p>函数的另外一个内部属性是<code>this</code>对象，<code>this</code>引用的是函数据以执行的环境对象，<code>this</code>是包含它的函数作为方法被调用是所属的对象 = 包含它的函数 + 作为方法被调用时 + 所属的对象。</p>\\n<h2>函数的方法</h2>\\n<p>主要有<code>apply</code>,<code>call</code>与<code>bind</code></p>\\n<h3><code>apply()</code>与<code>call()</code>：</h3>\\n<p>表示在特定的作用域内调用函数，与<code>call()</code>的区别在于<code>call</code>在使用时必须指定参数。</p>\\n<h2><code>bind()</code></h2>\\n<p>这个方法可以用来创建一个新的实例，实例的<code>this</code>值会被绑定到传给<code>bind()</code>的值上</p>\\n<h2>细碎的小点</h2>\\n<ul>\\n<li><code>return</code>语句，一旦<code>return</code>，后续的语句不会继续执行了，不加<code>return</code>的话，函数默认的返回值是<code>undefined</code>。</li>\\n</ul>\",\"fields\":{\"slug\":\"/2016-09-01----js-function-2/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-08-26---js-function-1/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"初探JS函数 有关函数相关的话题在网上讨论的并不够多，因为它比较复杂，这也是为什么现在网上会存在如此多的误解。 在这片文章里面，我会试着去总结有关函数的好的，坏的，丑陋的一面。 函数表达式 VS. 函数声明 在 ECMAScript…\",\"frontmatter\":{\"title\":\"初探JS函数\",\"date\":\"2016-08-26\",\"tags\":[\"JS\",\"function\"]},\"html\":\"<h1>初探JS函数</h1>\\n<p>有关函数相关的话题在网上讨论的并不够多，因为它比较复杂，这也是为什么现在网上会存在如此多的误解。 在这片文章里面，我会试着去总结有关函数的好的，坏的，丑陋的一面。</p>\\n<h2>函数表达式 VS. 函数声明</h2>\\n<p>在 ECMAScript 中，如果需要使用函数，最常用的两种方法就是通过函数表达式和函数声明。掌握它们区别非常重要，因为在JS 中两者的执行是有差别的，可惜很不爽，至少在看来， 两者之间的差别可以说是相当混乱，只有一件事是 ECMA 规范中讲清楚的—-函数声明必须要有一个函数名(规范中称为 identifier (标识)），函数表达式可以忽略函数名：</p>\\n<pre><code class=\\\"language-js\\\">// FunctionDeclaration :\\nfunction Identifier ( FormalParameterList &#x3C;opt> ){ FunctionBody }\\n// FunctionExpression :\\nfunction Identifier&#x3C;opt> ( FormalParameterList &#x3C;opt> ){ FunctionBody }\\n</code></pre>\\n<p>我们可以仔细瞧瞧，当忽略函数名时，只能是函数表达式，这个是没有争议的，因为规范中有说，函数表达式可以忽略函数名，但是如果加上函数名呢？这两种方式一模一样，我们别人说这是一个函数声明，还是一个函数表达式呢？</p>\\n<h2>区分函数表达式和函数声明</h2>\\n<p>看起来 ECMAScript 判断两者的不同是基于整个上下文的，如果<code>function foo () {}</code>是一行语句的某个部分，比如说赋值表达式的一部分，它应该是一个函数表达式，可以理解为当前赋值表达式有函数的参与。 如果<code>function foo () {}</code>被包含在一个函数体内或者直接暴露在最上层的作用域下，它就是一个函数声明。</p>\\n<pre><code class=\\\"language-js\\\">function foo(){} // 声明，因为它暴露在全局作用域下\\nvar bar = function foo () {} // 表达式，因为它是构成赋值表达式的一部分\\n new function bar () {} // 表达式，因为它是 new 语句的一部分\\n (funciton () {\\n     function bar () {} // 声明，因为它在函数体内\\n })();\\n</code></pre>\\n<p>上面的例子有个需要留意的地方，(function () {})这个函数应该算作哪一种。可以明确的说它是一个函数表达式，因为前后的两个()括号。两个括号组成一个分组运算符，而分组运算符可以包含表达式的，所以按照上面的说明，它是一部分，是一个函数表达式(注意区分编程中的语句和表达式，参考文章<a href=\\\"http://www.2ality.com/2012/09/expressions-vs-statements.html\\\">http://www.2ality.com/2012/09/expressions-vs-statements.html</a>。</p>\\n<p>区分清楚之后，来看他们之间的不同，首先在其他语句还没有执行之前，函数声明将会先被解析和执行。即便它的位置在整个页面资源的最底部，它会被在作用域中出现的时间将会先于其他的任何表达式。下面的例子演示了fn 函数声明的位置靠后，但是依然可以在声明的位置之前被调用。</p>\\n<pre><code class=\\\"language-js\\\">alert(fn());\\nfunction fn () {\\nreturn \\\"hello world~\\\"\\n}\\n</code></pre>\\n<p>另外一个绝对需要注意的特点，不要在条件语句声明函数，在不同的环境下，会有不同的处理结果，所以当遇到要依据不同条件来新建函数时，一定要使用函数表达式代替，看下面的例子：</p>\\n<pre><code class=\\\"language-js\\\">// 绝对不要这样做，由于函数声明会在其他语句没有执行之前就声明完毕，所以这里的处理逻辑比较混乱\\n// 某些浏览器会直接使用第一个声明，返回 'first'\\n// 某些会使用第二个声明 'second'\\nif (true) {\\n  function foo() {\\n    return 'first';\\n  }\\n}\\nelse {\\n  function foo() {\\n    return 'second';\\n  }\\n}\\nfoo();\\n// 当一定需要依据不同情况创建函数时，使用函数表达式的方法来代替\\nvar foo;\\nif (true) {\\n  foo = function() {\\n    return 'first';\\n  };\\n}\\nelse {\\n  foo = function() {\\n    return 'second';\\n  };\\n}\\nfoo();\\n</code></pre>\",\"fields\":{\"slug\":\"/2016-08-26---js-function-1/\"}}],\"Linux\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-06-03---shadowsocks-install/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"ShadowSocks 安装记录 这里使用的是  ubuntu 14.04 ,是我比较喜欢的一个系统。\\n首先更新  apt  源，保证获取最新的软件 之后安装  python  相关依赖， pip  包管理器，可能是类似  npm  的一种吧，没有细致研究过 通过  pip…\",\"frontmatter\":{\"title\":\"ShadowSocks 安装记录\",\"date\":\"2016-09-01\",\"tags\":[\"Linux\",\"shadowsocks\"]},\"html\":\"<h1>ShadowSocks 安装记录</h1>\\n<p>这里使用的是 <code>ubuntu 14.04</code>,是我比较喜欢的一个系统。\\n首先更新 <code>apt</code> 源，保证获取最新的软件</p>\\n<pre><code class=\\\"language-bash\\\">sudo apt-get update\\n</code></pre>\\n<p>之后安装 <code>python</code> 相关依赖，<code>pip</code> 包管理器，可能是类似 <code>npm</code> 的一种吧，没有细致研究过</p>\\n<pre><code class=\\\"language-bash\\\">sudo apt-get install python-gevent python-pip\\n</code></pre>\\n<p>通过 <code>pip</code> 安装 <code>ShadowSocks</code></p>\\n<pre><code class=\\\"language-bash\\\">sudo pip install shadowsocks\\napt-get install python-m2crypto\\n</code></pre>\\n<p>配置 <code>ShadowSocks</code> 的配置文件 <code>vim /etc/shadowsocks.json</code></p>\\n<pre><code class=\\\"language-bash\\\">{\\n    \\\"server\\\":\\\"0.0.0.0\\\",\\n    \\\"server_port\\\":8388,\\n    \\\"local_port\\\":1080,\\n    \\\"password\\\":\\\"password\\\",\\n    \\\"timeout\\\":600,\\n    \\\"method\\\":\\\"aes-256-cfb\\\"\\n}\\n</code></pre>\\n<p><code>server</code> 表示当前服务器的 <code>ip</code> 地址，<code>password</code> 更换成自己需要设置的密码</p>\\n<p>切换到 <code>root</code> 用户\\n之后启动 <code>shadowsocks</code></p>\\n<pre><code class=\\\"language-bash\\\">su -\\nssserver -c /etc/shadowsocks.json -d start\\nssserver -c /etc/shadowsocks.json -d stop\\n</code></pre>\\n<p>参考资料：\\n<a href=\\\"https://github.com/iMeiji/shadowsocks_install/wiki\\\">https://github.com/iMeiji/shadowsocks_install/wiki</a></p>\",\"fields\":{\"slug\":\"/2016-06-03---shadowsocks-install/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2017-01-22---tmux-operation/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"tmux基本操作 电脑换回了win10系统，使用bash on windows进行开发，有个问题一直很困扰。\\n在windows系统下面，少见非常优秀的，类似iTerm2那样的终端软件。使用cmder对于bash…\",\"frontmatter\":{\"title\":\"tmux日常操作\",\"date\":\"2017-01-22\",\"tags\":[\"Tmux\",\"Linux\"]},\"html\":\"<h1>tmux基本操作</h1>\\n<p>电脑换回了win10系统，使用bash on windows进行开发，有个问题一直很困扰。\\n在windows系统下面，少见非常优秀的，类似iTerm2那样的终端软件。使用cmder对于bash的美化确实起到了很大的作用，但是对屏幕的管理依然不方便。最近留意到了tmux这款终端复用工具，简单使用后，发现它的确非常棒，给我带来了不少的便利。</p>\\n<h2>Session</h2>\\n<p>创建一个Session，默认情况下，当在shell中输入<code>tmux</code>时，就会自动创建一个名称为<code>0</code>的Session</p>\\n<pre><code class=\\\"language-bash\\\">#　创建Session\\ntmux\\n# 查看当前建立的Session，使用下面两个命令\\ntmux list-session\\n# 缩写\\ntmux ls\\n0: 1 windows (created Sat Jan 21 11:27:33 2017) [55x35]\\n# 创建一个指定名称的Session\\ntmux new -s $name\\n# 使用t参数关闭指定的Session\\ntmux kill-session -t $name\\n# 将指定的Session放置到后台中\\ntmux detach -t  $name\\n# 加载处于在后台中的Session\\ntmux attach-session -t $name\\n# 完全退出，关闭所有的Session\\ntmux kill-server\\n</code></pre>\\n<h2>Window</h2>\\n<p>在Session之下，可以开设很多得当Window，其实当我们创建一个Session时，就已经会默认创建一个Window了。</p>\\n<p>在Window中，可以使用很多命令进行闪转腾挪了，默认调用命令的快捷键是<code>Ctrl-b</code>，看下面的例子：</p>\\n<pre><code class=\\\"language-bash\\\">#Ctrl-b &#x3C;command>\\n# 列出当前所有的Window\\nCtrl-b w \\n(0)  0: ~  \\\"DESKTOP-IE8ULOJ\\\"\\n(1)  1: ~  \\\"DESKTOP-IE8ULOJ\\\"\\n(2)  2: ~- \\\"DESKTOP-IE8ULOJ\\\"\\n(3)  3: ~* \\\"DESKTOP-IE8ULOJ\\\"\\n# 创建一个Wind ow （create）\\nCtrl-b c\\n# 切换到下一个Window （next）\\nCtrl-b n\\n# 切换到上一个Window（previous）\\nCtrl-b p\\n# 切换到指定序号的Window\\nCtrl-b [0-9]\\n# 重命名当前窗口的名称\\nCtrl-b ，\\n# 关闭当前窗口\\nCtrl-b &#x26;\\n</code></pre>\\n<h2>Pane</h2>\\n<p>在Window层级的切换时全屏的，可以继续分，往下的这个层级叫做Pane</p>\\n<pre><code class=\\\"language-bash\\\"># 垂直分割\\nCtrl-b %\\n# 水平分割\\nCtrl-b “”\\n# 在窗口之间切换\\nCtrl-b o\\n# 按照指定的方向切换\\nCtrl-b 方向键\\n# tmux默认有几种Pane的布局方式，这个命令用来在默认的布局方式中切换\\nCtrl-b 空格\\n# 关闭当前Pane\\nCtrl-b x\\n</code></pre>\",\"fields\":{\"slug\":\"/2017-01-22---tmux-operation/\"}}],\"shadowsocks\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-06-03---shadowsocks-install/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"ShadowSocks 安装记录 这里使用的是  ubuntu 14.04 ,是我比较喜欢的一个系统。\\n首先更新  apt  源，保证获取最新的软件 之后安装  python  相关依赖， pip  包管理器，可能是类似  npm  的一种吧，没有细致研究过 通过  pip…\",\"frontmatter\":{\"title\":\"ShadowSocks 安装记录\",\"date\":\"2016-09-01\",\"tags\":[\"Linux\",\"shadowsocks\"]},\"html\":\"<h1>ShadowSocks 安装记录</h1>\\n<p>这里使用的是 <code>ubuntu 14.04</code>,是我比较喜欢的一个系统。\\n首先更新 <code>apt</code> 源，保证获取最新的软件</p>\\n<pre><code class=\\\"language-bash\\\">sudo apt-get update\\n</code></pre>\\n<p>之后安装 <code>python</code> 相关依赖，<code>pip</code> 包管理器，可能是类似 <code>npm</code> 的一种吧，没有细致研究过</p>\\n<pre><code class=\\\"language-bash\\\">sudo apt-get install python-gevent python-pip\\n</code></pre>\\n<p>通过 <code>pip</code> 安装 <code>ShadowSocks</code></p>\\n<pre><code class=\\\"language-bash\\\">sudo pip install shadowsocks\\napt-get install python-m2crypto\\n</code></pre>\\n<p>配置 <code>ShadowSocks</code> 的配置文件 <code>vim /etc/shadowsocks.json</code></p>\\n<pre><code class=\\\"language-bash\\\">{\\n    \\\"server\\\":\\\"0.0.0.0\\\",\\n    \\\"server_port\\\":8388,\\n    \\\"local_port\\\":1080,\\n    \\\"password\\\":\\\"password\\\",\\n    \\\"timeout\\\":600,\\n    \\\"method\\\":\\\"aes-256-cfb\\\"\\n}\\n</code></pre>\\n<p><code>server</code> 表示当前服务器的 <code>ip</code> 地址，<code>password</code> 更换成自己需要设置的密码</p>\\n<p>切换到 <code>root</code> 用户\\n之后启动 <code>shadowsocks</code></p>\\n<pre><code class=\\\"language-bash\\\">su -\\nssserver -c /etc/shadowsocks.json -d start\\nssserver -c /etc/shadowsocks.json -d stop\\n</code></pre>\\n<p>参考资料：\\n<a href=\\\"https://github.com/iMeiji/shadowsocks_install/wiki\\\">https://github.com/iMeiji/shadowsocks_install/wiki</a></p>\",\"fields\":{\"slug\":\"/2016-06-03---shadowsocks-install/\"}}],\"ML\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2017-03-10---knn-2/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"机器学习之k-NN算法实战(二) 回顾上文，我们介绍了k-NN算法的原理，以及实例数据的格式，如何加载。万事俱备，下文我们来介绍k-NN算法的代码实现。 首先从store中取出样本数据，存到局部变量中 之后我们利用这些数据来进行k-NN…\",\"frontmatter\":{\"title\":\"机器学习之k-NN算法实战(二)\",\"date\":\"2017-03-10\",\"tags\":[\"ML\",\"KNN\"]},\"html\":\"<h1>机器学习之k-NN算法实战(二)</h1>\\n<p>回顾上文，我们介绍了k-NN算法的原理，以及实例数据的格式，如何加载。万事俱备，下文我们来介绍k-NN算法的代码实现。</p>\\n<p>首先从store中取出样本数据，存到局部变量中</p>\\n<pre><code class=\\\"language-py\\\">data_store = parse_data()\\n# 测试样本向量\\ntest_vectors = data_store[\\\"test_set\\\"][\\\"vectors\\\"]\\n# 测试样本的标签\\ntest_labels = data_store[\\\"test_set\\\"][\\\"labels\\\"]\\n# 训练样本的标签\\ntrain_vectors_labels = data_store[\\\"train_set\\\"][\\\"labels\\\"]\\n# 训练样本向量\\ntrain_vectors_mat = data_store[\\\"train_set\\\"][\\\"vectors\\\"]\\n</code></pre>\\n<p>之后我们利用这些数据来进行k-NN分类</p>\\n<pre><code class=\\\"language-py\\\">def classify(test_data_vector, training_data_mat, k):\\n    # 复制向量成矩阵\\n    test_data_mat = np.tile(test_data_vector, (training_data_mat.shape[0], 1))\\n    # 两个矩阵求内部向量的欧氏距离\\n    diff = test_data_mat - training_data_mat\\n    euclidean_dis = ((diff**2).sum(axis=1)) ** 0.5\\n    # 排序\\n    index_sorted = euclidean_dis.argsort()\\n    return index_sorted[:k]\\n</code></pre>\\n<p>上面的函数，我们需要的参数为测试向量，训练向量集，以及K值。我们将待测试的向量铺成和训练集相同shape的矩阵，之后直接求欧氏距离，按照预设去k个离被测试向量最近的训练向量，排序。</p>\\n<p>除了进行排序，我们还需要测试错误数据的占比，得出结论，这样才可以判断算法的优劣。</p>\\n<pre><code class=\\\"language-py\\\">def cal_vote(nearest_index, label, train_vectors_labels):\\n    # 统计错误的票数\\n    error_count = 0.0\\n    for i in range(len(nearest_index)):\\n        index = nearest_index[i]\\n        if train_vectors_labels[index] != label:\\n            error_count += 1\\n    # 错误数量过半时\\n    if error_count >= math.ceil(len(nearest_index)/2):\\n        return True\\n    else:\\n        return False\\n</code></pre>\\n<p>cal<em>vote函数接受三个参数，nearest</em>index是距离待测点最近的几个向量的索引，正确label，测试的label。之后计算投票，这里按照少数服从多数，有时候还可以按照距离的权重为各个向量加权。\\n之后我们调用上文的函数，代码如下</p>\\n<pre><code class=\\\"language-py\\\"># 分类错误的总数\\nsum_error_count = 0.0\\nfor i in range(len(test_vectors)):\\n    nearest_index = classify(test_vectors[i], train_vectors_mat, K)\\n    result = cal_vote(nearest_index, test_labels[i], train_vectors_labels)\\n    if not result:\\n        sum_error_count += 1\\n# 输出信息\\nprint(\\\"\\\\n当前位 k-NN 算法,k值为：{0}\\\".format(K))\\nprint(\\\"\\\\n分类结束，分类器分类总错误数为：{0}\\\".format(sum_error_count))\\nprint(\\\"\\\\n分类器分类错误率为：{0}%\\\".format((sum_error_count / len(train_vectors_labels))*100))\\n# 这里的k值设置为20，k值不同经常会影响分类器的效果，k=20时分类器在当前样本上，效果还不错\\n</code></pre>\\n<p>以上是算法部分，代码文件在<a href=\\\"https://github.com/getcha22/Machine-Learning/blob/master/k-NN/k-NN.py\\\">GITHUB</a>仓库中也存有备份,大家可以直接查看。</p>\\n<h2>总结</h2>\\n<p>k-NN算法的原理和实战代码部分见上文，接着我们来看看这个算法的优缺点，试用条件。</p>\\n<p>优点：</p>\\n<ul>\\n<li>简单明了，粗暴快速。这个是肯定的，核心原理就是计算两个向量的某种距离。</li>\\n<li>准确率尚可，对于一些基础的分类任务，它非常适合</li>\\n</ul>\\n<p>缺点：</p>\\n<ul>\\n<li>性能较弱，k-NN算法是懒惰学习方法，它是根据所给训练样本构造的分类器，是将所有训练样本首先存储起来，当要进行分类时，就直接进行计算处理。时间复杂度和空间复杂度都较高。</li>\\n<li>K值难以有一个确值，需要不断试。</li>\\n<li>对于非数值型的样本以及离散型的样本，我们需要对其进行数值化和连续化，比如红黄蓝等等。</li>\\n</ul>\",\"fields\":{\"slug\":\"/2017-03-10---knn-2/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2017-03-04---knn-1/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"机器学习之k-NN算法实战(一) 下文会介绍机器学习的k-NN算法，首先大致介绍k-NN算法的原理，之后我们会通过识别手写体数字这个小项目，来讲解k-NN分类算法的代码实现。 k-NN算法原理 所谓k-NN…\",\"frontmatter\":{\"title\":\"机器学习之k-NN算法实战(一)\",\"date\":\"2017-03-04\",\"tags\":[\"ML\",\"KNN\"]},\"html\":\"<h1>机器学习之k-NN算法实战(一)</h1>\\n<p>下文会介绍机器学习的k-NN算法，首先大致介绍k-NN算法的原理，之后我们会通过识别手写体数字这个小项目，来讲解k-NN分类算法的代码实现。</p>\\n<h2>k-NN算法原理</h2>\\n<p>所谓k-NN算法，全名为是一种分类算法，它属于监督式算法，也就是说对于这个算法，必须提前对数据打标签，否则无法完成分类。其次，k-NN又被人们称为是“懒汉”算法，或者说“惰性学习”，这是因为k-NN并不会像神经网络，线性回归那样直接训练出一个模型来，下文会逐步介绍。</p>\\n<p>使用k-NN算法进行分类，输入一个未知分类的测试数据，通过计算其与已知分类数据之间的某种距离，之后从训练数据中抽离出距离测试数据较近的样本，一一查看其分类，再进行多数表决，即可估算出测试数据的分类。\\n下面举个例子：</p>\\n<p><img src=\\\"\\\" alt=\\\"k-NN图例\\\"></p>\\n<p>绿圆是我们需要进行分类的测试数据，为了确定它的分类，我们可以通过欧式距离公式计算它和整个空间上所有样本的距离。按照我们预先设置的K值，找到离它最近的K个样本，上图我们假设了K值为3，我们发现实线圆中有三个训练样本与测试样本最接近，分别为两个红三角，一个蓝方块。于是我们推算出这个绿圆的分类与红三角相同。</p>\\n<h2>获取数据</h2>\\n<p>下面我们通过识别手写体数据这个实例来进行说明。手写体数字，就是下面图片展示的数据，他们没有完全统一的规则，我们需要让计算机在数据中发现规律，帮助我们识别新的手写体数字是几。</p>\\n<p><img src=\\\"\\\" alt=\\\"手写体数字\\\"></p>\\n<p>首先我们获取训练数据，还有测试数据。我们可以google MNIST这个关键字，之后从上面下载已经打好标签的数据，也可以直接从我的<a href=\\\"https://github.com/getcha22/Machine-Learning/tree/master/k-NN\\\">GITHUB仓库</a>里面直接复制粘贴，毕竟我们学习的目标是算法。</p>\\n<p>下面我们看看这些数据：</p>\\n<p><img src=\\\"\\\" alt=\\\"手写体数字1\\\">\\n<img src=\\\"\\\" alt=\\\"手写体数字2\\\"></p>\\n<p>每行数据会构成一个样本，训练集共有100个这样的样本，每个样本第一列是该样本的标签(见图一)。通过0-255表达某个像素的灰度值，0表示纯黑色，而255表示白色，其他值介于两者之间。\\n好，解释清楚样本的格式，我们现在需要加这些数据引入代码中，这样才可以对他们操作：</p>\\n<pre><code class=\\\"language-py\\\">    \\ndef parse_data():\\n    file_names = [\\n        'MNIST_data/mnist_train_100.csv',\\n        'MNIST_data/mnist_test_10.csv'\\n    ]\\n    # 整个存入dict，方便传递\\n    store = {}\\n    for file_name in range(2):\\n        # 拼接 dict 的 key 值\\n        type = file_names[file_name].split('_')[2] + '_set'\\n        labels = []\\n        vectors = []\\n        file = open(file_names[file_name])\\n        content = file.readlines()\\n        # 截取 str 中的 label， 将剩余部分转换成 ndarray，后续求距离会更高效\\n        for line in content:\\n            label = line[0]\\n            vector = line[2:-3].split(',')\\n            if (label and vector):\\n                labels.append(label)\\n                vectors.append(vector)\\n        vectors = np.array(vectors,dtype=float)\\n        store[type] = {\\n            \\\"labels\\\": labels,\\n            \\\"vectors\\\": vectors\\n        }\\n    return store\\n</code></pre>\\n<p>parse_data这个函数用来从存放数据的目录中加载数据，训练集中有100个样本，测试集中有10个测试样本，读取成功之后，将样本分类整理好，存放成dict格式，方便之后使用。\\n加载数据这个步骤完成了，接着我们就要进行分类代码的编写，请见下篇。</p>\",\"fields\":{\"slug\":\"/2017-03-04---knn-1/\"}}],\"KNN\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2017-03-10---knn-2/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"机器学习之k-NN算法实战(二) 回顾上文，我们介绍了k-NN算法的原理，以及实例数据的格式，如何加载。万事俱备，下文我们来介绍k-NN算法的代码实现。 首先从store中取出样本数据，存到局部变量中 之后我们利用这些数据来进行k-NN…\",\"frontmatter\":{\"title\":\"机器学习之k-NN算法实战(二)\",\"date\":\"2017-03-10\",\"tags\":[\"ML\",\"KNN\"]},\"html\":\"<h1>机器学习之k-NN算法实战(二)</h1>\\n<p>回顾上文，我们介绍了k-NN算法的原理，以及实例数据的格式，如何加载。万事俱备，下文我们来介绍k-NN算法的代码实现。</p>\\n<p>首先从store中取出样本数据，存到局部变量中</p>\\n<pre><code class=\\\"language-py\\\">data_store = parse_data()\\n# 测试样本向量\\ntest_vectors = data_store[\\\"test_set\\\"][\\\"vectors\\\"]\\n# 测试样本的标签\\ntest_labels = data_store[\\\"test_set\\\"][\\\"labels\\\"]\\n# 训练样本的标签\\ntrain_vectors_labels = data_store[\\\"train_set\\\"][\\\"labels\\\"]\\n# 训练样本向量\\ntrain_vectors_mat = data_store[\\\"train_set\\\"][\\\"vectors\\\"]\\n</code></pre>\\n<p>之后我们利用这些数据来进行k-NN分类</p>\\n<pre><code class=\\\"language-py\\\">def classify(test_data_vector, training_data_mat, k):\\n    # 复制向量成矩阵\\n    test_data_mat = np.tile(test_data_vector, (training_data_mat.shape[0], 1))\\n    # 两个矩阵求内部向量的欧氏距离\\n    diff = test_data_mat - training_data_mat\\n    euclidean_dis = ((diff**2).sum(axis=1)) ** 0.5\\n    # 排序\\n    index_sorted = euclidean_dis.argsort()\\n    return index_sorted[:k]\\n</code></pre>\\n<p>上面的函数，我们需要的参数为测试向量，训练向量集，以及K值。我们将待测试的向量铺成和训练集相同shape的矩阵，之后直接求欧氏距离，按照预设去k个离被测试向量最近的训练向量，排序。</p>\\n<p>除了进行排序，我们还需要测试错误数据的占比，得出结论，这样才可以判断算法的优劣。</p>\\n<pre><code class=\\\"language-py\\\">def cal_vote(nearest_index, label, train_vectors_labels):\\n    # 统计错误的票数\\n    error_count = 0.0\\n    for i in range(len(nearest_index)):\\n        index = nearest_index[i]\\n        if train_vectors_labels[index] != label:\\n            error_count += 1\\n    # 错误数量过半时\\n    if error_count >= math.ceil(len(nearest_index)/2):\\n        return True\\n    else:\\n        return False\\n</code></pre>\\n<p>cal<em>vote函数接受三个参数，nearest</em>index是距离待测点最近的几个向量的索引，正确label，测试的label。之后计算投票，这里按照少数服从多数，有时候还可以按照距离的权重为各个向量加权。\\n之后我们调用上文的函数，代码如下</p>\\n<pre><code class=\\\"language-py\\\"># 分类错误的总数\\nsum_error_count = 0.0\\nfor i in range(len(test_vectors)):\\n    nearest_index = classify(test_vectors[i], train_vectors_mat, K)\\n    result = cal_vote(nearest_index, test_labels[i], train_vectors_labels)\\n    if not result:\\n        sum_error_count += 1\\n# 输出信息\\nprint(\\\"\\\\n当前位 k-NN 算法,k值为：{0}\\\".format(K))\\nprint(\\\"\\\\n分类结束，分类器分类总错误数为：{0}\\\".format(sum_error_count))\\nprint(\\\"\\\\n分类器分类错误率为：{0}%\\\".format((sum_error_count / len(train_vectors_labels))*100))\\n# 这里的k值设置为20，k值不同经常会影响分类器的效果，k=20时分类器在当前样本上，效果还不错\\n</code></pre>\\n<p>以上是算法部分，代码文件在<a href=\\\"https://github.com/getcha22/Machine-Learning/blob/master/k-NN/k-NN.py\\\">GITHUB</a>仓库中也存有备份,大家可以直接查看。</p>\\n<h2>总结</h2>\\n<p>k-NN算法的原理和实战代码部分见上文，接着我们来看看这个算法的优缺点，试用条件。</p>\\n<p>优点：</p>\\n<ul>\\n<li>简单明了，粗暴快速。这个是肯定的，核心原理就是计算两个向量的某种距离。</li>\\n<li>准确率尚可，对于一些基础的分类任务，它非常适合</li>\\n</ul>\\n<p>缺点：</p>\\n<ul>\\n<li>性能较弱，k-NN算法是懒惰学习方法，它是根据所给训练样本构造的分类器，是将所有训练样本首先存储起来，当要进行分类时，就直接进行计算处理。时间复杂度和空间复杂度都较高。</li>\\n<li>K值难以有一个确值，需要不断试。</li>\\n<li>对于非数值型的样本以及离散型的样本，我们需要对其进行数值化和连续化，比如红黄蓝等等。</li>\\n</ul>\",\"fields\":{\"slug\":\"/2017-03-10---knn-2/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2017-03-04---knn-1/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"机器学习之k-NN算法实战(一) 下文会介绍机器学习的k-NN算法，首先大致介绍k-NN算法的原理，之后我们会通过识别手写体数字这个小项目，来讲解k-NN分类算法的代码实现。 k-NN算法原理 所谓k-NN…\",\"frontmatter\":{\"title\":\"机器学习之k-NN算法实战(一)\",\"date\":\"2017-03-04\",\"tags\":[\"ML\",\"KNN\"]},\"html\":\"<h1>机器学习之k-NN算法实战(一)</h1>\\n<p>下文会介绍机器学习的k-NN算法，首先大致介绍k-NN算法的原理，之后我们会通过识别手写体数字这个小项目，来讲解k-NN分类算法的代码实现。</p>\\n<h2>k-NN算法原理</h2>\\n<p>所谓k-NN算法，全名为是一种分类算法，它属于监督式算法，也就是说对于这个算法，必须提前对数据打标签，否则无法完成分类。其次，k-NN又被人们称为是“懒汉”算法，或者说“惰性学习”，这是因为k-NN并不会像神经网络，线性回归那样直接训练出一个模型来，下文会逐步介绍。</p>\\n<p>使用k-NN算法进行分类，输入一个未知分类的测试数据，通过计算其与已知分类数据之间的某种距离，之后从训练数据中抽离出距离测试数据较近的样本，一一查看其分类，再进行多数表决，即可估算出测试数据的分类。\\n下面举个例子：</p>\\n<p><img src=\\\"\\\" alt=\\\"k-NN图例\\\"></p>\\n<p>绿圆是我们需要进行分类的测试数据，为了确定它的分类，我们可以通过欧式距离公式计算它和整个空间上所有样本的距离。按照我们预先设置的K值，找到离它最近的K个样本，上图我们假设了K值为3，我们发现实线圆中有三个训练样本与测试样本最接近，分别为两个红三角，一个蓝方块。于是我们推算出这个绿圆的分类与红三角相同。</p>\\n<h2>获取数据</h2>\\n<p>下面我们通过识别手写体数据这个实例来进行说明。手写体数字，就是下面图片展示的数据，他们没有完全统一的规则，我们需要让计算机在数据中发现规律，帮助我们识别新的手写体数字是几。</p>\\n<p><img src=\\\"\\\" alt=\\\"手写体数字\\\"></p>\\n<p>首先我们获取训练数据，还有测试数据。我们可以google MNIST这个关键字，之后从上面下载已经打好标签的数据，也可以直接从我的<a href=\\\"https://github.com/getcha22/Machine-Learning/tree/master/k-NN\\\">GITHUB仓库</a>里面直接复制粘贴，毕竟我们学习的目标是算法。</p>\\n<p>下面我们看看这些数据：</p>\\n<p><img src=\\\"\\\" alt=\\\"手写体数字1\\\">\\n<img src=\\\"\\\" alt=\\\"手写体数字2\\\"></p>\\n<p>每行数据会构成一个样本，训练集共有100个这样的样本，每个样本第一列是该样本的标签(见图一)。通过0-255表达某个像素的灰度值，0表示纯黑色，而255表示白色，其他值介于两者之间。\\n好，解释清楚样本的格式，我们现在需要加这些数据引入代码中，这样才可以对他们操作：</p>\\n<pre><code class=\\\"language-py\\\">    \\ndef parse_data():\\n    file_names = [\\n        'MNIST_data/mnist_train_100.csv',\\n        'MNIST_data/mnist_test_10.csv'\\n    ]\\n    # 整个存入dict，方便传递\\n    store = {}\\n    for file_name in range(2):\\n        # 拼接 dict 的 key 值\\n        type = file_names[file_name].split('_')[2] + '_set'\\n        labels = []\\n        vectors = []\\n        file = open(file_names[file_name])\\n        content = file.readlines()\\n        # 截取 str 中的 label， 将剩余部分转换成 ndarray，后续求距离会更高效\\n        for line in content:\\n            label = line[0]\\n            vector = line[2:-3].split(',')\\n            if (label and vector):\\n                labels.append(label)\\n                vectors.append(vector)\\n        vectors = np.array(vectors,dtype=float)\\n        store[type] = {\\n            \\\"labels\\\": labels,\\n            \\\"vectors\\\": vectors\\n        }\\n    return store\\n</code></pre>\\n<p>parse_data这个函数用来从存放数据的目录中加载数据，训练集中有100个样本，测试集中有10个测试样本，读取成功之后，将样本分类整理好，存放成dict格式，方便之后使用。\\n加载数据这个步骤完成了，接着我们就要进行分类代码的编写，请见下篇。</p>\",\"fields\":{\"slug\":\"/2017-03-04---knn-1/\"}}],\"Node\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-10-01---node-file-system/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"Node文件系统 Node 通过封装基本的 POSIX 函数来提供文件系统，使用 require('fs…\",\"frontmatter\":{\"title\":\"Node文件系统\",\"date\":\"2016-10-01\",\"tags\":[\"Node\",\"JS\"]},\"html\":\"<h1>Node文件系统</h1>\\n<p><code>Node</code>通过封装基本的<code>POSIX</code>函数来提供文件系统，使用<code>require('fs')</code>来使用这个模块，所有与文件相关的方法，都提供了异步和同步的形式。 异步的方法通常会将一个可选的回调函数作为最后一个参数，回调函数的第一个参数通常留给意外情况，如果操作是成功的，第一个参数将是<code>null</code>或者<code>undeefined</code>。 使用同步方法，对于任何意外都会即时抛出，可以使用<code>try/catch</code>语句来处理意外情况，或者让错误时间向上冒泡。 下面是一个有关异步方法的基本例子：</p>\\n<pre><code class=\\\"language-js\\\">const fs = require('fs');\\nfs.unlink('/tmp/hello', (err) => {\\n  if (err) throw err;\\n  console.log('sucessfully deleted /tmp/hello');\\n}\\n</code></pre>\\n<p>再跟着一个同步的例子：</p>\\n<pre><code class=\\\"language-js\\\">const fs = require('fs');\\nfs.unlink('/tmp/hello');\\nconsole.log('successfully deleted /tmp/hello');\\n</code></pre>\\n<p>使用异步方法时，需要注意异步方法的执行不一定按照书写顺序，比如下面这种写法很容易出错：</p>\\n<pre><code class=\\\"language-js\\\">fs.rename('/tmp/hello', '/tmp/world', (err) => {\\n   if (err) throw err;\\n   console.log('renamed compelte');\\n});\\nfs.stat('/tmp/world', (err, stats) => {if (err) throw err;\\nconsole.log(`stats: ${JSON.stringify(stats)}`)});\\n</code></pre>\\n<p>在这里，很可能<code>fs.stat</code>函数先于<code>fs.rename</code>，这样会出现一些不必要的错误，正确的方法应该是写在回调函数中:</p>\\n<pre><code class=\\\"language-js\\\">fs.rename('/tmp/hello/', '/tmp/world', (err) ss=> {\\n    if (err) throw err;\\n    fs.stat('/tmp/world'),(err, stats) => {\\n        console.log(`stats: ${JSON.stringfy(stats)});\\n    });\\n});\\n</code></pre>\\n<p>执行复杂耗时的方法，强烈建议使用异步版本，同步方法在它们执行结束之前，会一直锁住当前线程，阻断所有操作。 在<code>fs</code>模块中，可以使用相对路径，但是需要留意参照的路径来自于<code>process.cwd()</code>的返回值。 很多<code>fs</code>函数可以忽略掉回调参数，如果这样进行使用，默认会抛出错误，为了跟踪到函数调用的位置，可以设置<code>NODE_DEBUG</code>环境变量：</p>\\n<pre><code class=\\\"language-bash\\\">$ cat script.js\\nfunction bad() {\\n  require('fs').readFile('/');\\n}\\nbad();\\n$ env NODE_DEBUG=fs node script.js\\nfs.js:66\\n        throw err;\\n              ^\\nError: EISDIR, read\\n    at rethrow (fs.js:61:21)\\n    at maybeCallback (fs.js:79:42)\\n    at Object.fs.readFile (fs.js:153:18)\\n    at bad (/path/to/script.js:2:17)\\n    at Object.&#x3C;anonymous> (/path/to/script.js:5:1)\\n    &#x3C;etc.>\\n</code></pre>\\n<p><code>fs.watch(filename[, options][, listener])</code>监听制定文件或者目录的变化情况，<code>filename</code>参数可以是文件或者目录，这个方法返回一个<code>fs.FSWather</code>对象。 第二个参数是可选的，提供的<code>options</code>参数应该是一个对象，里面要求的成员是<code>persistent</code>和<code>recursive</code>，这个两个成员都是布尔类型的值。 用做监听的回调函数有两个参数，分别是(<code>event</code>, <code>filename</code>)，<code>event</code>的值视情况，返回字符串<code>change</code>，<code>rename</code>，文件名指的是触发事件的这个文件。看下面的这个例子：</p>\\n<pre><code class=\\\"language-js\\\">// node.md\\n// 被监听的文件\\nthis is cat.\\n// app.js\\n// 用来监听文件改变\\n    fs.watch('./node.md', (event, filename) => {\\n        console.log('下面是event参数，event参数的类型，filename');\\n        console.log(typeof event);\\n        console.log(filename);\\n    });\\n// node.md\\n// 这里修改了监听的node.md文件\\nthis is dog.\\n// console\\n// 执行结果\\n下面是event参数，event参数的类型，filename\\nchange\\nstring\\nnode.md\\n// node.md => node1.md\\n// 修改文件的名字\\n// console\\n// 执行结果\\n下面是event参数，event参数的类型，filename\\nrename\\nstring\\nnode1.md\\n</code></pre>\\n<p>注意事项： <code>fs.watch</code>并不是跨所有平台的，在某些常见下不一定可用。 第二个参数中的布尔值<code>recursive</code>只在<code>osx</code>和<code>window</code>下可以使用。</p>\\n<h2>可用性</h2>\\n<ul>\\n<li><code>fs.watch</code>依赖于操作系统底层模块，由操作系统底层模块通知Node文件的变化。</li>\\n<li>如果某个操作系统底层模块对于文件的监听本身就有问题，那么<code>fs.watch</code>是无法发挥作用的，比如监听了一些不可靠的目录和文件，网络文件系统，虚拟机系统中的文件。</li>\\n<li>在<code>Linux</code>，<code>osx</code>系统中，<code>fs.watch</code>解析路径成一个索引节点，并且监听这个节点，但是如果监听的节点被删除或者重新创建，那么此时它就成了一个新节点了，<code>watch</code>将会发送一个<code>delete</code>事件，但是仍然监听原来的节点，原来的事件不会响应新节点的改变，这种处理是符合预期的。</li>\\n<li><code>filename</code>参数只支持在<code>Linux</code>和<code>windows</code>上面指定(<code>osx</code>也可以，但是有些情况可能会有异常)，事实上，即便是在可以使用的平台上，也不建议直接使用这个参数，因为在回调函数内部，建议增加一些逻辑判断，看一下<code>filename</code>是否为<code>null</code>，如下面的例子：</li>\\n</ul>\\n<pre><code class=\\\"language-js\\\">fs.watch('somedir', (event, filename) => {\\n    console.log(`event is: ${event}`);\\n    if (filename) {\\n         console.log(`filename provided: ${filename}`);\\n     } else {\\n         console.log('filename not provided');\\n     }\\n});\\n</code></pre>\",\"fields\":{\"slug\":\"/2016-10-01---node-file-system/\"}}],\"Tmux\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2017-01-22---tmux-operation/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"tmux基本操作 电脑换回了win10系统，使用bash on windows进行开发，有个问题一直很困扰。\\n在windows系统下面，少见非常优秀的，类似iTerm2那样的终端软件。使用cmder对于bash…\",\"frontmatter\":{\"title\":\"tmux日常操作\",\"date\":\"2017-01-22\",\"tags\":[\"Tmux\",\"Linux\"]},\"html\":\"<h1>tmux基本操作</h1>\\n<p>电脑换回了win10系统，使用bash on windows进行开发，有个问题一直很困扰。\\n在windows系统下面，少见非常优秀的，类似iTerm2那样的终端软件。使用cmder对于bash的美化确实起到了很大的作用，但是对屏幕的管理依然不方便。最近留意到了tmux这款终端复用工具，简单使用后，发现它的确非常棒，给我带来了不少的便利。</p>\\n<h2>Session</h2>\\n<p>创建一个Session，默认情况下，当在shell中输入<code>tmux</code>时，就会自动创建一个名称为<code>0</code>的Session</p>\\n<pre><code class=\\\"language-bash\\\">#　创建Session\\ntmux\\n# 查看当前建立的Session，使用下面两个命令\\ntmux list-session\\n# 缩写\\ntmux ls\\n0: 1 windows (created Sat Jan 21 11:27:33 2017) [55x35]\\n# 创建一个指定名称的Session\\ntmux new -s $name\\n# 使用t参数关闭指定的Session\\ntmux kill-session -t $name\\n# 将指定的Session放置到后台中\\ntmux detach -t  $name\\n# 加载处于在后台中的Session\\ntmux attach-session -t $name\\n# 完全退出，关闭所有的Session\\ntmux kill-server\\n</code></pre>\\n<h2>Window</h2>\\n<p>在Session之下，可以开设很多得当Window，其实当我们创建一个Session时，就已经会默认创建一个Window了。</p>\\n<p>在Window中，可以使用很多命令进行闪转腾挪了，默认调用命令的快捷键是<code>Ctrl-b</code>，看下面的例子：</p>\\n<pre><code class=\\\"language-bash\\\">#Ctrl-b &#x3C;command>\\n# 列出当前所有的Window\\nCtrl-b w \\n(0)  0: ~  \\\"DESKTOP-IE8ULOJ\\\"\\n(1)  1: ~  \\\"DESKTOP-IE8ULOJ\\\"\\n(2)  2: ~- \\\"DESKTOP-IE8ULOJ\\\"\\n(3)  3: ~* \\\"DESKTOP-IE8ULOJ\\\"\\n# 创建一个Wind ow （create）\\nCtrl-b c\\n# 切换到下一个Window （next）\\nCtrl-b n\\n# 切换到上一个Window（previous）\\nCtrl-b p\\n# 切换到指定序号的Window\\nCtrl-b [0-9]\\n# 重命名当前窗口的名称\\nCtrl-b ，\\n# 关闭当前窗口\\nCtrl-b &#x26;\\n</code></pre>\\n<h2>Pane</h2>\\n<p>在Window层级的切换时全屏的，可以继续分，往下的这个层级叫做Pane</p>\\n<pre><code class=\\\"language-bash\\\"># 垂直分割\\nCtrl-b %\\n# 水平分割\\nCtrl-b “”\\n# 在窗口之间切换\\nCtrl-b o\\n# 按照指定的方向切换\\nCtrl-b 方向键\\n# tmux默认有几种Pane的布局方式，这个命令用来在默认的布局方式中切换\\nCtrl-b 空格\\n# 关闭当前Pane\\nCtrl-b x\\n</code></pre>\",\"fields\":{\"slug\":\"/2017-01-22---tmux-operation/\"}}],\"summary\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2017-01-01---final-summary-2016/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"2016年终总结 2016年，已经2…\",\"frontmatter\":{\"title\":\"2016年终总结\",\"date\":\"2017-01-01\",\"tags\":[\"summary\"]},\"html\":\"<h1>2016年终总结</h1>\\n<p>2016年，已经22岁的我最终没有留下来继续工作，选择了求学。这一年很多事情都很矛盾，开始选择自己做大决定。像孩子第一次进入糖果店一样，我尝到了努力和学习的甜头，开始越来越不可收拾。</p>\\n<h2>年初的复习</h2>\\n<p>当时我算是彻底的一无所有，虽然琢磨制作网页小半年的时间了，越来越了解相关知识，但与知乎上回答问题的那些年轻人依然相差很远，自己知道自己的斤两。那时候身边的大部分事情都比较糟糕，我本专业学的差劲，也不感兴趣。就这样断断续续的拖到放假。</p>\\n<p>按照惯性，我就和之前十几年重复的事情一样，被动的去尝试一切的可能性，也还和高考中考一样，父母永远会对我有期待，永远倾尽他们的一切来为我的可能性很小的未来让路，这一路走来我上很一般的高中，上大专，都一直没有变过。</p>\\n<p>但这次有些不一样，我也记不得转变是从什么时候开始的，但是肯定不会是突然开始的。可能是由于半年断断续续，三天打鱼两天晒网的学习前端吧，好多个三天打鱼两天晒网连在一起不知道算不算打鱼晒网了。</p>\\n<p>总之我开始一个人找安静的地方做自己的小东西，学点别人不懂的东西，偶尔一个下午窝在图书馆学点自己的东西，这样间接的为我带来了断断续续的成就感。结果确实如常人所说的不重要，做这些事情换来在性格上的提升影响了后面的专转本复习过程。</p>\\n<p>到专转本复习的那段时间，我开始像书上说的一样，每天就是学习，但也并没有对专转本保证非常强烈的渴望，只是很平淡的学习。父亲惊讶于我的改变，奶奶也很吃惊，逢人就说。那个时候我心里可真是五味杂陈，过去作为一个学生，10多年的学生，却从未像学生一样努力学习过。第一次努力学习就成为别人眼中的异类。本来一件很普通，很理所当然应该去做的事情，我拖了这么多年才做成，在别人眼中依然是惊叹。但我也感谢这些现象，我没有太多的分心和彷徨。</p>\\n<p>在复习的初期，有件非常重要的事情，也是非常好运的事情，美团那边的三面来了，是我在火车上的时候，技术工程部这边的未来同事通知我参加三面，当时非常惊讶，因为二面20道题，我仅仅做出了2道题，已经不抱有希望了。事后我觉得可能是因为益国给我布置的作业我写的比较认真吧，一个不算难的问题我用了好多种方法，而且写满了注释来解释自己的思路。</p>\\n<p>不管如何，迎来了三面，我把这件事情告诉了父亲。他在县城呆了太多年，对美团是什么样子的公司根本不了解，觉得应该上不了台面，也可能因为过去十几年我从未让父亲自豪过，父亲觉得我很难成功，但是父亲碍于我的面子，依然允许我抽几天时间准备前端的面试。</p>\\n<p>我没有准备太久，三面非常快就来了，主要是面试官提示，引导。我自己把自己会的东西一股脑的往出说，那时可真是痛快，在原来专科是没有人听我这么倾诉的。最棒的是面试官的知识非常的广，基本我这里提到什么，他都能问到难点上，我就开动脑子尽量去想，放大胆说，遇到实在不会的，我就尽量说说相关的内容，我学习前端知识时间有限，掌握和了解的知识其实不多，但是面试气氛是非常的不错，总共进行了大约一个半小时。之前我担心会需要写代码，怕家里的网络不好，还专门去了县城的网吧， 后来因为网吧太吵了，而且信号不好，我干脆到街上，一边说一边找安静的地方，最后在一个叫不出名字的小区落脚。哈哈，有一说一，会就会，不会就大致说说相关的内容，但是不瞎说。这次面试我非常的满意，我的计算机基础可能与科班出身差很多，但是关于CSS，JS的了解我还相对自信一些。面试结束后大概三天左右，就有结果通知我，处理掉一些另外的小插曲，约定好专转本结束（周六）后的周一去报到。</p>\\n<p>无话可说的日子才是最好的日子，专转本的复习远远超过我高考的复习强度，爸爸和奶奶见证我的变化，也不断的给我支持。到考试前2天我从县城回到太原坐车前往徐州，参加专转本的考试。</p>\\n<p>回想专转本考试也非常有趣，因为我没有报过什么补习班，也没有做过模拟题和技巧类的训练，导致我的时间规划非常差，英语甚至没有写完，一道题磨磨蹭蹭，老是不放心结果。数学从前到后才写了一次，遗漏都没有足够的时间检查，就要交卷了，计算机是我的强项，也仅仅是刚刚好。想想也好玩，这么多年，包括高考在内的考试从来都是把自己掏干净，却什么也写不出，剩余的时间就是不断的东张西望，现在是心里面有很多东西，却来不及写，哈哈。</p>\\n<p>不管如何专转本就结束了，和几个在校的同学吃了点东西，就拉着行李去北京，我父亲提前一天在那里提前帮我找房子。当时其实也是战战兢兢，担心去了北京之后，美团万一又说不要我了，到时候该怎么办，之前在加工厂干活时，加工一块4m长的阳光板只给我5毛钱，一天累死累活挣30块钱。现在让我相信自己将来工作的地方有苹果顶配的笔记本，有3000块钱的工程椅，还有健身房，简直是奇幻了。</p>\\n<p>报到的那边早上，怕父亲忙，就让他先回去了，我准时去了公司，从hr那里填写了入职相关的内容，部门的负责人崔凯迟迟不来接我去工位，大概10点半了。hr让我给崔凯打个电话。崔凯江湖气的声音在电话里面响起：郝翔？你到了吗？好，你就在那里等着，我现在还回不回去，被堵路上了，我让兄弟们接你去。哈哈，也是这个时候心才放了下去。不一会儿益国来接我的，他是我后边为我引路的师傅。</p>\\n<h2>美团半年</h2>\\n<p>在美团那里的一切都充满了快乐。因为之前使用ubuntu的进行开发，这让我用一周时间熟悉了工作工具，三周学习了React相关的技术栈，之后改线上的bug，leader帮我review代码，这些和大多数人的过程一样。因为我慌张着担心自己是新人中最慢的，所以每天总是拖着到最后一个才敢离开，放松当天紧张的心情。</p>\\n<p>那时的我总是喜欢没话找话说，抓住和别人在一起聊天的时间问问题，不断的询问同事我的成长是否慢了，我如何改进。父亲也每天给我打电话，询问我的进展，给我鼓励。女朋友给我打气，陪伴我。因为好不容易才拥有的，所以那段时间非常珍惜。</p>\\n<p>到4月份我已经完成了第一次的业务开发，返校处理毕业的问题。现在想想那时被毕业设计真是搞得焦头烂额。学校的某些奇葩规定让人瞠目结算，论文的要求高过我们的水平，主动让我们抄袭袭。不去留意内容，仅仅不断的给我们找排版上的毛病，学生们普遍比较无奈，只有不断的花钱去整篇整篇的重新打印。一本施工组织设计厚一些的三百来页，往事不堪回首啊。</p>\\n<p>不管如何结束了毕业问题，回到美团继续工作。这段时间我过得紧张且充满挑战性。产品那边觉得公司关于登陆验证方面重复开发比较频繁，点评和美团和并之后更甚，浪费了不少开发资源。想要我和后端抽离现在的验证页面，开发一种适配公司各种业务，嵌入到网页中可以直接使用的验证模块。这个模块从产品构思，开发到部署的过程我都经历了，在三个月的时间内，我积累了不少的开发和编程经验。leader没有因为我是实习生就仅仅让我打打杂，他给我足够多的自主性，这些是传统企业中少有的，非常感激这段时光。</p>\\n<p>让我印象深刻的一个同事也是一个胖子，他的水平很高，经常分享一些技术文章，我们时常在一些热门论坛上看到他的文章。我们争议两点：一是因为我想为项目开发一个简单的，类似解析器的函数，在JS中写HTML时，可以为DOM元素自动绑定上对应的响应函数，方便后边的开发。当时我摆出的观点是编程不应该重复，不该写一些easy代码。同时可以提高后续开发的效率，因为整个解析函数非常的简单，干净。他的观点与我相反，觉得我不应该做这个解析器，因为这样后续维护我代码的人必须了解这个解析函数，哪怕他足够简单。</p>\\n<p>第二件事情就是我想走之后将项目交给他，他因为解析函数的问题，觉得我的项目里面都是坑，不情愿接。同时表明了他后半年的工作任务必须围绕React，他不想接触其他的技术栈，担心隔一段时间之后就会忘记React的。给我留下记忆的是他口述过程中对于工作的规划非常清晰，且独立强烈的工作学习方向。他的想法没有问题，但这些与我的观念不合，我认为我当时刚来的时候也是学习React 的，我做这个项目不也是牺牲了自己学习新技术的机会吗？为什么我可以为了业务转变，而他就不行呢，况且转换也不以为着没有新挑战。</p>\\n<h2>爱情</h2>\\n<p>贯穿在2016年的事情，除了亲情，便是爱情了。</p>\\n<p>2014年中我们在一起，到2016年便是我们在一起的第1.5年。他离开了学校，正式工作。我从学校切换到工作再切换到学校。我们这一年没有了2015年的轻松活泼感，对未来的焦虑和我们身份上的区别不断的代入和影响我们的感情。</p>\\n<p>回想起来她背着布袋，在街上走，傻傻的样子就感觉很甜蜜。记得早一年的冬天，因为工资过低，她又不想和家里人要钱，白天去工作，晚上回来之后还要去鸡公煲店里面打工，去端盘子，洗碗。本该窝在家里的冬天，小小的她却为了生活去忍受冰冷。我真的很庆幸有她，她小小的身体里面有着坚强和勇敢的种子，愿意吃苦去忍受。</p>\\n<p>过程总是充满了磕磕绊绊，但是在结束时，留在心中回忆起来，甜的更多些。</p>\\n<p>回想这一年走来，和我女朋友的感情一波三折，都说理不清楚的就是爱情。在一起也二年多了，哪里分得清楚谁欠谁，谁付出的多一些，所有的事情都搅在了一起。</p>\\n<p>我们在一起就想要甜甜的度过每一天。但这一年可能是我们所有弱点都完全展示给对方的一年了，我们都是两个孩子。</p>\\n<p>年初一切还好，我在全身心的准备考试，基本每天的交流时间很少，并没有留下多少记忆。三月底到北京工作时候，我们的交流开始增多了，美团的实习工资很高，我当时其实是难以相信的，一向没有经济规划的我兴冲冲的想要购置物品，买零食，买手机。</p>\\n<p>我们在假期一起去清华北大，但是到了之后发现那边真的好大啊，人好多。顶级学府门口的保安都感觉和镀了金一样，里面的学生看起来非常的忙，骑车子的速度很快，我当时感觉很诧异，想着他们也不怕撞了人。但本着宽容的心态，我无耻的换位思考了一下，作为清北的学生，每天和猴子一样被参观者指指点点，总是会有些不适应的。\\n其实我们从北大出来之后，就没有去清华了，感觉那里好大，莫名其妙就下午快四点了，两只肥仔我们必须去觅食了，走走停停，嘟嘟嚷嚷的去吃自助，一路上她不断的抱怨“走不动了，还有多远，还有那么远啊”，哈哈！</p>\\n<p>我们去天安门，吃天安门侧门售卖的5元钱一根的烤肠，感觉是那么好吃，哈哈。一起去逛护城河，拍照片，我每次拍照片都不拍不好，别人给我的时候我还老是扭捏。也从小到大一直没有积累照片的习惯，不知道将来年纪再大些会不会后悔。</p>\\n<p>去天安门后，我们还去了天安门对面的街上闲逛，一家店铺是卖首饰零碎的，我看到门口有卖酥饼的，我当时非常饿，看到两块钱一个，就进去买了一个。买的时候问的很好：这个里面是什么馅呢？一个男的说是黑芝麻的。我仔细瞧瞧，感觉不像啊，我继续追问，真是黑芝麻的？他又很肯定的说是。我交了两块钱，拿上饼子出门，结果咬开根本看不到芝麻，知道掰成两半才发现中间有几颗芝麻粒。我当时真的感觉莫名其妙，以及被欺骗非常不好受。我进去找到那个男的，你这个是黑芝麻馅的？他依然说是，我说你这就这么几颗黑芝麻也敢叫黑芝麻馅，你骗谁呢。他一脸看穷逼的样子，尖酸刻薄：你一共就两块钱，你想买多少芝麻。真是不可理喻，我把吃过的饼子直接扔到他门口的饼堆里面，扭头就走了。结果他追出来，不让我走。我当时心里想着不走就不走，怕你什么，天安门你还想搞事情。但又一想，到时候真的被拦住万一有警察，我和她怎么办，最后女老板也来了，我当时莫名其妙就怂了，后来女老板让我走吧，我说不是故意的。女老板也不想把事情闹大，就让我们走了。</p>\\n<p>在工作期间我记得我们吵过几次架，有一次是因为我第二天要上班，我给她规划了路线，让她一个人去北京西站坐火车回太原。一路上其实还好好的，回去之后我们就开始吵架了。当时报道北京颐和酒店那里有个女孩子莫名其妙被暴打，因为打人者误以为是同行来抢生意的。她当时非常的害怕，嫌我不关心她，想象她要是遇到那种情况又该怎么办呢，我对于这件事情感觉非常莫名其妙，现在治安这么好，为什么会想到这些呢，新闻上的事情就是因为难以遇到才被报道的，真的要是常见哪里还叫新闻啊。现在想想，在这一整年，我对她的关心始终不够，因为自己靠自己的努力和运气走出了一条可以解决温饱，过得开心的路，让自己处于非常膨胀的心态中，感觉什么事情都已经不重要了。</p>\\n<p>后半年我放弃继续美团的工作，想要回来考研，我想圆自己的清华梦，缩小和同龄人之间的差距。想在未来，给家里人，她更好的生活环境。</p>\\n<p>于是在进入新学校之后我就尽可能的沉浸在自己一个人的世界里面，每天拿出大量的时间和书本做斗争，整体学习和生活趋于稳定。而她由于工作出现了问题，需要换工作，每天充满了焦虑，我们开始频繁的陷入争吵。她因为工作不顺利，情绪总是不好。我们开始因为一些莫名其妙，有的我现在甚至已经想不起来的源头吵架，我总是埋怨她对于工作不满而频繁出现的抱怨，埋怨她对于其他朋友的攀比。</p>\\n<p>我们在身边时总是很好的。如果是在身边，我可能会给她一个拥抱，让我们继续鼓起勇气往前走，可是异地网恋，隔着千山万水，我们所有的情感只能通过声音和文字表达。\\n我们便吵架，好多次吵架，吵到最后，觉得对方仿佛就是世界上最恶毒的人，两个人都哭哭啼啼，闹着要分手。但在最后，她总是更早的回到理性，我们又会和好，真的好庆幸有她。在生活上她其实就是我们这个小班子的船长，是我们继续前进的方向。</p>\\n<p>吵架是件不好的事情，但是它确实催生了很多改变。我们为我们的小轮船继续投入燃料，开始将两个人的工作压力和学习压力注意方法的进行释放，更加照顾对方的感受。到几个月前她更换了新工作之后，她开始对工作富有更高的责任心，经常会在下班之后，仍然留在公司加班，比较晚了才回去。</p>\\n<p>她有不少该我学习的地方，她在理财方面也做的非常好。记得她贷款买下苹果手机之后，我一直担心分期那么多，要拖到什么时候才可以换完啊，我们的生活会因为这个过得很辛苦的。但结果是因为她在工资上的规划，在生活上的节俭，才两个多月就还完了。</p>\\n<p>我最喜欢的歌曲里面，唱最长情的莫过于陪伴。我觉得最幸福的事情莫过于两个人互相陪伴。任何时候想到对方，充满笑意和暖心，多么幸福，难怪很多人为了爱情死生挈阔，因为它的确有这样的魔力，让人温暖，充满勇气。年末想起这些，我非常想继续陪伴着她，我们现在越来越少发送争吵了。</p>\\n<p>我感谢她做出的牺牲。她开始减少了和其他朋友间的比较，疏远了一些可有可无的朋友，将更多的时间花在更有意义的事情上。开始想着不断的提高自己的工作技能。\\n什么事情都有个过错，我相信既然有了想法，且开始付诸一点点行动，那么慢慢总会有收获的，不断是斜着上坡还是垂直上坡，都是在向上的。</p>\\n<h2>2017年的展望</h2>\\n<p>站在今天看我们的一切都真的很棒，坎坎坷坷，但都过来了，我们从这一年中更加了解对方，了解对方的家庭成员，更加的情投意合，找到了更好的相处模式。我们越来越勇敢了，在2017我们便要甩开膀子，大干一场，绝不彷徨。让家里人因为我们努力更加幸福自豪，让自己有足够的能力建立一个小家，也希望在更遥远的时候可以为祖国添砖加瓦。</p>\",\"fields\":{\"slug\":\"/2017-01-01---final-summary-2016/\"}}]},\"post\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-10-01---node-file-system/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"Node文件系统 Node 通过封装基本的 POSIX 函数来提供文件系统，使用 require('fs…\",\"frontmatter\":{\"title\":\"Node文件系统\",\"date\":\"2016-10-01\",\"tags\":[\"Node\",\"JS\"]},\"html\":\"<h1>Node文件系统</h1>\\n<p><code>Node</code>通过封装基本的<code>POSIX</code>函数来提供文件系统，使用<code>require('fs')</code>来使用这个模块，所有与文件相关的方法，都提供了异步和同步的形式。 异步的方法通常会将一个可选的回调函数作为最后一个参数，回调函数的第一个参数通常留给意外情况，如果操作是成功的，第一个参数将是<code>null</code>或者<code>undeefined</code>。 使用同步方法，对于任何意外都会即时抛出，可以使用<code>try/catch</code>语句来处理意外情况，或者让错误时间向上冒泡。 下面是一个有关异步方法的基本例子：</p>\\n<pre><code class=\\\"language-js\\\">const fs = require('fs');\\nfs.unlink('/tmp/hello', (err) => {\\n  if (err) throw err;\\n  console.log('sucessfully deleted /tmp/hello');\\n}\\n</code></pre>\\n<p>再跟着一个同步的例子：</p>\\n<pre><code class=\\\"language-js\\\">const fs = require('fs');\\nfs.unlink('/tmp/hello');\\nconsole.log('successfully deleted /tmp/hello');\\n</code></pre>\\n<p>使用异步方法时，需要注意异步方法的执行不一定按照书写顺序，比如下面这种写法很容易出错：</p>\\n<pre><code class=\\\"language-js\\\">fs.rename('/tmp/hello', '/tmp/world', (err) => {\\n   if (err) throw err;\\n   console.log('renamed compelte');\\n});\\nfs.stat('/tmp/world', (err, stats) => {if (err) throw err;\\nconsole.log(`stats: ${JSON.stringify(stats)}`)});\\n</code></pre>\\n<p>在这里，很可能<code>fs.stat</code>函数先于<code>fs.rename</code>，这样会出现一些不必要的错误，正确的方法应该是写在回调函数中:</p>\\n<pre><code class=\\\"language-js\\\">fs.rename('/tmp/hello/', '/tmp/world', (err) ss=> {\\n    if (err) throw err;\\n    fs.stat('/tmp/world'),(err, stats) => {\\n        console.log(`stats: ${JSON.stringfy(stats)});\\n    });\\n});\\n</code></pre>\\n<p>执行复杂耗时的方法，强烈建议使用异步版本，同步方法在它们执行结束之前，会一直锁住当前线程，阻断所有操作。 在<code>fs</code>模块中，可以使用相对路径，但是需要留意参照的路径来自于<code>process.cwd()</code>的返回值。 很多<code>fs</code>函数可以忽略掉回调参数，如果这样进行使用，默认会抛出错误，为了跟踪到函数调用的位置，可以设置<code>NODE_DEBUG</code>环境变量：</p>\\n<pre><code class=\\\"language-bash\\\">$ cat script.js\\nfunction bad() {\\n  require('fs').readFile('/');\\n}\\nbad();\\n$ env NODE_DEBUG=fs node script.js\\nfs.js:66\\n        throw err;\\n              ^\\nError: EISDIR, read\\n    at rethrow (fs.js:61:21)\\n    at maybeCallback (fs.js:79:42)\\n    at Object.fs.readFile (fs.js:153:18)\\n    at bad (/path/to/script.js:2:17)\\n    at Object.&#x3C;anonymous> (/path/to/script.js:5:1)\\n    &#x3C;etc.>\\n</code></pre>\\n<p><code>fs.watch(filename[, options][, listener])</code>监听制定文件或者目录的变化情况，<code>filename</code>参数可以是文件或者目录，这个方法返回一个<code>fs.FSWather</code>对象。 第二个参数是可选的，提供的<code>options</code>参数应该是一个对象，里面要求的成员是<code>persistent</code>和<code>recursive</code>，这个两个成员都是布尔类型的值。 用做监听的回调函数有两个参数，分别是(<code>event</code>, <code>filename</code>)，<code>event</code>的值视情况，返回字符串<code>change</code>，<code>rename</code>，文件名指的是触发事件的这个文件。看下面的这个例子：</p>\\n<pre><code class=\\\"language-js\\\">// node.md\\n// 被监听的文件\\nthis is cat.\\n// app.js\\n// 用来监听文件改变\\n    fs.watch('./node.md', (event, filename) => {\\n        console.log('下面是event参数，event参数的类型，filename');\\n        console.log(typeof event);\\n        console.log(filename);\\n    });\\n// node.md\\n// 这里修改了监听的node.md文件\\nthis is dog.\\n// console\\n// 执行结果\\n下面是event参数，event参数的类型，filename\\nchange\\nstring\\nnode.md\\n// node.md => node1.md\\n// 修改文件的名字\\n// console\\n// 执行结果\\n下面是event参数，event参数的类型，filename\\nrename\\nstring\\nnode1.md\\n</code></pre>\\n<p>注意事项： <code>fs.watch</code>并不是跨所有平台的，在某些常见下不一定可用。 第二个参数中的布尔值<code>recursive</code>只在<code>osx</code>和<code>window</code>下可以使用。</p>\\n<h2>可用性</h2>\\n<ul>\\n<li><code>fs.watch</code>依赖于操作系统底层模块，由操作系统底层模块通知Node文件的变化。</li>\\n<li>如果某个操作系统底层模块对于文件的监听本身就有问题，那么<code>fs.watch</code>是无法发挥作用的，比如监听了一些不可靠的目录和文件，网络文件系统，虚拟机系统中的文件。</li>\\n<li>在<code>Linux</code>，<code>osx</code>系统中，<code>fs.watch</code>解析路径成一个索引节点，并且监听这个节点，但是如果监听的节点被删除或者重新创建，那么此时它就成了一个新节点了，<code>watch</code>将会发送一个<code>delete</code>事件，但是仍然监听原来的节点，原来的事件不会响应新节点的改变，这种处理是符合预期的。</li>\\n<li><code>filename</code>参数只支持在<code>Linux</code>和<code>windows</code>上面指定(<code>osx</code>也可以，但是有些情况可能会有异常)，事实上，即便是在可以使用的平台上，也不建议直接使用这个参数，因为在回调函数内部，建议增加一些逻辑判断，看一下<code>filename</code>是否为<code>null</code>，如下面的例子：</li>\\n</ul>\\n<pre><code class=\\\"language-js\\\">fs.watch('somedir', (event, filename) => {\\n    console.log(`event is: ${event}`);\\n    if (filename) {\\n         console.log(`filename provided: ${filename}`);\\n     } else {\\n         console.log('filename not provided');\\n     }\\n});\\n</code></pre>\",\"fields\":{\"slug\":\"/2016-10-01---node-file-system/\"}}],\"tag\":\"Node\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---tags-node-da6350a4995cb57f8db5.js","module.exports = {\"pathContext\":{\"posts\":{\"Ruby\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/es6-string.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"\",\"fields\":{\"slug\":\"/es6-string/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/git-develop-workflow.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"\",\"fields\":{\"slug\":\"/git-develop-workflow/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/js-logic-operation.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"\",\"fields\":{\"slug\":\"/js-logic-operation/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/mysql-operation.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"\",\"fields\":{\"slug\":\"/mysql-operation/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/numpy-ndarray.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"\",\"fields\":{\"slug\":\"/numpy-ndarray/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/node-module-loader.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"\",\"fields\":{\"slug\":\"/node-module-loader/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/rails-install.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"Rails 安装记录 本文 ubuntu 版本为 14.04stl 64bit ，参考教程： http://rails-practice.com/content/Chapter_1/1.1.html，  需要翻墙 Git ubuntu安装完毕之后，首先安装git…\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"<h1>Rails 安装记录</h1>\\n<blockquote>\\n<p>本文<code>ubuntu</code>版本为<code>14.04stl 64bit</code>，参考教程：<a href=\\\"http://rails-practice.com/content/Chapter_1/1.1.html%EF%BC%8C\\\">http://rails-practice.com/content/Chapter_1/1.1.html，</a> 需要翻墙</p>\\n</blockquote>\\n<h2>Git</h2>\\n<p>ubuntu安装完毕之后，首先安装git，以便之后会用到：</p>\\n<pre><code class=\\\"language-bash\\\">sudo apt-get update\\nsudo apt-get install git-core\\n</code></pre>\\n<p>配置身份信息：</p>\\n<pre><code class=\\\"language-bash\\\">git config --global user.name \\\"xxx\\\"\\ngit config --global user.email \\\"xx@gmail.com\\\"\\n</code></pre>\\n<p>核实信息是否有误：</p>\\n<pre><code class=\\\"language-bash\\\">git config --list\\n</code></pre>\\n<p>此时已经能通过<code>http</code>正常拉去git上的内容，若想进一步配置<code>ssh</code>，可以参考<a href=\\\"https://help.github.com/articles/generating-ssh-keys/1323\\\">https://help.github.com/articles/generating-ssh-keys/1323</a></p>\\n<h2>RVM</h2>\\n<p><code>rails</code>需要先安装<code>Ruby</code>环境，<code>RVM</code>是<code>Ruby</code>管理工具，可以方便的安装、管理、切换多个<code>Ruby</code>，管理<code>Gemset</code>。</p>\\n<pre><code class=\\\"language-bash\\\">curl -sSL https://get.rvm.io | bash -s stable\\n</code></pre>\\n<p>此时会有如下提示：</p>\\n<pre><code class=\\\"language-bash\\\">getcha22@ubuntu:~/Desktop$ curl -sSL https://get.rvm.io | bash -s stable\\nDownloading https://github.com/rvm/rvm/archive/1.26.11.tar.gz\\nDownloading https://github.com/rvm/rvm/releases/download/1.26.11/1.26.11.tar.gz.asc\\ngpg: Signature made Mon 30 Mar 2015 02:52:13 PM PDT using RSA key ID BF04FF17\\ngpg: Can't check signature: public key not found\\nWarning, RVM 1.26.0 introduces signed releases and automated check of signatures when GPG software found.\\nAssuming you trust Michal Papis import the mpapis public key (downloading the signatures).\\nGPG signature verification failed for '/home/getcha22/.rvm/archives/rvm-1.26.11.tgz' - 'https://github.com/rvm/rvm/releases/download/1.26.11/1.26.11.tar.gz.asc'!\\ntry downloading the signatures:\\n    gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3\\nor if it fails:\\n    command curl -sSL https://rvm.io/mpapis.asc | gpg --import -\\nthe key can be compared with:\\n    https://rvm.io/mpapis.asc\\n    https://keybase.io/mpapi\\n</code></pre>\\n<p>按照提示，执行：</p>\\n<pre><code class=\\\"language-bash\\\">gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0\\n</code></pre>\\n<p>依然warring，继续按照提示</p>\\n<pre><code class=\\\"language-bash\\\">sudo curl -sSL https://rvm.io/mpapis.asc | gpg --import -\\n</code></pre>\\n<p>提示Thank you for using RVM!，OK，安装成功</p>\\n<h2>Ruby</h2>\\n<p>重启终端，开始安装<code>Ruby</code>，先使用<code>rvm list known</code>来查看可以按照的<code>Ruby</code>列表，按照参考的教程，我选择使用<code>2.2.0</code></p>\\n<pre><code class=\\\"language-bash\\\">rvm install 2.2.0123\\n</code></pre>\\n<p>在我安装的过程中，由于vpn不算稳定，出现了404的提示，我尝试重新安装，这次安装成功。 通过下面的命令检查当前的版本：</p>\\n<pre><code class=\\\"language-bash\\\">rvm list\\n</code></pre>\\n<p>提示结果：</p>\\n<pre><code class=\\\"language-bash\\\">rvm rubies\\n   ruby-2.2.0 [ x86_64 ]\\n</code></pre>\\n<p>再进一步核实<code>ruby</code>的版本， 此时由于<code>ubuntu</code>存在其他版本的<code>ruby</code>，需要制定默认的<code>ruby</code>版本，此时可以使用:</p>\\n<pre><code class=\\\"language-bash\\\">rvm --default use 2.2.0\\n</code></pre>\\n<p>发现有错误提示<code>RVM is not a function</code>,这个问题是由于<code>ubuntu</code>系统的终端导致 ，为了解决这个问题，需要<code>Run command as login shell</code>，参考这个链接进行解决：<a href=\\\"https://rvm.io/integration/gnome-terminal\\\">https://rvm.io/integration/gnome-terminal</a> ，之后重新制定默认版本，提示OK。</p>\\n<pre><code class=\\\"language-bash\\\">ruby 2.2.0p0 (2014-12-25 revision 49005) [x86_64-linux]\\n</code></pre>\\n<p>到此为止，<code>ruby</code>的安装告一段落，开始进行<code>Rails</code>的安装。</p>\\n<h2>Rails</h2>\\n<p>先设置<code>Gemset</code>。<code>Gemset</code> 是一个独立的 <code>Gem</code> 集合，可以为每个项目设置自己的 <code>Gemset</code>，而不会相互干扰：</p>\\n<pre><code class=\\\"language-bash\\\">rvm gemset create rails4.2\\nrvm use 2.2.0@rails4.2 --default\\ngem install rails -v 4.2.0 --no-ri --no-rdoc\\n</code></pre>\\n<p>出现如下问题:</p>\\n<pre><code class=\\\"language-bash\\\">ERROR:  While executing gem ... (Gem::RemoteFetcher::FetchError)\\n    Errno::ECONNRESET: Connection reset by peer - connect(2) for \\\"rubygems.global.ssl.fastly.net\\\" port 443 (https://api.rubygems.org/quick/Marshal.4.8/rails-4.2.4.gemspec.rz)\\n</code></pre>\\n<p>遇到这个问题，还提示端口是443.可能是<code>gem</code>源导致的网络问题，尝试修改https为http。通过以下命令:</p>\\n<pre><code class=\\\"language-bash\\\">gem sources\\ngem sources -a url //添加\\ngem sources -r url  //删除\\n更新source cache\\ngem sources -u\\n// other :\\ngem sources --add https://ruby.taobao.org/ --remove https://rubygems.org/\\ngem sources -l\\n</code></pre>\\n<p>之后重新进行安装，最后结束安装</p>\\n<pre><code class=\\\"language-bash\\\">Successfully installed rails-4.2.0\\n30 gems installed\\n</code></pre>\\n<h2>其他情况</h2>\\n<ul>\\n<li><code>bundle install</code>如果遇到问题，可以先把<code>gemfile</code>中的<code>source</code>修改成<code>http</code>开头即可，如果在操作时提示需要<code>javascript run time</code>，只要安装<code>Node.js</code>即可</li>\\n</ul>\",\"fields\":{\"slug\":\"/rails-install/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2015-07-10---anaconda-introduction/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"\",\"fields\":{\"slug\":\"/2015-07-10---anaconda-introduction/\"}}],\"Rails\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/es6-string.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"\",\"fields\":{\"slug\":\"/es6-string/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/git-develop-workflow.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"\",\"fields\":{\"slug\":\"/git-develop-workflow/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/js-logic-operation.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"\",\"fields\":{\"slug\":\"/js-logic-operation/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/mysql-operation.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"\",\"fields\":{\"slug\":\"/mysql-operation/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/numpy-ndarray.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"\",\"fields\":{\"slug\":\"/numpy-ndarray/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/node-module-loader.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"\",\"fields\":{\"slug\":\"/node-module-loader/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/rails-install.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"Rails 安装记录 本文 ubuntu 版本为 14.04stl 64bit ，参考教程： http://rails-practice.com/content/Chapter_1/1.1.html，  需要翻墙 Git ubuntu安装完毕之后，首先安装git…\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"<h1>Rails 安装记录</h1>\\n<blockquote>\\n<p>本文<code>ubuntu</code>版本为<code>14.04stl 64bit</code>，参考教程：<a href=\\\"http://rails-practice.com/content/Chapter_1/1.1.html%EF%BC%8C\\\">http://rails-practice.com/content/Chapter_1/1.1.html，</a> 需要翻墙</p>\\n</blockquote>\\n<h2>Git</h2>\\n<p>ubuntu安装完毕之后，首先安装git，以便之后会用到：</p>\\n<pre><code class=\\\"language-bash\\\">sudo apt-get update\\nsudo apt-get install git-core\\n</code></pre>\\n<p>配置身份信息：</p>\\n<pre><code class=\\\"language-bash\\\">git config --global user.name \\\"xxx\\\"\\ngit config --global user.email \\\"xx@gmail.com\\\"\\n</code></pre>\\n<p>核实信息是否有误：</p>\\n<pre><code class=\\\"language-bash\\\">git config --list\\n</code></pre>\\n<p>此时已经能通过<code>http</code>正常拉去git上的内容，若想进一步配置<code>ssh</code>，可以参考<a href=\\\"https://help.github.com/articles/generating-ssh-keys/1323\\\">https://help.github.com/articles/generating-ssh-keys/1323</a></p>\\n<h2>RVM</h2>\\n<p><code>rails</code>需要先安装<code>Ruby</code>环境，<code>RVM</code>是<code>Ruby</code>管理工具，可以方便的安装、管理、切换多个<code>Ruby</code>，管理<code>Gemset</code>。</p>\\n<pre><code class=\\\"language-bash\\\">curl -sSL https://get.rvm.io | bash -s stable\\n</code></pre>\\n<p>此时会有如下提示：</p>\\n<pre><code class=\\\"language-bash\\\">getcha22@ubuntu:~/Desktop$ curl -sSL https://get.rvm.io | bash -s stable\\nDownloading https://github.com/rvm/rvm/archive/1.26.11.tar.gz\\nDownloading https://github.com/rvm/rvm/releases/download/1.26.11/1.26.11.tar.gz.asc\\ngpg: Signature made Mon 30 Mar 2015 02:52:13 PM PDT using RSA key ID BF04FF17\\ngpg: Can't check signature: public key not found\\nWarning, RVM 1.26.0 introduces signed releases and automated check of signatures when GPG software found.\\nAssuming you trust Michal Papis import the mpapis public key (downloading the signatures).\\nGPG signature verification failed for '/home/getcha22/.rvm/archives/rvm-1.26.11.tgz' - 'https://github.com/rvm/rvm/releases/download/1.26.11/1.26.11.tar.gz.asc'!\\ntry downloading the signatures:\\n    gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3\\nor if it fails:\\n    command curl -sSL https://rvm.io/mpapis.asc | gpg --import -\\nthe key can be compared with:\\n    https://rvm.io/mpapis.asc\\n    https://keybase.io/mpapi\\n</code></pre>\\n<p>按照提示，执行：</p>\\n<pre><code class=\\\"language-bash\\\">gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0\\n</code></pre>\\n<p>依然warring，继续按照提示</p>\\n<pre><code class=\\\"language-bash\\\">sudo curl -sSL https://rvm.io/mpapis.asc | gpg --import -\\n</code></pre>\\n<p>提示Thank you for using RVM!，OK，安装成功</p>\\n<h2>Ruby</h2>\\n<p>重启终端，开始安装<code>Ruby</code>，先使用<code>rvm list known</code>来查看可以按照的<code>Ruby</code>列表，按照参考的教程，我选择使用<code>2.2.0</code></p>\\n<pre><code class=\\\"language-bash\\\">rvm install 2.2.0123\\n</code></pre>\\n<p>在我安装的过程中，由于vpn不算稳定，出现了404的提示，我尝试重新安装，这次安装成功。 通过下面的命令检查当前的版本：</p>\\n<pre><code class=\\\"language-bash\\\">rvm list\\n</code></pre>\\n<p>提示结果：</p>\\n<pre><code class=\\\"language-bash\\\">rvm rubies\\n   ruby-2.2.0 [ x86_64 ]\\n</code></pre>\\n<p>再进一步核实<code>ruby</code>的版本， 此时由于<code>ubuntu</code>存在其他版本的<code>ruby</code>，需要制定默认的<code>ruby</code>版本，此时可以使用:</p>\\n<pre><code class=\\\"language-bash\\\">rvm --default use 2.2.0\\n</code></pre>\\n<p>发现有错误提示<code>RVM is not a function</code>,这个问题是由于<code>ubuntu</code>系统的终端导致 ，为了解决这个问题，需要<code>Run command as login shell</code>，参考这个链接进行解决：<a href=\\\"https://rvm.io/integration/gnome-terminal\\\">https://rvm.io/integration/gnome-terminal</a> ，之后重新制定默认版本，提示OK。</p>\\n<pre><code class=\\\"language-bash\\\">ruby 2.2.0p0 (2014-12-25 revision 49005) [x86_64-linux]\\n</code></pre>\\n<p>到此为止，<code>ruby</code>的安装告一段落，开始进行<code>Rails</code>的安装。</p>\\n<h2>Rails</h2>\\n<p>先设置<code>Gemset</code>。<code>Gemset</code> 是一个独立的 <code>Gem</code> 集合，可以为每个项目设置自己的 <code>Gemset</code>，而不会相互干扰：</p>\\n<pre><code class=\\\"language-bash\\\">rvm gemset create rails4.2\\nrvm use 2.2.0@rails4.2 --default\\ngem install rails -v 4.2.0 --no-ri --no-rdoc\\n</code></pre>\\n<p>出现如下问题:</p>\\n<pre><code class=\\\"language-bash\\\">ERROR:  While executing gem ... (Gem::RemoteFetcher::FetchError)\\n    Errno::ECONNRESET: Connection reset by peer - connect(2) for \\\"rubygems.global.ssl.fastly.net\\\" port 443 (https://api.rubygems.org/quick/Marshal.4.8/rails-4.2.4.gemspec.rz)\\n</code></pre>\\n<p>遇到这个问题，还提示端口是443.可能是<code>gem</code>源导致的网络问题，尝试修改https为http。通过以下命令:</p>\\n<pre><code class=\\\"language-bash\\\">gem sources\\ngem sources -a url //添加\\ngem sources -r url  //删除\\n更新source cache\\ngem sources -u\\n// other :\\ngem sources --add https://ruby.taobao.org/ --remove https://rubygems.org/\\ngem sources -l\\n</code></pre>\\n<p>之后重新进行安装，最后结束安装</p>\\n<pre><code class=\\\"language-bash\\\">Successfully installed rails-4.2.0\\n30 gems installed\\n</code></pre>\\n<h2>其他情况</h2>\\n<ul>\\n<li><code>bundle install</code>如果遇到问题，可以先把<code>gemfile</code>中的<code>source</code>修改成<code>http</code>开头即可，如果在操作时提示需要<code>javascript run time</code>，只要安装<code>Node.js</code>即可</li>\\n</ul>\",\"fields\":{\"slug\":\"/rails-install/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2015-07-10---anaconda-introduction/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"\",\"fields\":{\"slug\":\"/2015-07-10---anaconda-introduction/\"}}],\"installtion-record\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/es6-string.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"\",\"fields\":{\"slug\":\"/es6-string/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/git-develop-workflow.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"\",\"fields\":{\"slug\":\"/git-develop-workflow/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/js-logic-operation.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"\",\"fields\":{\"slug\":\"/js-logic-operation/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/mysql-operation.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"\",\"fields\":{\"slug\":\"/mysql-operation/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/numpy-ndarray.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"\",\"fields\":{\"slug\":\"/numpy-ndarray/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/node-module-loader.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"\",\"fields\":{\"slug\":\"/node-module-loader/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/rails-install.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"Rails 安装记录 本文 ubuntu 版本为 14.04stl 64bit ，参考教程： http://rails-practice.com/content/Chapter_1/1.1.html，  需要翻墙 Git ubuntu安装完毕之后，首先安装git…\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"<h1>Rails 安装记录</h1>\\n<blockquote>\\n<p>本文<code>ubuntu</code>版本为<code>14.04stl 64bit</code>，参考教程：<a href=\\\"http://rails-practice.com/content/Chapter_1/1.1.html%EF%BC%8C\\\">http://rails-practice.com/content/Chapter_1/1.1.html，</a> 需要翻墙</p>\\n</blockquote>\\n<h2>Git</h2>\\n<p>ubuntu安装完毕之后，首先安装git，以便之后会用到：</p>\\n<pre><code class=\\\"language-bash\\\">sudo apt-get update\\nsudo apt-get install git-core\\n</code></pre>\\n<p>配置身份信息：</p>\\n<pre><code class=\\\"language-bash\\\">git config --global user.name \\\"xxx\\\"\\ngit config --global user.email \\\"xx@gmail.com\\\"\\n</code></pre>\\n<p>核实信息是否有误：</p>\\n<pre><code class=\\\"language-bash\\\">git config --list\\n</code></pre>\\n<p>此时已经能通过<code>http</code>正常拉去git上的内容，若想进一步配置<code>ssh</code>，可以参考<a href=\\\"https://help.github.com/articles/generating-ssh-keys/1323\\\">https://help.github.com/articles/generating-ssh-keys/1323</a></p>\\n<h2>RVM</h2>\\n<p><code>rails</code>需要先安装<code>Ruby</code>环境，<code>RVM</code>是<code>Ruby</code>管理工具，可以方便的安装、管理、切换多个<code>Ruby</code>，管理<code>Gemset</code>。</p>\\n<pre><code class=\\\"language-bash\\\">curl -sSL https://get.rvm.io | bash -s stable\\n</code></pre>\\n<p>此时会有如下提示：</p>\\n<pre><code class=\\\"language-bash\\\">getcha22@ubuntu:~/Desktop$ curl -sSL https://get.rvm.io | bash -s stable\\nDownloading https://github.com/rvm/rvm/archive/1.26.11.tar.gz\\nDownloading https://github.com/rvm/rvm/releases/download/1.26.11/1.26.11.tar.gz.asc\\ngpg: Signature made Mon 30 Mar 2015 02:52:13 PM PDT using RSA key ID BF04FF17\\ngpg: Can't check signature: public key not found\\nWarning, RVM 1.26.0 introduces signed releases and automated check of signatures when GPG software found.\\nAssuming you trust Michal Papis import the mpapis public key (downloading the signatures).\\nGPG signature verification failed for '/home/getcha22/.rvm/archives/rvm-1.26.11.tgz' - 'https://github.com/rvm/rvm/releases/download/1.26.11/1.26.11.tar.gz.asc'!\\ntry downloading the signatures:\\n    gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3\\nor if it fails:\\n    command curl -sSL https://rvm.io/mpapis.asc | gpg --import -\\nthe key can be compared with:\\n    https://rvm.io/mpapis.asc\\n    https://keybase.io/mpapi\\n</code></pre>\\n<p>按照提示，执行：</p>\\n<pre><code class=\\\"language-bash\\\">gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0\\n</code></pre>\\n<p>依然warring，继续按照提示</p>\\n<pre><code class=\\\"language-bash\\\">sudo curl -sSL https://rvm.io/mpapis.asc | gpg --import -\\n</code></pre>\\n<p>提示Thank you for using RVM!，OK，安装成功</p>\\n<h2>Ruby</h2>\\n<p>重启终端，开始安装<code>Ruby</code>，先使用<code>rvm list known</code>来查看可以按照的<code>Ruby</code>列表，按照参考的教程，我选择使用<code>2.2.0</code></p>\\n<pre><code class=\\\"language-bash\\\">rvm install 2.2.0123\\n</code></pre>\\n<p>在我安装的过程中，由于vpn不算稳定，出现了404的提示，我尝试重新安装，这次安装成功。 通过下面的命令检查当前的版本：</p>\\n<pre><code class=\\\"language-bash\\\">rvm list\\n</code></pre>\\n<p>提示结果：</p>\\n<pre><code class=\\\"language-bash\\\">rvm rubies\\n   ruby-2.2.0 [ x86_64 ]\\n</code></pre>\\n<p>再进一步核实<code>ruby</code>的版本， 此时由于<code>ubuntu</code>存在其他版本的<code>ruby</code>，需要制定默认的<code>ruby</code>版本，此时可以使用:</p>\\n<pre><code class=\\\"language-bash\\\">rvm --default use 2.2.0\\n</code></pre>\\n<p>发现有错误提示<code>RVM is not a function</code>,这个问题是由于<code>ubuntu</code>系统的终端导致 ，为了解决这个问题，需要<code>Run command as login shell</code>，参考这个链接进行解决：<a href=\\\"https://rvm.io/integration/gnome-terminal\\\">https://rvm.io/integration/gnome-terminal</a> ，之后重新制定默认版本，提示OK。</p>\\n<pre><code class=\\\"language-bash\\\">ruby 2.2.0p0 (2014-12-25 revision 49005) [x86_64-linux]\\n</code></pre>\\n<p>到此为止，<code>ruby</code>的安装告一段落，开始进行<code>Rails</code>的安装。</p>\\n<h2>Rails</h2>\\n<p>先设置<code>Gemset</code>。<code>Gemset</code> 是一个独立的 <code>Gem</code> 集合，可以为每个项目设置自己的 <code>Gemset</code>，而不会相互干扰：</p>\\n<pre><code class=\\\"language-bash\\\">rvm gemset create rails4.2\\nrvm use 2.2.0@rails4.2 --default\\ngem install rails -v 4.2.0 --no-ri --no-rdoc\\n</code></pre>\\n<p>出现如下问题:</p>\\n<pre><code class=\\\"language-bash\\\">ERROR:  While executing gem ... (Gem::RemoteFetcher::FetchError)\\n    Errno::ECONNRESET: Connection reset by peer - connect(2) for \\\"rubygems.global.ssl.fastly.net\\\" port 443 (https://api.rubygems.org/quick/Marshal.4.8/rails-4.2.4.gemspec.rz)\\n</code></pre>\\n<p>遇到这个问题，还提示端口是443.可能是<code>gem</code>源导致的网络问题，尝试修改https为http。通过以下命令:</p>\\n<pre><code class=\\\"language-bash\\\">gem sources\\ngem sources -a url //添加\\ngem sources -r url  //删除\\n更新source cache\\ngem sources -u\\n// other :\\ngem sources --add https://ruby.taobao.org/ --remove https://rubygems.org/\\ngem sources -l\\n</code></pre>\\n<p>之后重新进行安装，最后结束安装</p>\\n<pre><code class=\\\"language-bash\\\">Successfully installed rails-4.2.0\\n30 gems installed\\n</code></pre>\\n<h2>其他情况</h2>\\n<ul>\\n<li><code>bundle install</code>如果遇到问题，可以先把<code>gemfile</code>中的<code>source</code>修改成<code>http</code>开头即可，如果在操作时提示需要<code>javascript run time</code>，只要安装<code>Node.js</code>即可</li>\\n</ul>\",\"fields\":{\"slug\":\"/rails-install/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2015-07-10---anaconda-introduction/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"]},\"html\":\"\",\"fields\":{\"slug\":\"/2015-07-10---anaconda-introduction/\"}}],\"os\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/os-1.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"操作系统（一） 按下电源之后，如何加载操作系统？ 操作系统如何与外设、应用程序交互？ BIOS、BootLoader、OS的关系 BIOS即基本输入输出系统，存在CMOS中，OS即操作系统，操作系统存在硬盘中。硬盘中还存另一个简单的小程序BootLoader，它可以将OS…\",\"frontmatter\":{\"title\":\"操作系统（一）\",\"date\":\"2018-01-10\",\"tags\":[\"os\",\"Bootloader\"]},\"html\":\"<h1>操作系统（一）</h1>\\n<ol>\\n<li>按下电源之后，如何加载操作系统？</li>\\n<li>操作系统如何与外设、应用程序交互？</li>\\n</ol>\\n<h2>BIOS、BootLoader、OS的关系</h2>\\n<p>BIOS即基本输入输出系统，存在CMOS中，OS即操作系统，操作系统存在硬盘中。硬盘中还存另一个简单的小程序BootLoader，它可以将OS从硬盘放到内存中去，使cpu可以执行OS相关的代码。</p>\\n<ol>\\n<li>一开始加电，CPU从一个预先约定的地址处开始执行BIOS程序，进行加电自检（显卡，键鼠，硬盘），检查成功，即外设均可正常工作，接着要将BootLoader程序放到内存中去。</li>\\n<li>BootLoader放在硬盘内的某个指定位置，BIOS从这位置开始，连续读取其后的512B的代码和数据，放入内存之中，CPU按照BootLoader的代码开始执行。</li>\\n<li>此时CPU的控制权由BootLoader掌控，该程序会找到硬盘中OS程序的起始扇区和长度，将这块区域从硬盘中读到内存中去，CPU调到OS的起始代码处开始。</li>\\n</ol>\\n<h2>操作系统如何与设备和程序交互</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>对象</th>\\n<th>交互方式</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>面向外设</td>\\n<td>中断、I/O</td>\\n</tr>\\n<tr>\\n<td>面向程序</td>\\n<td>系统调用、异常</td>\\n</tr>\\n</tbody>\\n</table>\\n<h3>基本概念</h3>\\n<ul>\\n<li>系统调用：系统的资源由操作系统统一掌控，应用程序需要这些资源时，要向系统主动提出服务请求，之后由操作系统来完成相应的功能。</li>\\n<li>异常：同样由应用程序产生的，但是并非主动产生，而是在执行过程中，出现了意想不到的事情，必须由操作系统解救。</li>\\n<li>中断：来源于外设，当外设执行完上一轮CPU分配的任务后，请求下一轮的任务，通过中断机制，使操作系统能感知外设发出的请求。</li>\\n</ul>\\n<h3>为什么应用程序不能直接找外设？</h3>\\n<ul>\\n<li>安全：操作系统是特殊的软件，是可信程序，而应用程序则不是。</li>\\n<li>抽象：操作系统为应用提供简单一致的接口，不需要针对不同的外设开发不同的软件，屏蔽底层设备的差异性，提供统一的接口。</li>\\n</ul>\\n<h3>区别联系</h3>\\n<table>\\n<thead>\\n<tr>\\n<th align=\\\"left\\\">源头</th>\\n<th></th>\\n<th align=\\\"left\\\">处理时间</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td align=\\\"left\\\">中  断</td>\\n<td>非CPU执行指令时产生的，由设备产生，例如设备上一轮的I/O处理完成了，希望再为分配下一轮的任务</td>\\n<td align=\\\"left\\\">异步,即不知道外设什么时候发出中断，什么时候返回给外设下一轮任务也未知</td>\\n</tr>\\n<tr>\\n<td align=\\\"left\\\">异  常</td>\\n<td>CPU执行应用程序的指令时产生，被动产生的，举例：越界访问，非法操作码等</td>\\n<td align=\\\"left\\\">同步，即执行到特定的指令一定会发生，且要立即处理</td>\\n</tr>\\n<tr>\\n<td align=\\\"left\\\">系统调用</td>\\n<td>CPU执行应用程序的指令时产生，主动产生的，举例：对文件的增删改查</td>\\n<td align=\\\"left\\\">同步和异步，即执行到特定的指令，应用程序发出调用，比如网络请求这是同步的，但之后可以继续执行其余指令，不必一直等待</td>\\n</tr>\\n</tbody>\\n</table>\\n<h3>处理过程</h3>\\n<h4>中断处理过程</h4>\\n<ol>\\n<li>外设完成任务，在某个寄存器或者某个特定的位置设置一个中断标记。</li>\\n<li>CPU在下一个时间片开始之前会先检测这个位置，CPU发现标记后便可判断为哪种中断，得出中断号，根据中断表查出这类中断对应的处理程序地址。</li>\\n<li>带着参数执行这个地址处的程序。</li>\\n<li>操作系统在跳转前还需要保存被打断程序的现场状态，以便后续恢复后能继续运行，在执行完后同样要继续恢复。</li>\\n</ol>\\n<p><strong>特点</strong>：对于正在执行的应用程序来说是透明的，应用程序无感知</p>\\n<h4>异常处理过程</h4>\\n<ol>\\n<li>CPU正在执行应用程序代码时，发现了非法指令，CPU无法继续执行了，产生一个异常ID（硬件实现：改变某个寄存器的值），转而执行操作系统的代码。</li>\\n<li>操作系统通过异常ID确定异常号，保存好当前上下文，再确定异常处理程序的地址。</li>\\n<li>异常处理判断直接杀死当前程序，还是为其分配必要的资源后重新执行一次（这种情况下对应用程序是透明的，好像不曾产生异常）。</li>\\n</ol>\\n<h4>系统调用过程</h4>\\n<p>应用程序无法直接完成某项任务，需要操作系统作为中介提供服务。</p>\\n<blockquote>\\n<p>windows系统提供了Win32 API，应用程序可以为这些接口提供参数来申请系统调用。\\nPOSIX-based systems系统（Linux，MacOS等系统）提供了POSIX API，可以实现应用程序的系统调用。\\n人们都知道JAVA虚拟机会提供JAVA API，通过JAVA API实现的是库函数的调用，再通过JAVA虚拟机来代为实现系统调用，其实是多了一层封装的，但也就是因为多了一层JAVA虚拟机，所以JAVA程序有非常好的跨平台性，JAVA虚拟机实现了对不同操作系统差异的屏蔽。不过这并没有什么了不起的，现在大部分编程语言都是跨平台的，社区或者公司都提供了不同平台的解释或者编译程序，也可以一次编写到处运行。\\n应用程序编写时，只要掌握对应OS提供的API与API具有的功能即可。</p>\\n</blockquote>\\n<p>应用程序直接或者间接（通过库函数）访问OS系统提供的API，会触发了CPU从用户态到内核态的切换。\\n用户态就是CPU执行应用程序的状态，仅能执行有限指令，不能直接操纵外设，无法完全控制整个计算机。\\n内核态指CPU执行OS程序的状态，可以执行特权和访问I/O的指令，可以完全控制整个计算机。\\n完成转换后就将控制权交到了操作系统，操作系统可以对系统调用做标识，识别，完成服务。</p>\\n<h4>函数调用与系统调用的区别</h4>\\n<p>函数调用其实是在一个栈空间完成了参数的传递和返回。而系统调用时，应用程序和内核程序有各自的堆栈，发出系统调用，要切换执行内核程序，就要先切换堆栈，同时转换特权集（用户态到内核态），切换堆栈和转换是有开销的，还包括系统调用的参数检查，两个堆栈之间的拷贝（堆栈的切换不能仅仅通过修改指针）。总体而言开销大很多，但换来的回报是安全。</p>\",\"fields\":{\"slug\":\"/os-1/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/os-2.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"操作系统（二） 操作系统如何管理物理主存？ 计算机体系结构、主存结构分层 CPU芯片内部有寄存器和Cache…\",\"frontmatter\":{\"title\":\"操作系统（二）\",\"date\":\"2018-01-12\",\"tags\":[\"os\",\"memory\"]},\"html\":\"<h1>操作系统（二）</h1>\\n<ol>\\n<li>操作系统如何管理物理主存？</li>\\n</ol>\\n<h2>计算机体系结构、主存结构分层</h2>\\n<ol>\\n<li>CPU芯片内部有寄存器和Cache，操作系统无法直接访问管理，这一层次的主存容量小但是数据很快。</li>\\n<li>在主存结构中有一块很大的区域，即主存或者物理主存。这块区域可以用来放置操作系统本身代码以及其他要运行的程序，主存容量大，速度慢。</li>\\n<li>计算机中可以在主存中存放着多个可运行的程序，若CPU的运行速度很快，且这些可运行的程序都需要很大的主存，那么CPU运行完主存中可运行的程序（假想当前主存中的可运行的所有程序都需要接收到网络响应后才能恢复运行），那么CPU就闲置下来了。为了避免CPU浪费，操作系统就需要发挥作用，将临时用不到的程序和数据放到硬盘中。</li>\\n<li>主存在计算机掉电之后其内的数据就丢失了，在主存结构的底层，就是硬盘，它用来保存数据。</li>\\n</ol>\\n<p><strong>特点</strong>：上述主存结构分层，从上到下速度依次降低，存储容量依次增大。数据访问很快，数据的存储空间很大。有了操作系统的帮助，操作系统如何管理物理主存，如何完成这个任务？</p>\\n<h2>操作系统为配合应用程序需要完成的任务</h2>\\n<p>为了配合程序，操作系统需要完成以下任务：</p>\\n<ul>\\n<li>抽象：我们希望应用程序在主存中运行时，不需要考虑物理主存和外设在什么地方，只需要访问一个连续的地址空间（逻辑地址空间）即可。</li>\\n<li>保护：在主存中可以运行多个不同的应用程序，某个程序可能会访问别的程序的地址空间，这时就需要一种机制来隔离和保护被访问程序的地址空间。</li>\\n<li>共享：除了隔离外，程序之间如何交互、共享各自的数据。</li>\\n<li>虚拟化：当需要在主存中运行的应用程序很多时，会出现主存不够用的情况。我们将暂时不用的数据临时放入硬盘，用的时候再拿出来，整个过程要对应用程序透明，这也是操作系统的任务。</li>\\n</ul>\\n<p><strong>注</strong>：上面提到了两个地址空间，主存和硬盘是物理地址空间，而应用程序在操作系统的作用下看到的是逻辑地址空间。</p>\\n<h2>地址空间与地址生成</h2>\\n<h3>地址空间定义</h3>\\n<p>地址空间分为物理地址空间和逻辑地址空间。</p>\\n<ul>\\n<li>物理地址空间：与硬件直接对应，主存条代表的主存和硬盘代表的另一种存储空间，物理地址空间的管理由硬件来完成。</li>\\n<li>逻辑地址空间：是运行程序所见到的一维线性的地址空间，应用程序非常容易控制和访问逻辑地址空间。</li>\\n<li>两者对应关系：某条程序指令指向某个一维逻辑地址，这个逻辑地址可能是该程序堆栈的某个位置，但最终这个位置可能是主存中甚至是硬盘中，操作系统完成了两者的映射关系。</li>\\n</ul>\\n<h3>逻辑地址生成</h3>\\n<ol>\\n<li>C程序通过编译变为汇编程序，在C程序中，函数的位置和变量的名字就是地址，只不过以一种更容易人理解的方式存在。</li>\\n<li>汇编程序更贴近机器语言，但是函数和变量仍然通过符号表示，相比机器语言，汇编语言更易让人阅读。</li>\\n<li>将汇编程序汇编成机器语言，即.o程序，.o程序的起始地址从0开始，此时变量和函数已经被转成了特定的地址。</li>\\n<li>一个大程序会由多个小程序组成，小程序之间往往具有复杂的依赖关系，通过链接可以将多个.o小程序最终变成一个单一的可执行程序.exe，.exe程序已经可以在主存中执行的，但是目前还放在硬盘中。</li>\\n<li>多个点.o程序中地址已经在.exe程序中有了相应的映射，但这个定义并非主存中的位置，再通过载入程序，将.exe程序放入到主存中执行，这一步为.exe程序分配在主存中的逻辑地址，使得应用程序在主存中正常的跑，.exe程序的地址做了相应的偏远，通过这个偏移量，程序就会依照这个偏移量进行执行。</li>\\n</ol>\\n<p><strong>特点</strong>：从函数和变量到最终可以在主存中执行的逻辑地址，通过了很多步骤，但这些步骤基本都不需要操作系统做任何的帮助，最终放入内存后，应用程序看到的地址仍然不是物理地址。</p>\\n<p><strong>题目</strong>\\n在内存管理中，地址变换机构将逻辑地址变为物理地址，形成该逻辑地址的阶段是编辑、编译、链接还是装载？\\n答：链接。在编译、汇编后，一个程序可能形成了多个.o文件，这是已经具有了逻辑地址，但只是相对于该模块的逻辑地址，并不能直接用于后续的地址变换。多个.h文件再经过链接，组合为.exe文件，便形成了相对于整个程序的逻辑地址。这个地址可用于后续的地址变换。</p>\\n<h3><del>逻辑地址如何对应物理地址（需要组成原理的内容做铺垫）</del></h3>\\n<p>指令放在物理内存的什么地方，指令的逻辑地址在什么地方，CPU有MMU，它有一块区域存着映射关系，查表可以完成具体的物理地址，硬件就可以从相应的物理地址中取出。</p>\\n<p>操作系统先生成一个逻辑地址和物理地址的映射关系，将该映射关系存在内存中，CPU可以在MMU中缓存这个映射关系。（<strong>如何完成预先生成，后续谈</strong>）</p>\\n<ol>\\n<li>CPU执行某条指令，ALU需要得到该指令逻辑地址上的内容，ALU首先将该逻辑地址作为参数，向存储管理单元MMU发出查物理地址的请求。</li>\\n<li>CPU的MMU查找对应的映射表，判断是否有对应的物理地址。</li>\\n<li>若没有这个物理地址，就到内存中的映射表上找</li>\\n<li>找到后CPU的控制器向主存发出请求，需要某个物理地址的内容，主存将内存的内容通过总线传给CPU，CPU拿到内容就可以进行执行了</li>\\n</ol>\\n<h2>如何确保内存中的程序不相互干扰</h2>\\n<p>操作系统首先确认每个程序可以访问的地址空间，第一部分是起始地址，第二个部分是该程序可访问的区域。这张表由操作系统建立和维护，CPU在执行某条指令时，CPU要查表确定是否合法，合法之后才根据地址取指令。</p>\",\"fields\":{\"slug\":\"/os-2/\"}}],\"Bootloader\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/os-1.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"操作系统（一） 按下电源之后，如何加载操作系统？ 操作系统如何与外设、应用程序交互？ BIOS、BootLoader、OS的关系 BIOS即基本输入输出系统，存在CMOS中，OS即操作系统，操作系统存在硬盘中。硬盘中还存另一个简单的小程序BootLoader，它可以将OS…\",\"frontmatter\":{\"title\":\"操作系统（一）\",\"date\":\"2018-01-10\",\"tags\":[\"os\",\"Bootloader\"]},\"html\":\"<h1>操作系统（一）</h1>\\n<ol>\\n<li>按下电源之后，如何加载操作系统？</li>\\n<li>操作系统如何与外设、应用程序交互？</li>\\n</ol>\\n<h2>BIOS、BootLoader、OS的关系</h2>\\n<p>BIOS即基本输入输出系统，存在CMOS中，OS即操作系统，操作系统存在硬盘中。硬盘中还存另一个简单的小程序BootLoader，它可以将OS从硬盘放到内存中去，使cpu可以执行OS相关的代码。</p>\\n<ol>\\n<li>一开始加电，CPU从一个预先约定的地址处开始执行BIOS程序，进行加电自检（显卡，键鼠，硬盘），检查成功，即外设均可正常工作，接着要将BootLoader程序放到内存中去。</li>\\n<li>BootLoader放在硬盘内的某个指定位置，BIOS从这位置开始，连续读取其后的512B的代码和数据，放入内存之中，CPU按照BootLoader的代码开始执行。</li>\\n<li>此时CPU的控制权由BootLoader掌控，该程序会找到硬盘中OS程序的起始扇区和长度，将这块区域从硬盘中读到内存中去，CPU调到OS的起始代码处开始。</li>\\n</ol>\\n<h2>操作系统如何与设备和程序交互</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>对象</th>\\n<th>交互方式</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>面向外设</td>\\n<td>中断、I/O</td>\\n</tr>\\n<tr>\\n<td>面向程序</td>\\n<td>系统调用、异常</td>\\n</tr>\\n</tbody>\\n</table>\\n<h3>基本概念</h3>\\n<ul>\\n<li>系统调用：系统的资源由操作系统统一掌控，应用程序需要这些资源时，要向系统主动提出服务请求，之后由操作系统来完成相应的功能。</li>\\n<li>异常：同样由应用程序产生的，但是并非主动产生，而是在执行过程中，出现了意想不到的事情，必须由操作系统解救。</li>\\n<li>中断：来源于外设，当外设执行完上一轮CPU分配的任务后，请求下一轮的任务，通过中断机制，使操作系统能感知外设发出的请求。</li>\\n</ul>\\n<h3>为什么应用程序不能直接找外设？</h3>\\n<ul>\\n<li>安全：操作系统是特殊的软件，是可信程序，而应用程序则不是。</li>\\n<li>抽象：操作系统为应用提供简单一致的接口，不需要针对不同的外设开发不同的软件，屏蔽底层设备的差异性，提供统一的接口。</li>\\n</ul>\\n<h3>区别联系</h3>\\n<table>\\n<thead>\\n<tr>\\n<th align=\\\"left\\\">源头</th>\\n<th></th>\\n<th align=\\\"left\\\">处理时间</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td align=\\\"left\\\">中  断</td>\\n<td>非CPU执行指令时产生的，由设备产生，例如设备上一轮的I/O处理完成了，希望再为分配下一轮的任务</td>\\n<td align=\\\"left\\\">异步,即不知道外设什么时候发出中断，什么时候返回给外设下一轮任务也未知</td>\\n</tr>\\n<tr>\\n<td align=\\\"left\\\">异  常</td>\\n<td>CPU执行应用程序的指令时产生，被动产生的，举例：越界访问，非法操作码等</td>\\n<td align=\\\"left\\\">同步，即执行到特定的指令一定会发生，且要立即处理</td>\\n</tr>\\n<tr>\\n<td align=\\\"left\\\">系统调用</td>\\n<td>CPU执行应用程序的指令时产生，主动产生的，举例：对文件的增删改查</td>\\n<td align=\\\"left\\\">同步和异步，即执行到特定的指令，应用程序发出调用，比如网络请求这是同步的，但之后可以继续执行其余指令，不必一直等待</td>\\n</tr>\\n</tbody>\\n</table>\\n<h3>处理过程</h3>\\n<h4>中断处理过程</h4>\\n<ol>\\n<li>外设完成任务，在某个寄存器或者某个特定的位置设置一个中断标记。</li>\\n<li>CPU在下一个时间片开始之前会先检测这个位置，CPU发现标记后便可判断为哪种中断，得出中断号，根据中断表查出这类中断对应的处理程序地址。</li>\\n<li>带着参数执行这个地址处的程序。</li>\\n<li>操作系统在跳转前还需要保存被打断程序的现场状态，以便后续恢复后能继续运行，在执行完后同样要继续恢复。</li>\\n</ol>\\n<p><strong>特点</strong>：对于正在执行的应用程序来说是透明的，应用程序无感知</p>\\n<h4>异常处理过程</h4>\\n<ol>\\n<li>CPU正在执行应用程序代码时，发现了非法指令，CPU无法继续执行了，产生一个异常ID（硬件实现：改变某个寄存器的值），转而执行操作系统的代码。</li>\\n<li>操作系统通过异常ID确定异常号，保存好当前上下文，再确定异常处理程序的地址。</li>\\n<li>异常处理判断直接杀死当前程序，还是为其分配必要的资源后重新执行一次（这种情况下对应用程序是透明的，好像不曾产生异常）。</li>\\n</ol>\\n<h4>系统调用过程</h4>\\n<p>应用程序无法直接完成某项任务，需要操作系统作为中介提供服务。</p>\\n<blockquote>\\n<p>windows系统提供了Win32 API，应用程序可以为这些接口提供参数来申请系统调用。\\nPOSIX-based systems系统（Linux，MacOS等系统）提供了POSIX API，可以实现应用程序的系统调用。\\n人们都知道JAVA虚拟机会提供JAVA API，通过JAVA API实现的是库函数的调用，再通过JAVA虚拟机来代为实现系统调用，其实是多了一层封装的，但也就是因为多了一层JAVA虚拟机，所以JAVA程序有非常好的跨平台性，JAVA虚拟机实现了对不同操作系统差异的屏蔽。不过这并没有什么了不起的，现在大部分编程语言都是跨平台的，社区或者公司都提供了不同平台的解释或者编译程序，也可以一次编写到处运行。\\n应用程序编写时，只要掌握对应OS提供的API与API具有的功能即可。</p>\\n</blockquote>\\n<p>应用程序直接或者间接（通过库函数）访问OS系统提供的API，会触发了CPU从用户态到内核态的切换。\\n用户态就是CPU执行应用程序的状态，仅能执行有限指令，不能直接操纵外设，无法完全控制整个计算机。\\n内核态指CPU执行OS程序的状态，可以执行特权和访问I/O的指令，可以完全控制整个计算机。\\n完成转换后就将控制权交到了操作系统，操作系统可以对系统调用做标识，识别，完成服务。</p>\\n<h4>函数调用与系统调用的区别</h4>\\n<p>函数调用其实是在一个栈空间完成了参数的传递和返回。而系统调用时，应用程序和内核程序有各自的堆栈，发出系统调用，要切换执行内核程序，就要先切换堆栈，同时转换特权集（用户态到内核态），切换堆栈和转换是有开销的，还包括系统调用的参数检查，两个堆栈之间的拷贝（堆栈的切换不能仅仅通过修改指针）。总体而言开销大很多，但换来的回报是安全。</p>\",\"fields\":{\"slug\":\"/os-1/\"}}],\"opensauce\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/opensauce.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"opensauce单元测试 为开源项目提供免费的云测试\\n https://saucelabs.com/opensauce/ 推荐文章 https://philipwalton.com/articles/learning-how-to-set-up-automated-cross…\",\"frontmatter\":{\"title\":\"opensauce单元测试\",\"date\":\"2016-05-03\",\"tags\":[\"opensauce\",\"unit testing\"]},\"html\":\"<h1>opensauce单元测试</h1>\\n<p>为开源项目提供免费的云测试\\n<a href=\\\"https://saucelabs.com/opensauce/\\\">https://saucelabs.com/opensauce/</a></p>\\n<p>推荐文章<a href=\\\"https://philipwalton.com/articles/learning-how-to-set-up-automated-cross-browser-javascript-unit-testing/\\\">https://philipwalton.com/articles/learning-how-to-set-up-automated-cross-browser-javascript-unit-testing/</a></p>\\n<p>中文版\\n<a href=\\\"http://www.jianshu.com/p/d079b9c61450\\\">http://www.jianshu.com/p/d079b9c61450</a></p>\",\"fields\":{\"slug\":\"/opensauce/\"}}],\"unit testing\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/opensauce.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"opensauce单元测试 为开源项目提供免费的云测试\\n https://saucelabs.com/opensauce/ 推荐文章 https://philipwalton.com/articles/learning-how-to-set-up-automated-cross…\",\"frontmatter\":{\"title\":\"opensauce单元测试\",\"date\":\"2016-05-03\",\"tags\":[\"opensauce\",\"unit testing\"]},\"html\":\"<h1>opensauce单元测试</h1>\\n<p>为开源项目提供免费的云测试\\n<a href=\\\"https://saucelabs.com/opensauce/\\\">https://saucelabs.com/opensauce/</a></p>\\n<p>推荐文章<a href=\\\"https://philipwalton.com/articles/learning-how-to-set-up-automated-cross-browser-javascript-unit-testing/\\\">https://philipwalton.com/articles/learning-how-to-set-up-automated-cross-browser-javascript-unit-testing/</a></p>\\n<p>中文版\\n<a href=\\\"http://www.jianshu.com/p/d079b9c61450\\\">http://www.jianshu.com/p/d079b9c61450</a></p>\",\"fields\":{\"slug\":\"/opensauce/\"}}],\"CSS\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/pixel-layout.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"布局像素的辨析 下文主要介绍了一些关于分辨率的基础概念。 物理分辨率 所谓物理分辨率，是指一块屏幕上，横向有多少个像素点，纵向有多少个像素点，比如苹果5的分辨率是640x1136，代表它横向有640个像素点，纵向拥有113…\",\"frontmatter\":{\"title\":\"布局像素的辨析\",\"date\":\"2016-08-12\",\"tags\":[\"CSS\"]},\"html\":\"<h1>布局像素的辨析</h1>\\n<p>下文主要介绍了一些关于分辨率的基础概念。</p>\\n<h2>物理分辨率</h2>\\n<p>所谓物理分辨率，是指一块屏幕上，横向有多少个像素点，纵向有多少个像素点，比如苹果5的分辨率是640x1136，代表它横向有640个像素点，纵向拥有1136个像素点。看官也听出来了，这个物理分辨率是屏幕自带的固定参数，无法更改。</p>\\n<h2>屏幕尺寸</h2>\\n<p>屏幕尺寸指屏幕对角线的长度，根据横向长度和纵向长度进一步计算得到，使用英寸为单位，比如苹果5的尺寸为4.0英寸。</p>\\n<h2>像素密度</h2>\\n<p>像素密度是一个重要的概念，指每英寸上有多少像素点，通过这个参数可以很明确的表示屏幕清晰程度。计算公式为屏幕上所有的物理像素点，除以屏幕尺寸(对角线长度，英寸)。</p>\\n<p>常见的一个临界值是300ppi，这个数字来自于苹果4发布会，乔布斯宣称达到这个分辨率的手机，如果正常距离使用，人眼已经无法分辨屏幕上细微的方格了，苹果一向是善于包装旧概念的，retina display 一词就是被乔布斯创造出来，翻译过来就是这几年经常听到的视网膜显示屏。</p>\\n<h2>逻辑像素</h2>\\n<p>逻辑像素对于开发人员极其重要，是开发过程中表示界面尺寸的一种尺寸，这个需要和物理像素，即物理分辨率做区分。经常听到的一句话就是——物理像素是设备硬件支持的，逻辑像素是软件可以达到的。</p>\\n<p>这句话很好理解，举个简单的例子，之前的苹果3gs，分辨率是480x320，3.5英寸，风靡世界的苹果4，分辨率为它的2倍，960x640。注意，这里表达的分辨率就是指物理像素。</p>\\n<p>在苹果4上，纵向有960个像素点组成，横向则为640个像素点。\\n此时如果在这两部手机上开发，继续使用px布局，即使用物理像素进行开发，就会遇到一些问题，在苹果3gs上开发的布局，在苹果4上无法充满屏幕。</p>\\n<p>苹果此时引入一个概念，pt，即点(point)，在这之前，1pt是等于一个像素的，逻辑像素与物理像素是相同的。</p>\\n<p>在苹果4上出现了不同，1pt = 2px，也就是说，一个英寸上的物理像素数目，是逻辑像素的二倍。举个例子，在开发过程中，我们使用14pt的高度，在3gs上面，显示就是14px，也即上面说的物理像素和逻辑像素是相同的，但是在苹果4上面，显示为28px，他们所占的物理尺寸是相同的(我们肉眼看到的尺寸)，我们可以可以看到14pt的逻辑尺寸，既充满了3gs，也充满了苹果4，但事实上每单位物理尺寸上的物理像素已经不同了。\\n物理分辨率可以不同，但是他们通过逻辑像素这个概念(pt)，在显示结果上得到了统一。</p>\\n<h2>DPI</h2>\\n<p>如果明确了上面的这些概念，那么对于dpi的概念就手到擒来了，所谓dpi，是指每英寸上点的数目，这里的点自然是指pt了，于是很容易理解这样的现象：</p>\\n<p>在3gs上，使用20x20个像素来表示20x20个点，但是到了4上，使用40x40个像素来表示这20x20个点，他们所用到的物理像素数量不同，但是表示点的数目是相同的，而dpi是指每英寸上具有点的数目，于是我们可以得到3gs和4的dpi是相同的，均为162dpi。</p>\\n<p>以上</p>\",\"fields\":{\"slug\":\"/pixel-layout/\"}}],\"memory\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/os-2.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"操作系统（二） 操作系统如何管理物理主存？ 计算机体系结构、主存结构分层 CPU芯片内部有寄存器和Cache…\",\"frontmatter\":{\"title\":\"操作系统（二）\",\"date\":\"2018-01-12\",\"tags\":[\"os\",\"memory\"]},\"html\":\"<h1>操作系统（二）</h1>\\n<ol>\\n<li>操作系统如何管理物理主存？</li>\\n</ol>\\n<h2>计算机体系结构、主存结构分层</h2>\\n<ol>\\n<li>CPU芯片内部有寄存器和Cache，操作系统无法直接访问管理，这一层次的主存容量小但是数据很快。</li>\\n<li>在主存结构中有一块很大的区域，即主存或者物理主存。这块区域可以用来放置操作系统本身代码以及其他要运行的程序，主存容量大，速度慢。</li>\\n<li>计算机中可以在主存中存放着多个可运行的程序，若CPU的运行速度很快，且这些可运行的程序都需要很大的主存，那么CPU运行完主存中可运行的程序（假想当前主存中的可运行的所有程序都需要接收到网络响应后才能恢复运行），那么CPU就闲置下来了。为了避免CPU浪费，操作系统就需要发挥作用，将临时用不到的程序和数据放到硬盘中。</li>\\n<li>主存在计算机掉电之后其内的数据就丢失了，在主存结构的底层，就是硬盘，它用来保存数据。</li>\\n</ol>\\n<p><strong>特点</strong>：上述主存结构分层，从上到下速度依次降低，存储容量依次增大。数据访问很快，数据的存储空间很大。有了操作系统的帮助，操作系统如何管理物理主存，如何完成这个任务？</p>\\n<h2>操作系统为配合应用程序需要完成的任务</h2>\\n<p>为了配合程序，操作系统需要完成以下任务：</p>\\n<ul>\\n<li>抽象：我们希望应用程序在主存中运行时，不需要考虑物理主存和外设在什么地方，只需要访问一个连续的地址空间（逻辑地址空间）即可。</li>\\n<li>保护：在主存中可以运行多个不同的应用程序，某个程序可能会访问别的程序的地址空间，这时就需要一种机制来隔离和保护被访问程序的地址空间。</li>\\n<li>共享：除了隔离外，程序之间如何交互、共享各自的数据。</li>\\n<li>虚拟化：当需要在主存中运行的应用程序很多时，会出现主存不够用的情况。我们将暂时不用的数据临时放入硬盘，用的时候再拿出来，整个过程要对应用程序透明，这也是操作系统的任务。</li>\\n</ul>\\n<p><strong>注</strong>：上面提到了两个地址空间，主存和硬盘是物理地址空间，而应用程序在操作系统的作用下看到的是逻辑地址空间。</p>\\n<h2>地址空间与地址生成</h2>\\n<h3>地址空间定义</h3>\\n<p>地址空间分为物理地址空间和逻辑地址空间。</p>\\n<ul>\\n<li>物理地址空间：与硬件直接对应，主存条代表的主存和硬盘代表的另一种存储空间，物理地址空间的管理由硬件来完成。</li>\\n<li>逻辑地址空间：是运行程序所见到的一维线性的地址空间，应用程序非常容易控制和访问逻辑地址空间。</li>\\n<li>两者对应关系：某条程序指令指向某个一维逻辑地址，这个逻辑地址可能是该程序堆栈的某个位置，但最终这个位置可能是主存中甚至是硬盘中，操作系统完成了两者的映射关系。</li>\\n</ul>\\n<h3>逻辑地址生成</h3>\\n<ol>\\n<li>C程序通过编译变为汇编程序，在C程序中，函数的位置和变量的名字就是地址，只不过以一种更容易人理解的方式存在。</li>\\n<li>汇编程序更贴近机器语言，但是函数和变量仍然通过符号表示，相比机器语言，汇编语言更易让人阅读。</li>\\n<li>将汇编程序汇编成机器语言，即.o程序，.o程序的起始地址从0开始，此时变量和函数已经被转成了特定的地址。</li>\\n<li>一个大程序会由多个小程序组成，小程序之间往往具有复杂的依赖关系，通过链接可以将多个.o小程序最终变成一个单一的可执行程序.exe，.exe程序已经可以在主存中执行的，但是目前还放在硬盘中。</li>\\n<li>多个点.o程序中地址已经在.exe程序中有了相应的映射，但这个定义并非主存中的位置，再通过载入程序，将.exe程序放入到主存中执行，这一步为.exe程序分配在主存中的逻辑地址，使得应用程序在主存中正常的跑，.exe程序的地址做了相应的偏远，通过这个偏移量，程序就会依照这个偏移量进行执行。</li>\\n</ol>\\n<p><strong>特点</strong>：从函数和变量到最终可以在主存中执行的逻辑地址，通过了很多步骤，但这些步骤基本都不需要操作系统做任何的帮助，最终放入内存后，应用程序看到的地址仍然不是物理地址。</p>\\n<p><strong>题目</strong>\\n在内存管理中，地址变换机构将逻辑地址变为物理地址，形成该逻辑地址的阶段是编辑、编译、链接还是装载？\\n答：链接。在编译、汇编后，一个程序可能形成了多个.o文件，这是已经具有了逻辑地址，但只是相对于该模块的逻辑地址，并不能直接用于后续的地址变换。多个.h文件再经过链接，组合为.exe文件，便形成了相对于整个程序的逻辑地址。这个地址可用于后续的地址变换。</p>\\n<h3><del>逻辑地址如何对应物理地址（需要组成原理的内容做铺垫）</del></h3>\\n<p>指令放在物理内存的什么地方，指令的逻辑地址在什么地方，CPU有MMU，它有一块区域存着映射关系，查表可以完成具体的物理地址，硬件就可以从相应的物理地址中取出。</p>\\n<p>操作系统先生成一个逻辑地址和物理地址的映射关系，将该映射关系存在内存中，CPU可以在MMU中缓存这个映射关系。（<strong>如何完成预先生成，后续谈</strong>）</p>\\n<ol>\\n<li>CPU执行某条指令，ALU需要得到该指令逻辑地址上的内容，ALU首先将该逻辑地址作为参数，向存储管理单元MMU发出查物理地址的请求。</li>\\n<li>CPU的MMU查找对应的映射表，判断是否有对应的物理地址。</li>\\n<li>若没有这个物理地址，就到内存中的映射表上找</li>\\n<li>找到后CPU的控制器向主存发出请求，需要某个物理地址的内容，主存将内存的内容通过总线传给CPU，CPU拿到内容就可以进行执行了</li>\\n</ol>\\n<h2>如何确保内存中的程序不相互干扰</h2>\\n<p>操作系统首先确认每个程序可以访问的地址空间，第一部分是起始地址，第二个部分是该程序可访问的区域。这张表由操作系统建立和维护，CPU在执行某条指令时，CPU要查表确定是否合法，合法之后才根据地址取指令。</p>\",\"fields\":{\"slug\":\"/os-2/\"}}],\"React\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/react-summary.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"React学习总结 参考官方文档，整理一些应该被重视的知识点 React中的事件相关 类似HTML中事件的使用方法，可以直接将事件处理函数作为属性值，赋给用驼峰式命名的事件属性。之后的事情交给React，React…\",\"frontmatter\":{\"title\":\"React学习总结\",\"date\":\"2016-04-21\",\"tags\":[\"React\",\"JS\"]},\"html\":\"<h1>React学习总结</h1>\\n<p>参考官方文档，整理一些应该被重视的知识点</p>\\n<h2>React中的事件相关</h2>\\n<p>类似HTML中事件的使用方法，可以直接将事件处理函数作为属性值，赋给用驼峰式命名的事件属性。之后的事情交给React，React自己有一个事件系统，它可以保证事件在所有浏览器中的一致性，React知道如何去冒泡和捕获事件，这个实现是根据w3c的规范，不管使用的是什么浏览器</p>\\n<h2>State 相关</h2>\\n<p>State是可以用来动态渲染，和props是一对好基友。</p>\\n<h3>State 的异步工作方式</h3>\\n<p><code>setState</code> 方法本身是异步的，有一种常见的方式是当React数据改变时，通过 setState(data,callback) 这个方法会将新数据合并到this.state对象上，之后重新渲染组件。当组件结束了重新渲染(re-render），可选的第二个参数callback会被执行。</p>\\n<h3>组件在什么时候需要State</h3>\\n<p>大多数的组件应该简单的通过props获取数据，之后渲染组件，然而有时候会需要一些复杂的数据处理，比如说响应用户的操作，一个请求，此时需要用到state。但尽可能多的让组件无状态话，减少冗余。一种常见的模式是创建许多无状态的组件，它们仅仅负责渲染数据，有一个拥有状态组件在它们层级之上，经过一系列的逻辑处理，通过props将state传递给它的子组件。有状态的组件囊括了尽可能多的逻辑，而无状态的组件仅仅负责渲染数据。</p>\\n<h3>哪些数据应该作为State</h3>\\n<p>尽量使用 props 作为唯一的数据源，事件处理函数会响应用户的事件，此时可能会更新影响用户界面的数据，这些数据应该被 State 包含。真实环境下，这个数据应该很小且可以被 JSON 序列化 。\\n在创建包含状态的组件时，让它尽可能少的包含状态，并且将这些状态存入 this.state 对象中，后续的 render 方法再根据可能有的状态来计算出需要的其他数据，逻辑处理在 render ，通过状态来计算 render 的内容。</p>\\n<h2>组件复用</h2>\\n<p>React 因为新的 render 而导致 DOM 发生更新的过程称为组件校正，这个校正过程是根据组件的顺序决定，比如</p>\\n<pre><code class=\\\"language-html\\\">// Render Pass 1\\n&#x3C;Card>\\n    &#x3C;p>Paragraph 1&#x3C;/p>\\n    &#x3C;p>Paragraph 2&#x3C;/p>\\n&#x3C;/Card>\\n// Render Pass 2\\n&#x3C;Card>\\n    &#x3C;p>Paragraph 2&#x3C;/p>\\n&#x3C;/Card>\\n</code></pre>\\n<p>看起来像是 React 通过 diff 删除了第一个标签，但实际上 React 按照组件的顺序，修改了第一个标签的文本，删除了第二个组件。考虑一个组件由很多状态决定，内部的DOM需要来回的切换，由于组件校正的原理，可能会有些性能问题。此时可以选择为组件添加 <code>display: none</code> ，而不是直接选择删除。有些情况可能比较复杂，比如说有一个很长的列表，需要不断的重排序或者向首尾插入删除新子组件，这种情况如果按照顺序来校正，可能会出现性能问题，此时可以为这些子组件指定独一无二的key。当 React 校正这些组件的时候，就会直接重排序或者销毁，而不是按照顺序，修改子组件的内容来校正。</p>\\n<h2>PropTypes</h2>\\n<p>当项目越来越大，组件的复用越来越频繁，为了确保每次复用接收到的 props 是可用的，需要指定PropTypes。</p>\\n<p>类似于 export，React.PropTypes 对象导出很多验证器，这些验证器可以保证传递来的 props 是正确的。\\n当一个不可用的值被传递给当前组件的 props，那么在控制台中就会显示异常。\\n具体的属性可以参考这个<a href=\\\"http://facebook.github.io/react/docs/reusable-components.html\\\">页面</a>，可以为对象或者数组指定具体的内部 Child。</p>\",\"fields\":{\"slug\":\"/react-summary/\"}}],\"JS\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/react-summary.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"React学习总结 参考官方文档，整理一些应该被重视的知识点 React中的事件相关 类似HTML中事件的使用方法，可以直接将事件处理函数作为属性值，赋给用驼峰式命名的事件属性。之后的事情交给React，React…\",\"frontmatter\":{\"title\":\"React学习总结\",\"date\":\"2016-04-21\",\"tags\":[\"React\",\"JS\"]},\"html\":\"<h1>React学习总结</h1>\\n<p>参考官方文档，整理一些应该被重视的知识点</p>\\n<h2>React中的事件相关</h2>\\n<p>类似HTML中事件的使用方法，可以直接将事件处理函数作为属性值，赋给用驼峰式命名的事件属性。之后的事情交给React，React自己有一个事件系统，它可以保证事件在所有浏览器中的一致性，React知道如何去冒泡和捕获事件，这个实现是根据w3c的规范，不管使用的是什么浏览器</p>\\n<h2>State 相关</h2>\\n<p>State是可以用来动态渲染，和props是一对好基友。</p>\\n<h3>State 的异步工作方式</h3>\\n<p><code>setState</code> 方法本身是异步的，有一种常见的方式是当React数据改变时，通过 setState(data,callback) 这个方法会将新数据合并到this.state对象上，之后重新渲染组件。当组件结束了重新渲染(re-render），可选的第二个参数callback会被执行。</p>\\n<h3>组件在什么时候需要State</h3>\\n<p>大多数的组件应该简单的通过props获取数据，之后渲染组件，然而有时候会需要一些复杂的数据处理，比如说响应用户的操作，一个请求，此时需要用到state。但尽可能多的让组件无状态话，减少冗余。一种常见的模式是创建许多无状态的组件，它们仅仅负责渲染数据，有一个拥有状态组件在它们层级之上，经过一系列的逻辑处理，通过props将state传递给它的子组件。有状态的组件囊括了尽可能多的逻辑，而无状态的组件仅仅负责渲染数据。</p>\\n<h3>哪些数据应该作为State</h3>\\n<p>尽量使用 props 作为唯一的数据源，事件处理函数会响应用户的事件，此时可能会更新影响用户界面的数据，这些数据应该被 State 包含。真实环境下，这个数据应该很小且可以被 JSON 序列化 。\\n在创建包含状态的组件时，让它尽可能少的包含状态，并且将这些状态存入 this.state 对象中，后续的 render 方法再根据可能有的状态来计算出需要的其他数据，逻辑处理在 render ，通过状态来计算 render 的内容。</p>\\n<h2>组件复用</h2>\\n<p>React 因为新的 render 而导致 DOM 发生更新的过程称为组件校正，这个校正过程是根据组件的顺序决定，比如</p>\\n<pre><code class=\\\"language-html\\\">// Render Pass 1\\n&#x3C;Card>\\n    &#x3C;p>Paragraph 1&#x3C;/p>\\n    &#x3C;p>Paragraph 2&#x3C;/p>\\n&#x3C;/Card>\\n// Render Pass 2\\n&#x3C;Card>\\n    &#x3C;p>Paragraph 2&#x3C;/p>\\n&#x3C;/Card>\\n</code></pre>\\n<p>看起来像是 React 通过 diff 删除了第一个标签，但实际上 React 按照组件的顺序，修改了第一个标签的文本，删除了第二个组件。考虑一个组件由很多状态决定，内部的DOM需要来回的切换，由于组件校正的原理，可能会有些性能问题。此时可以选择为组件添加 <code>display: none</code> ，而不是直接选择删除。有些情况可能比较复杂，比如说有一个很长的列表，需要不断的重排序或者向首尾插入删除新子组件，这种情况如果按照顺序来校正，可能会出现性能问题，此时可以为这些子组件指定独一无二的key。当 React 校正这些组件的时候，就会直接重排序或者销毁，而不是按照顺序，修改子组件的内容来校正。</p>\\n<h2>PropTypes</h2>\\n<p>当项目越来越大，组件的复用越来越频繁，为了确保每次复用接收到的 props 是可用的，需要指定PropTypes。</p>\\n<p>类似于 export，React.PropTypes 对象导出很多验证器，这些验证器可以保证传递来的 props 是正确的。\\n当一个不可用的值被传递给当前组件的 props，那么在控制台中就会显示异常。\\n具体的属性可以参考这个<a href=\\\"http://facebook.github.io/react/docs/reusable-components.html\\\">页面</a>，可以为对象或者数组指定具体的内部 Child。</p>\",\"fields\":{\"slug\":\"/react-summary/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-09-01----js-function-2/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"再探JS函数 函数是JS的核心概念，主要用来封装语句，封装单独的功能。 函数参数 函数不在意它本身到底接收多少参数，不关心最后会使用多少参数。因为函数只会接收一个数组，函数可以通过 arguments…\",\"frontmatter\":{\"title\":\"再探JS函数\",\"date\":\"2016-09-07\",\"tags\":[\"JS\",\"function\"]},\"html\":\"<h1>再探JS函数</h1>\\n<p>函数是JS的核心概念，主要用来封装语句，封装单独的功能。</p>\\n<h2>函数参数</h2>\\n<p>函数不在意它本身到底接收多少参数，不关心最后会使用多少参数。因为函数只会接收一个数组，函数可以通过<code>arguments</code>属性来访问这个参数数组。关于这个数组，他其实是个对象，如下:</p>\\n<pre><code class=\\\"language-js\\\">var a = function () {var b= 1; var c = 0} //a是一个函数\\ntypeof a.arguments  // Object\\n</code></pre>\\n<p>但是为什么又说它是数组呢，因为它本身很数组很像，可以通过方括号加数字的方法来访问具体的参数，同时还有数组对象有的<code>length</code>属性。一个有趣的例子：</p>\\n<pre><code class=\\\"language-js\\\">function a (){\\n  console.log(\\\"hello\\\" +　arguments[0] + arguments[1]);\\n}\\na(\\\"hao\\\",\\\"xiang\\\"); //hellohaoxiang\\n</code></pre>\\n<p>这样子依然是有效的，在函数执行的时候，通过<code>arguments</code>对象的<code>length</code>属性可以知道被传递的参数个数，还有个更有趣的例子，是关于<code>arguments</code>的同步性的：</p>\\n<pre><code class=\\\"language-js\\\">function doAdd (num1,num2){\\n  arguments[1]=10;\\n  alert(arguments[0] + num2);\\n  }\\n  doAdd(1,1); //11，arguments[1]和num2是同步的\\n</code></pre>\\n<p>参数就是局部变量，对于函数来说，传递参数是按值的，基本类型的很好理解，相当于变量的复制。对于引用类型来说，还需要留意到此时依然是按值传递的，这个值依然是指引用的内存地址值。证明方法：需要先创建一个对象，传递函数中，此时在函数内部修改对象的属性，此时内外是一致的，因为他们是一种的一个对象。但是此时如果将参数重新初始化为一个对象，那么也就是说此时参数已经指向另一个变量了，和之前的一切无关。</p>\\n<h2>函数相关属性</h2>\\n<p><code>arguments</code>属性有一个叫做<code>callee</code>的指针，这个指针指向拥有这个<code>arguments</code>对象的函数。主要用来解除耦合，下面是关于递归算法的例子</p>\\n<pre><code class=\\\"language-js\\\">function fac (num) {\\n    switch (num){\\n        case 1 :\\n        return 1;\\n        default: return num * arguments.callee(num-1);\\n    }\\n}\\n</code></pre>\\n<p>函数的另外一个内部属性是<code>this</code>对象，<code>this</code>引用的是函数据以执行的环境对象，<code>this</code>是包含它的函数作为方法被调用是所属的对象 = 包含它的函数 + 作为方法被调用时 + 所属的对象。</p>\\n<h2>函数的方法</h2>\\n<p>主要有<code>apply</code>,<code>call</code>与<code>bind</code></p>\\n<h3><code>apply()</code>与<code>call()</code>：</h3>\\n<p>表示在特定的作用域内调用函数，与<code>call()</code>的区别在于<code>call</code>在使用时必须指定参数。</p>\\n<h2><code>bind()</code></h2>\\n<p>这个方法可以用来创建一个新的实例，实例的<code>this</code>值会被绑定到传给<code>bind()</code>的值上</p>\\n<h2>细碎的小点</h2>\\n<ul>\\n<li><code>return</code>语句，一旦<code>return</code>，后续的语句不会继续执行了，不加<code>return</code>的话，函数默认的返回值是<code>undefined</code>。</li>\\n</ul>\",\"fields\":{\"slug\":\"/2016-09-01----js-function-2/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-02-07---js-in/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"JavaScript 中的 in 关键字 在 JavaScript 中,我经常会使用 for(key in ..) 语句来遍历对象的 key  ,这是一种很常用的方式.\\n这里需要留意, 其实 for(.. in ..) 语句也可以用来遍历数组,其中的 key…\",\"frontmatter\":{\"title\":\"JavaScript 中的 in 关键字\",\"date\":\"2016-02-07\",\"tags\":[\"JS\"]},\"html\":\"<h1>JavaScript 中的 in 关键字</h1>\\n<p>在<code>JavaScript</code>中,我经常会使用<code>for(key in ..)</code>语句来遍历对象的<code>key</code> ,这是一种很常用的方式.\\n这里需要留意, 其实<code>for(.. in ..)</code>语句也可以用来遍历数组,其中的<code>key</code>就是数组的<code>index</code>(索引值,0开始) 。\\n除了在<code>for(.. in ..)</code>语句中使用,<code>in</code>也可以作为一个单独的关键字使用,用来判断某个属性或者元素是否存在与数组或者对象.一般会用在判断语句中,下面进行说明。</p>\\n<h2>数组</h2>\\n<pre><code class=\\\"language-js\\\">var pig = ['head', 'hand', 'leg'];\\nconsole.log('head' in pig); // false\\nconsole.log('0' in pig); // true\\nconsole.log(4 in pig); // false\\n</code></pre>\\n<p>通过<code>in</code>操作判断数组是否存在某个索引,逐个分析：</p>\\n<ol>\\n<li>判断<code>head</code>字符串是否为<code>pig</code>的索引,很明显,索引应该是数字,所以<code>false</code>。</li>\\n<li>判断<code>pig</code>是否有索引为字符串 '0',可以看到最后判断结果为 true, 这是因为执行<code>in</code>关键字判断时, <code>JS</code>引擎进行了隐式转换。</li>\\n<li>判断数字<code>4</code>是否为<code>pig</code>数组的索引,结果<code>false</code>。</li>\\n</ol>\\n<h2>对象</h2>\\n<pre><code class=\\\"language-js\\\">var pig = {head: 'head', hand: 'head', leg: 'leg'};\\nconsole.log(head in pig); // false\\nconsole.log('head' in pig); // true\\n</code></pre>\\n<p>通过<code>in</code>操作判断对象是否有某个键名,逐个分析：</p>\\n<ol>\\n<li>判断变量<code>head</code>是否为<code>pig</code>的键名, <code>head</code>是一个未声明未赋值的变量,当然不会是<code>pig</code>的键名,返回<code>false</code>。\\n判断字符串<code>head</code>是否为<code>pig</code>的键名,返回<code>true</code>。</li>\\n</ol>\",\"fields\":{\"slug\":\"/2016-02-07---js-in/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-08-26---js-function-1/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"初探JS函数 有关函数相关的话题在网上讨论的并不够多，因为它比较复杂，这也是为什么现在网上会存在如此多的误解。 在这片文章里面，我会试着去总结有关函数的好的，坏的，丑陋的一面。 函数表达式 VS. 函数声明 在 ECMAScript…\",\"frontmatter\":{\"title\":\"初探JS函数\",\"date\":\"2016-08-26\",\"tags\":[\"JS\",\"function\"]},\"html\":\"<h1>初探JS函数</h1>\\n<p>有关函数相关的话题在网上讨论的并不够多，因为它比较复杂，这也是为什么现在网上会存在如此多的误解。 在这片文章里面，我会试着去总结有关函数的好的，坏的，丑陋的一面。</p>\\n<h2>函数表达式 VS. 函数声明</h2>\\n<p>在 ECMAScript 中，如果需要使用函数，最常用的两种方法就是通过函数表达式和函数声明。掌握它们区别非常重要，因为在JS 中两者的执行是有差别的，可惜很不爽，至少在看来， 两者之间的差别可以说是相当混乱，只有一件事是 ECMA 规范中讲清楚的—-函数声明必须要有一个函数名(规范中称为 identifier (标识)），函数表达式可以忽略函数名：</p>\\n<pre><code class=\\\"language-js\\\">// FunctionDeclaration :\\nfunction Identifier ( FormalParameterList &#x3C;opt> ){ FunctionBody }\\n// FunctionExpression :\\nfunction Identifier&#x3C;opt> ( FormalParameterList &#x3C;opt> ){ FunctionBody }\\n</code></pre>\\n<p>我们可以仔细瞧瞧，当忽略函数名时，只能是函数表达式，这个是没有争议的，因为规范中有说，函数表达式可以忽略函数名，但是如果加上函数名呢？这两种方式一模一样，我们别人说这是一个函数声明，还是一个函数表达式呢？</p>\\n<h2>区分函数表达式和函数声明</h2>\\n<p>看起来 ECMAScript 判断两者的不同是基于整个上下文的，如果<code>function foo () {}</code>是一行语句的某个部分，比如说赋值表达式的一部分，它应该是一个函数表达式，可以理解为当前赋值表达式有函数的参与。 如果<code>function foo () {}</code>被包含在一个函数体内或者直接暴露在最上层的作用域下，它就是一个函数声明。</p>\\n<pre><code class=\\\"language-js\\\">function foo(){} // 声明，因为它暴露在全局作用域下\\nvar bar = function foo () {} // 表达式，因为它是构成赋值表达式的一部分\\n new function bar () {} // 表达式，因为它是 new 语句的一部分\\n (funciton () {\\n     function bar () {} // 声明，因为它在函数体内\\n })();\\n</code></pre>\\n<p>上面的例子有个需要留意的地方，(function () {})这个函数应该算作哪一种。可以明确的说它是一个函数表达式，因为前后的两个()括号。两个括号组成一个分组运算符，而分组运算符可以包含表达式的，所以按照上面的说明，它是一部分，是一个函数表达式(注意区分编程中的语句和表达式，参考文章<a href=\\\"http://www.2ality.com/2012/09/expressions-vs-statements.html\\\">http://www.2ality.com/2012/09/expressions-vs-statements.html</a>。</p>\\n<p>区分清楚之后，来看他们之间的不同，首先在其他语句还没有执行之前，函数声明将会先被解析和执行。即便它的位置在整个页面资源的最底部，它会被在作用域中出现的时间将会先于其他的任何表达式。下面的例子演示了fn 函数声明的位置靠后，但是依然可以在声明的位置之前被调用。</p>\\n<pre><code class=\\\"language-js\\\">alert(fn());\\nfunction fn () {\\nreturn \\\"hello world~\\\"\\n}\\n</code></pre>\\n<p>另外一个绝对需要注意的特点，不要在条件语句声明函数，在不同的环境下，会有不同的处理结果，所以当遇到要依据不同条件来新建函数时，一定要使用函数表达式代替，看下面的例子：</p>\\n<pre><code class=\\\"language-js\\\">// 绝对不要这样做，由于函数声明会在其他语句没有执行之前就声明完毕，所以这里的处理逻辑比较混乱\\n// 某些浏览器会直接使用第一个声明，返回 'first'\\n// 某些会使用第二个声明 'second'\\nif (true) {\\n  function foo() {\\n    return 'first';\\n  }\\n}\\nelse {\\n  function foo() {\\n    return 'second';\\n  }\\n}\\nfoo();\\n// 当一定需要依据不同情况创建函数时，使用函数表达式的方法来代替\\nvar foo;\\nif (true) {\\n  foo = function() {\\n    return 'first';\\n  };\\n}\\nelse {\\n  foo = function() {\\n    return 'second';\\n  };\\n}\\nfoo();\\n</code></pre>\",\"fields\":{\"slug\":\"/2016-08-26---js-function-1/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-10-01---node-file-system/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"Node文件系统 Node 通过封装基本的 POSIX 函数来提供文件系统，使用 require('fs…\",\"frontmatter\":{\"title\":\"Node文件系统\",\"date\":\"2016-10-01\",\"tags\":[\"Node\",\"JS\"]},\"html\":\"<h1>Node文件系统</h1>\\n<p><code>Node</code>通过封装基本的<code>POSIX</code>函数来提供文件系统，使用<code>require('fs')</code>来使用这个模块，所有与文件相关的方法，都提供了异步和同步的形式。 异步的方法通常会将一个可选的回调函数作为最后一个参数，回调函数的第一个参数通常留给意外情况，如果操作是成功的，第一个参数将是<code>null</code>或者<code>undeefined</code>。 使用同步方法，对于任何意外都会即时抛出，可以使用<code>try/catch</code>语句来处理意外情况，或者让错误时间向上冒泡。 下面是一个有关异步方法的基本例子：</p>\\n<pre><code class=\\\"language-js\\\">const fs = require('fs');\\nfs.unlink('/tmp/hello', (err) => {\\n  if (err) throw err;\\n  console.log('sucessfully deleted /tmp/hello');\\n}\\n</code></pre>\\n<p>再跟着一个同步的例子：</p>\\n<pre><code class=\\\"language-js\\\">const fs = require('fs');\\nfs.unlink('/tmp/hello');\\nconsole.log('successfully deleted /tmp/hello');\\n</code></pre>\\n<p>使用异步方法时，需要注意异步方法的执行不一定按照书写顺序，比如下面这种写法很容易出错：</p>\\n<pre><code class=\\\"language-js\\\">fs.rename('/tmp/hello', '/tmp/world', (err) => {\\n   if (err) throw err;\\n   console.log('renamed compelte');\\n});\\nfs.stat('/tmp/world', (err, stats) => {if (err) throw err;\\nconsole.log(`stats: ${JSON.stringify(stats)}`)});\\n</code></pre>\\n<p>在这里，很可能<code>fs.stat</code>函数先于<code>fs.rename</code>，这样会出现一些不必要的错误，正确的方法应该是写在回调函数中:</p>\\n<pre><code class=\\\"language-js\\\">fs.rename('/tmp/hello/', '/tmp/world', (err) ss=> {\\n    if (err) throw err;\\n    fs.stat('/tmp/world'),(err, stats) => {\\n        console.log(`stats: ${JSON.stringfy(stats)});\\n    });\\n});\\n</code></pre>\\n<p>执行复杂耗时的方法，强烈建议使用异步版本，同步方法在它们执行结束之前，会一直锁住当前线程，阻断所有操作。 在<code>fs</code>模块中，可以使用相对路径，但是需要留意参照的路径来自于<code>process.cwd()</code>的返回值。 很多<code>fs</code>函数可以忽略掉回调参数，如果这样进行使用，默认会抛出错误，为了跟踪到函数调用的位置，可以设置<code>NODE_DEBUG</code>环境变量：</p>\\n<pre><code class=\\\"language-bash\\\">$ cat script.js\\nfunction bad() {\\n  require('fs').readFile('/');\\n}\\nbad();\\n$ env NODE_DEBUG=fs node script.js\\nfs.js:66\\n        throw err;\\n              ^\\nError: EISDIR, read\\n    at rethrow (fs.js:61:21)\\n    at maybeCallback (fs.js:79:42)\\n    at Object.fs.readFile (fs.js:153:18)\\n    at bad (/path/to/script.js:2:17)\\n    at Object.&#x3C;anonymous> (/path/to/script.js:5:1)\\n    &#x3C;etc.>\\n</code></pre>\\n<p><code>fs.watch(filename[, options][, listener])</code>监听制定文件或者目录的变化情况，<code>filename</code>参数可以是文件或者目录，这个方法返回一个<code>fs.FSWather</code>对象。 第二个参数是可选的，提供的<code>options</code>参数应该是一个对象，里面要求的成员是<code>persistent</code>和<code>recursive</code>，这个两个成员都是布尔类型的值。 用做监听的回调函数有两个参数，分别是(<code>event</code>, <code>filename</code>)，<code>event</code>的值视情况，返回字符串<code>change</code>，<code>rename</code>，文件名指的是触发事件的这个文件。看下面的这个例子：</p>\\n<pre><code class=\\\"language-js\\\">// node.md\\n// 被监听的文件\\nthis is cat.\\n// app.js\\n// 用来监听文件改变\\n    fs.watch('./node.md', (event, filename) => {\\n        console.log('下面是event参数，event参数的类型，filename');\\n        console.log(typeof event);\\n        console.log(filename);\\n    });\\n// node.md\\n// 这里修改了监听的node.md文件\\nthis is dog.\\n// console\\n// 执行结果\\n下面是event参数，event参数的类型，filename\\nchange\\nstring\\nnode.md\\n// node.md => node1.md\\n// 修改文件的名字\\n// console\\n// 执行结果\\n下面是event参数，event参数的类型，filename\\nrename\\nstring\\nnode1.md\\n</code></pre>\\n<p>注意事项： <code>fs.watch</code>并不是跨所有平台的，在某些常见下不一定可用。 第二个参数中的布尔值<code>recursive</code>只在<code>osx</code>和<code>window</code>下可以使用。</p>\\n<h2>可用性</h2>\\n<ul>\\n<li><code>fs.watch</code>依赖于操作系统底层模块，由操作系统底层模块通知Node文件的变化。</li>\\n<li>如果某个操作系统底层模块对于文件的监听本身就有问题，那么<code>fs.watch</code>是无法发挥作用的，比如监听了一些不可靠的目录和文件，网络文件系统，虚拟机系统中的文件。</li>\\n<li>在<code>Linux</code>，<code>osx</code>系统中，<code>fs.watch</code>解析路径成一个索引节点，并且监听这个节点，但是如果监听的节点被删除或者重新创建，那么此时它就成了一个新节点了，<code>watch</code>将会发送一个<code>delete</code>事件，但是仍然监听原来的节点，原来的事件不会响应新节点的改变，这种处理是符合预期的。</li>\\n<li><code>filename</code>参数只支持在<code>Linux</code>和<code>windows</code>上面指定(<code>osx</code>也可以，但是有些情况可能会有异常)，事实上，即便是在可以使用的平台上，也不建议直接使用这个参数，因为在回调函数内部，建议增加一些逻辑判断，看一下<code>filename</code>是否为<code>null</code>，如下面的例子：</li>\\n</ul>\\n<pre><code class=\\\"language-js\\\">fs.watch('somedir', (event, filename) => {\\n    console.log(`event is: ${event}`);\\n    if (filename) {\\n         console.log(`filename provided: ${filename}`);\\n     } else {\\n         console.log('filename not provided');\\n     }\\n});\\n</code></pre>\",\"fields\":{\"slug\":\"/2016-10-01---node-file-system/\"}}],\"Git\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-08-20---git-add/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"Git 学习小记之 add 所谓 add 操作，就是 add file into staged area 。下面针对两种情况进行讨论： 新建的文件 旧文件 新建的文件 我们了解 add…\",\"frontmatter\":{\"title\":\"Git 学习小记之 add\",\"date\":\"2016-08-20\",\"tags\":[\"Git\"]},\"html\":\"<h1>Git 学习小记之 add</h1>\\n<p>所谓<code>add</code>操作，就是<code>add file into staged area</code>。下面针对两种情况进行讨论：</p>\\n<ul>\\n<li>新建的文件</li>\\n<li>旧文件</li>\\n</ul>\\n<h2>新建的文件</h2>\\n<p>我们了解<code>add</code>是一个重要的操作。假设有一个空目录，此时里面没有任何文件。\\n我们新建一个文件，这个文件就是处于<code>untrack</code>状态的，可以理解为未被跟踪状态。</p>\\n<p>此时修改这个文件，依然是处于<code>untrack</code>状态。在此时使用<code>add</code>操作，有两个作用：</p>\\n<ol>\\n<li>将新文件添加到暂存区(<code>staged</code>)</li>\\n<li>将文件标记为 <code>track</code></li>\\n</ol>\\n<p>我们再使用<code>commit</code>操作，生成快照，同时<code>clean</code>暂存区，初始化一切。</p>\\n<h2>旧文件</h2>\\n<p>另外一种情况，假设已经有了旧文件，文件处于<code>track</code>状态。</p>\\n<p>此时修改文件，如果使用<code>status</code>命令查看，会提示<code>Changes not staged for commit</code>，大意就是此时已经更新文件了，但是更新的内容还没有暂存起来，提示使用<code>add</code>操作进行暂存。</p>\\n<p>按照提示使用<code>add</code>操作后，使用<code>status</code>命令查看，会发现处于已暂存状态。<code>Changes to be committed</code>，如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。</p>\\n<h2>与 <code>commit</code> 搭配使用</h2>\\n<p>如果发现不断的<code>add</code>、<code>commit</code>比较麻烦，可以使用<code>commit</code>命令加<code>-a</code>参数，Git会自动更新已经跟踪过的文件，更新暂存区。但这里有个地方需要留意，<code>-a</code> 参数并不会更新未跟踪的文件。</p>\\n<h2>总结</h2>\\n<p>关于<code>add</code>，最值得留意的就是一旦修改文件，必须重新暂存，否则生成快照(<code>commit</code>)的依然是上次<code>add</code>时的状态，快照只从暂存区来。</p>\\n<p>总结起来，对于新文件，<code>add</code>会跟踪文件，同时将文件存入暂存区，如果是旧文件，可以按照本地文件更新暂存区的文件。除了上面提到的，还有一种常见的情况，当文件出现冲突时，经常需要人为解决冲突，在修改之后，可以使用<code>add</code>操作将有冲突的文件标记为已经解决状态。</p>\",\"fields\":{\"slug\":\"/2016-08-20---git-add/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-09-01---git-branch/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"Git学习小记之分支原理 如果想要熟练使用 Git，没有分支理念是绝对行不通的，在用 Git 管理项目的时候，经常需要使用 commit 这个命令，那么这个 commit 到底是指什么呢？ 按照官方的解释，这应该成为一个对象，它包含着一个指向暂存内容(被add…\",\"frontmatter\":{\"title\":\"Git学习小记之分支原理\",\"date\":\"2016-09-01\",\"tags\":[\"Git\"]},\"html\":\"<h1>Git学习小记之分支原理</h1>\\n<p>如果想要熟练使用 Git，没有分支理念是绝对行不通的，在用 Git 管理项目的时候，经常需要使用 commit 这个命令，那么这个 commit 到底是指什么呢？</p>\\n<p>按照官方的解释，这应该成为一个对象，它包含着一个指向暂存内容(被add的文件)快照的指针，包含本次提交的附属信息，比如说作者等等，指向父 commit 对象(如果被 merge 而成，可能有多个父 commit 对象)的指针。</p>\\n<p>举下面这个例子来分析：</p>\\n<pre><code class=\\\"language-bash\\\">git add README test.rb LICENSE\\ngit commit -m 'initial commit of my project'\\n</code></pre>\\n<ul>\\n<li>add：暂存操作会对文件计算校验和(SHA-1哈希字串)，然后与当前版本的文件快照(用 blob 对象存储)一起存入到暂存区域中。</li>\\n<li>commit：正式建立提交对象前：Git 先计算出每一个子目录的校验和，然后在 Git 仓库中，将这些目录保存为树对象。</li>\\n</ul>\\n<p>建立提交对象的过程主要如下：\\n携带相关提交信息，包含一个指向该树的指针，这样就代表如果将来需要，可以重现此次快照内容。\\n来看看现在仓库中有什么：\\n一个表示文件快照内容的 blob 对象，一个记录着目录树内容，以及其中各个文件具体对应哪个 blob 对象的索引 tree 对象。以及一个包含着指向索引 tree 对象，以及其他提交信息元数据的 commit 对象。如图：</p>\\n<p><img src=\\\"a.png\\\"></p>\",\"fields\":{\"slug\":\"/2016-09-01---git-branch/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-09-10---git-alias/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"Git 学习小记之使用别名 Git 是在开发中需要频繁使用的工具，如何高效使用，除了深刻理解用法之外，还可以利用一些别名来减少操作。 Git 中的省略其实无处不在，事实上在我们 push 的时候使用的  git push origin master ，意思就是 git push…\",\"frontmatter\":{\"title\":\"Git 学习小记之使用别名\",\"date\":\"2016-09-10\",\"tags\":[\"Git\"]},\"html\":\"<h1>Git 学习小记之使用别名</h1>\\n<p>Git 是在开发中需要频繁使用的工具，如何高效使用，除了深刻理解用法之外，还可以利用一些别名来减少操作。</p>\\n<p>Git 中的省略其实无处不在，事实上在我们<code>push</code>的时候使用的 <code>git push origin master</code>，意思就是<code>git push origin master:master</code>（将本地的<code>master</code>分支推送至远端的<code>master</code>分支，如果没有就新建一个），这就是一个省略了。</p>\\n<p>哈哈，开玩笑的，下面开始进入正题了，想要使用别名，需要先在 Git 中进行配置，命令如下：</p>\\n<pre><code class=\\\"language-bash\\\">git config --global alias.&#x3C;缩写> &#x3C;全称>\\n</code></pre>\\n<p>举个例子</p>\\n<pre><code class=\\\"language-bash\\\">git config --global alias.co checkout\\n</code></pre>\\n<p>这里代表的例子就是指用<code>co</code>命令代替<code>checkout</code>命令，输入这个命令后，后续如果需要切换分支，那么就可以直接使用</p>\\n<pre><code class=\\\"language-bash\\\">git co haoxiangQ2\\nSwitched to branch 'haoxiangQ2'\\n</code></pre>\\n<p>在使用 Git 的时候，我们会 add 追踪文件，但是有时候需要取消对文件的追踪，就会用的 reset 命令，对于这个命令，经常会有人抱怨不好记，太长，那么可以使用下面的配置</p>\\n<pre><code class=\\\"language-bash\\\">git config --global alias.unstage 'reset HEAD --'\\ngit unstage fileA\\n</code></pre>\\n<p>方便快捷，哈哈，下面有些官方推荐的别名配置，可以灵活使用</p>\\n<pre><code class=\\\"language-bash\\\">git config --global alias.co checkout\\ngit config --global alias.br branch\\ngit config --global alias.ci commit\\ngit config --global alias.st status\\ngit config --global alias.unstage 'reset HEAD --'\\ngit config --global alias.last 'log -1 HEAD'\\n</code></pre>\",\"fields\":{\"slug\":\"/2016-09-10---git-alias/\"}}],\"css\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2015-10-05---css-summary/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"CSS 总结 计划总结常用的CSS…\",\"frontmatter\":{\"title\":\"CSS 总结\",\"date\":\"2015-10-5\",\"tags\":[\"css\"]},\"html\":\"<h1>CSS 总结</h1>\\n<p>计划总结常用的CSS知识</p>\\n<h2>基本布局</h2>\\n<p>下面汇总了传统的绝对，浮动，表格与凝胶等布局方式的优缺点</p>\\n<h3>绝对布局</h3>\\n<ul>\\n<li>优点：主内容随页面宽度，固定边栏</li>\\n<li>缺点：浏览器变宽的时候，页脚可能会遮住边栏，同时浏览器变宽后，主内容区和边栏的比例会不协调。</li>\\n</ul>\\n<h3>表格显示布局</h3>\\n<ul>\\n<li>优点：使用<code>table</code>标签，随窗口缩放</li>\\n<li>缺点：对于语义化不利</li>\\n</ul>\\n<h3>凝胶布局</h3>\\n<ul>\\n<li>优点：主内容区建立后，设置左右margin为0</li>\\n<li>缺点：对于页面的利用率不充足</li>\\n</ul>\\n<h2>盒子模型</h2>\\n<p>边框折叠指两个垂直外边距相遇时，会碰到一起，即便是元素嵌套也不例外会进行折叠，下面有一些特殊情况：</p>\\n<ol>\\n<li>\\n<p>上面的div有20px的边距，下面的有10px的边距，此时折叠，依然是20px的边距。但是如果此时把下面的元素设置为float，那么两者的边框不会折叠。</p>\\n</li>\\n<li>\\n<p>考虑这种情况，一个元素嵌套一个元素，此时依然是折叠的，但如果此时为外边的元素设置了边框，那么内外元素边距不折叠</p>\\n</li>\\n<li>\\n<p>box-sizing的用法</p>\\n</li>\\n</ol>\\n<h2>选择器优先级</h2>\\n<p>计算方法如下：计算模型分三个位置，其中，选择器若包含id，则计算模型第一位加一，第二个位置为class、伪类则加一。第三个位置为元素名，每个元素名加一，最后按照结果大小排序，对于依然冲突的规则，按照先后顺序，后出现的覆盖之前的。</p>\",\"fields\":{\"slug\":\"/2015-10-05---css-summary/\"}}],\"regular expression\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-04-05---regular-expression-1/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"正则表达式核心 若有多个字符串，其中一个字符串中包含部分内容，我们使用正则来进行匹配，匹配的结果到底什么？是包含匹配内容的那个字符串？还是只有匹配的内容？ Go Ahead…\",\"frontmatter\":{\"title\":\"正则表达式核心\",\"date\":\"2016-04-05\",\"tags\":[\"regular expression\"]},\"html\":\"<h1>正则表达式核心</h1>\\n<p>若有多个字符串，其中一个字符串中包含部分内容，我们使用正则来进行匹配，匹配的结果到底什么？是包含匹配内容的那个字符串？还是只有匹配的内容？</p>\\n<p>Go Ahead~</p>\\n<p>正则表达式的核心概念就是元字符，它一点也不复杂，掌握了元字符，就可以正则表达式的能力有所了解。</p>\\n<p>接下来的每一节，我都会介绍数个元字符，最终本文结束时，读者就会对正则表达式的核心元字符有大概的了解。</p>\\n<h2>从 hi, Hao 开始</h2>\\n<p><code>hi, Hao</code>这样一个字符串，如果使用正则表达式匹配到<code>hi</code>？这非常简单，我们使用<code>js</code>来作为实现语言：</p>\\n<pre><code class=\\\"language-js\\\">let p = /hi/;\\nlet s = `hi, HAO`;\\ns.match(p); // [\\\"hi\\\", index: 0, input: \\\"hi,Hao\\\"]\\n</code></pre>\\n<p>逐行分析：</p>\\n<ol>\\n<li>使用<code>/code/</code>这样的语法，告诉<code>js</code>解释引擎，这是一个正则表达式，其中的<code>hi</code>就是正则表达式的实际内容</li>\\n<li>声明赋值一个字符串</li>\\n<li>使用<code>match</code>方法匹配，它将返回一个数组，其中存放了与它找到的匹配文本有关的信息。该数组的第<code>0</code>个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本。除了这些常规的数组元素之外，返回的数组还含有两个对象属性。<code>index</code>属性声明的是匹配文本的起始字符在原字符串中的位置，<code>input</code>属性声明的是对原字符串的引用。</li>\\n</ol>\\n<p>上面太简单了，但如果遇到这样的情况呢？</p>\\n<pre><code class=\\\"language-js\\\">let s = `hi,this is Hao. hi, this is Liu.`;\\n</code></pre>\\n<p>这里面的<code>hi</code>，我全都要，该如何匹配？之前的正则表达式是否可行呢？</p>\\n<pre><code class=\\\"language-js\\\">s.match(/hi/) // [\\\"hi\\\", index: 0, input: \\\"hi,this is Hao. hi, this is Liu.\\\"]\\n</code></pre>\\n<p>很明显，没有用了，仍然只捕捉到一个结果。为了解决这个问题，我们引入全局标志<code>g</code>，使用<code>g</code>，<code>match</code>方法将执行全局检索，找到原字符串中所有匹配子字符串。若没有找到任何匹配的子串，则返回<code>null</code>。如果找到了一个或多个匹配子串，则返回一个数组。不过全局匹配返回的数组的内容与前者大不相同，它的数组元素中存放的是原字符串中所有的匹配子串，而且也没有<code>index</code>属性和<code>input</code>属性。</p>\\n<pre><code class=\\\"language-js\\\">s.match(/hi/g) // (4) [\\\"hi\\\", \\\"hi\\\", \\\"hi\\\", \\\"hi\\\"]\\n</code></pre>\\n<p>成功了。</p>\\n<p>挑剔的人来了，如果只想匹配到下面这个字符串最中间的<code>hi</code>呢？</p>\\n<pre><code class=\\\"language-js\\\">let s = `this is Hao. hi this is Liu.`;\\n</code></pre>\\n<p>我们这里就需要用正则表达式的核心内容，元字符了，直接看例子，</p>\\n<pre><code class=\\\"language-js\\\">s.match(/hi/) // [\\\"hi\\\", index: 1, input: \\\"this is Hao. hi this is Liu.\\\"]\\ns.match(/\\\\bhi\\\\b/) //[\\\"hi\\\", index: 13, input: \\\"this is Hao. hi this is Liu.\\\"]\\n</code></pre>\\n<p>逐行分析：</p>\\n<ol>\\n<li>第一行使用了老方法妄图匹配中间的<code>hi</code>，但在遇到索引位置<code>1</code>开始的<code>hi</code>时，就匹配完成了，老方法显然无法满足要求</li>\\n<li>第二种方法从结果上看匹配成功了，匹配到了索引位置<code>13</code>处开始的<code>hi</code>，我们分析一下这个正则表达式中有什么。抛除熟悉的<code>\\\\ hi \\\\</code>，我们发现了<code>hi</code>左右的<code>\\\\b \\\\b</code>，这便是元字符，<code>\\\\</code>用来告诉计算机这是元字符，区别于普通的字符串。<code>b</code>元字符可以匹配这样的位置，这个位置的前一个字符和后一个字符不全是字母、数字、下划线、汉字。分析一下会发现第一个<code>hi</code>在<code>this</code>中，很明显，子串<code>hi</code>的前后字符都是字母，不满足要求。到了索引为<code>13</code>出的<code>hi</code>，它的前后是空格，不是字母、数字、下划线或者汉字，<code>b</code>元字符要求<code>hi</code>的前一个字符和后一个字符不全是字母、数字、下划线、汉字。这里都是空格，这可高于要求的<code>不全是</code>，都已经<code>全都不是</code>了，当然满足了，匹配成功。</li>\\n</ol>\\n<table>\\n<thead>\\n<tr>\\n<th>元字符</th>\\n<th>作用</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>b</td>\\n<td>所匹配的位置，前一个字符和后一个字符不全是\\n<code>w</code>\\n(\\n<code>w</code>\\n用来匹配字母、数字、下划线、汉字)</td>\\n</tr>\\n</tbody>\\n</table>\\n<h2>.*元字符</h2>\\n<p>匹配<code>hi</code>还是容易的，但如果想匹配一大段内容呢？比如</p>\\n<pre><code class=\\\"language-js\\\">let s = `hi! .................... I'm Lucy! I may be a pink ostrich but I'm still a kid just like you! I love  tell jokes, laugh, sing, watch cartoons and learn! And I get to do all these things in class with Sr. Grace! She's my favorite teacher in the whole world. `;\\n</code></pre>\\n<p>上面的省略号代表非常多的内容。假如我想要匹配<code>hi</code>与<code>Lucy</code>连同它中间的内容呢？我总不能都放到正则表达式吧，那多丑！\\n我们这里又要使用元字符了</p>\\n<pre><code class=\\\"language-js\\\">s.match(/\\\\bhi\\\\b.*\\\\bLucy\\\\b/) //succ\\n</code></pre>\\n<p>这里面的有两三点要说明：</p>\\n<ol>\\n<li><code>.*</code>也算元字符？是的，这是两个元字符，只不过他们没有加<code>\\\\</code>而已。</li>\\n<li>为什么不加<code>\\\\</code>标志符？因为他们太常用了，干脆就省略<code>\\\\</code>了，反而专门要匹配字符串<code>.</code>与<code>*</code>的场合却很少，干脆将正则表达式与字符串的表示反一下，如果想要匹配<code>.</code>这个字符串，那么为它加上<code>\\\\</code>，即<code>\\\\.</code>，<code>\\\\*</code>也是同理。</li>\\n<li><code>.*</code>代表什么含义？请看下面的表格</li>\\n</ol>\\n<table>\\n<thead>\\n<tr>\\n<th>元字符</th>\\n<th>作用</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>.</td>\\n<td>匹配除了换行符之外的任何字符</td>\\n</tr>\\n<tr>\\n<td>*</td>\\n<td>用来指定这个元字符 * 前面的内容可以连续重复使用任意多次，可以使得整个表达式得到匹配</td>\\n</tr>\\n</tbody>\\n</table>\\n<p>看到这个表格你应该明了了，<code>.*</code>用来表示任何数量的字符，只要字符里边不包括换行，于是 \\\\bhi\\\\b.*\\\\bLucy\\\\b 就表示先有个单词<code>hi</code>，接着允许出现很多字符，除了换行，之后有一个单词<code>Lucy</code>。</p>\\n<h2>电话号码的匹配实例</h2>\\n<p><code>0\\\\d\\\\d\\\\d-\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d</code> 用来匹配<code>0</code>开头，之后3位数字加<code>-</code>，之后8位数字的电话号码。使用这么多的<code>\\\\d</code>是一件很让人上头的事情，可以使用这样的写法：<code>0\\\\d{3}-\\\\d{8}</code>。</p>\\n<table>\\n<thead>\\n<tr>\\n<th>元字符</th>\\n<th>作用</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>d</td>\\n<td>匹配一位数字,比如 0 ，1 ，2 等任意的一位数字</td>\\n</tr>\\n<tr>\\n<td>{n}</td>\\n<td>用来指定这个元字符\\n<code>*</code>\\n前面的内容可以连续重复使用任意多次，可以使得整个表达式得到匹配</td>\\n</tr>\\n</tbody>\\n</table>\\n<h2>其他常用元字符</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>元字符</th>\\n<th>作用</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>/s</td>\\n<td>匹配任意多的空白符</td>\\n</tr>\\n<tr>\\n<td>/w</td>\\n<td>代表着可用文字，包含字母，数字，下划线，汉字</td>\\n</tr>\\n<tr>\\n<td>/s</td>\\n<td>匹配任意多的空白符</td>\\n</tr>\\n<tr>\\n<td>+</td>\\n<td>与\\n<code>{n}</code>\\n、\\n<code>*</code>\\n类似，指定当前元字符前面的内容重复多次，\\n<code>+</code>\\n专指重复\\n<code>1</code>\\n次以上</td>\\n</tr>\\n</tbody>\\n</table>\\n<h2>番外</h2>\\n<p>现在好多内容在讲正则的时候都不注意区分哪些是核心内容，在很多环境下，编程语言会对正则做出拓展，引入了很多新符号，引入了很多的复杂度，对初学者不友好。下面推荐一些文章</p>\\n<ul>\\n<li>谷歌大牛的文章：<a href=\\\"http://blog.youxu.info/2009/03/05/ree1/\\\">编程珠玑番外篇-C.正则表达式精义-1</a></li>\\n<li>进阶：<a href=\\\"http://www.cppblog.com/vczh/archive/2014/01/19/205468.html\\\">跟vczh看实例学编译原理——零：序言</a></li>\\n<li>这是一个图形化的在线正则展示网页，可以用来测试正则：<a href=\\\"https://regexper.com/\\\">Regexper</a></li>\\n</ul>\",\"fields\":{\"slug\":\"/2016-04-05---regular-expression-1/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-04-06---regular-expression-2/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"正则表达式进阶 接上一篇内容，上一篇主要介绍了正则表达式的核心内容，非常的简单易懂，现在对核心内容进行拓展。 界定符 表示正则表达式的开始和结束，具体的由解析器决定 /[0-9]/ #[0-…\",\"frontmatter\":{\"title\":\"正则表达式进阶\",\"date\":\"2016-04-06\",\"tags\":[\"regular expression\"]},\"html\":\"<h1>正则表达式进阶</h1>\\n<p>接上一篇内容，上一篇主要介绍了正则表达式的核心内容，非常的简单易懂，现在对核心内容进行拓展。</p>\\n<h2>界定符</h2>\\n<p>表示正则表达式的开始和结束，具体的由解析器决定</p>\\n<ul>\\n<li><code>/[0-9]/</code></li>\\n<li><code>#[0-9]#</code></li>\\n</ul>\\n<h2>元字符</h2>\\n<p>元字符定义了原子的筛选方式，可以将某一类原子归类，并且给出缩写，简化正则：</p>\\n<ul>\\n<li><code>|</code>匹配两个或者多个分支</li>\\n<li><code>[]</code>中括号内部的任意一个原子</li>\\n<li><code>[^]</code>匹配除括号内部原子之外的任何字符</li>\\n</ul>\\n<h3>原子的筛选</h3>\\n<p>使用<code>[]</code>可以进行原子的筛选，代表或者的关系，<code>[^]</code>代表非的关系</p>\\n<ul>\\n<li><code>[Dd]uang</code></li>\\n<li><code>(D|d)uang</code></li>\\n</ul>\\n<p>这两种方法都可以匹配到想要的内容，但具体有什么区别呢？\\n请注意在<code>[]</code>中出现的，只能是单个原子，每个原子之间都是或的关系，而使用<code>|</code>元字符，两边可以由多个原子组成来进行匹配。</p>\\n<h3>原子集合</h3>\\n<p>之所以定义了原子集合，主要是为了用来简化书写，一般原子集合，都可以通过原子筛选的方式给出，除了换行符的原子:</p>\\n<ul>\\n<li><code>\\\\d</code>数字<code>[0-9]</code></li>\\n<li><code>\\\\D</code>非数字<code>[^0-9]</code></li>\\n<li><code>\\\\s</code>不可见原子<code>[\\\\f\\\\n\\\\r\\\\t]</code></li>\\n<li><code>\\\\S</code>可见的原子</li>\\n<li><code>\\\\w</code>数字字母下划线<code>[0-9a-zA-Z_]</code></li>\\n<li><code>\\\\W</code>任意一个非下划线，数字字母<code>[^0-9a-zA-Z_]</code></li>\\n</ul>\\n<h2>量词</h2>\\n<p>所谓量词，就是表示它前面的原子重复多少次</p>\\n<ul>\\n<li><code>{d}</code>重复<code>d</code>次</li>\\n<li><code>{d,}</code> 最少重复<code>d</code>次</li>\\n<li><code>{d,b}</code> 重复<code>d</code>到<code>b</code>次</li>\\n</ul>\\n<h3>量词集合</h3>\\n<p>参考原子集合，是为了简化筛选元素。量词集合的出现也是同样的道理</p>\\n<ul>\\n<li><code>{0,}</code> 最少重复<code>0</code>次，包含<code>0</code>次</li>\\n<li><code>{1,}</code> 最少重复<code>1</code>次，包含<code>1</code>次</li>\\n<li><code>{0,1}</code> 重复<code>0</code>次或者<code>1</code>次</li>\\n</ul>\\n<h3>修正模式</h3>\\n<ul>\\n<li><code>U</code>表示贪婪模式</li>\\n<li><code>i</code>忽略大小写，用在正则中</li>\\n<li><code>x</code>忽略正则中的空格，<code>tab</code>制表符</li>\\n</ul>\\n<h2>转义</h2>\\n<p>转译，当正则占用了需要的输入</p>\\n<ul>\\n<li><code>\\\\</code></li>\\n</ul>\",\"fields\":{\"slug\":\"/2016-04-06---regular-expression-2/\"}}],\"function\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-09-01----js-function-2/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"再探JS函数 函数是JS的核心概念，主要用来封装语句，封装单独的功能。 函数参数 函数不在意它本身到底接收多少参数，不关心最后会使用多少参数。因为函数只会接收一个数组，函数可以通过 arguments…\",\"frontmatter\":{\"title\":\"再探JS函数\",\"date\":\"2016-09-07\",\"tags\":[\"JS\",\"function\"]},\"html\":\"<h1>再探JS函数</h1>\\n<p>函数是JS的核心概念，主要用来封装语句，封装单独的功能。</p>\\n<h2>函数参数</h2>\\n<p>函数不在意它本身到底接收多少参数，不关心最后会使用多少参数。因为函数只会接收一个数组，函数可以通过<code>arguments</code>属性来访问这个参数数组。关于这个数组，他其实是个对象，如下:</p>\\n<pre><code class=\\\"language-js\\\">var a = function () {var b= 1; var c = 0} //a是一个函数\\ntypeof a.arguments  // Object\\n</code></pre>\\n<p>但是为什么又说它是数组呢，因为它本身很数组很像，可以通过方括号加数字的方法来访问具体的参数，同时还有数组对象有的<code>length</code>属性。一个有趣的例子：</p>\\n<pre><code class=\\\"language-js\\\">function a (){\\n  console.log(\\\"hello\\\" +　arguments[0] + arguments[1]);\\n}\\na(\\\"hao\\\",\\\"xiang\\\"); //hellohaoxiang\\n</code></pre>\\n<p>这样子依然是有效的，在函数执行的时候，通过<code>arguments</code>对象的<code>length</code>属性可以知道被传递的参数个数，还有个更有趣的例子，是关于<code>arguments</code>的同步性的：</p>\\n<pre><code class=\\\"language-js\\\">function doAdd (num1,num2){\\n  arguments[1]=10;\\n  alert(arguments[0] + num2);\\n  }\\n  doAdd(1,1); //11，arguments[1]和num2是同步的\\n</code></pre>\\n<p>参数就是局部变量，对于函数来说，传递参数是按值的，基本类型的很好理解，相当于变量的复制。对于引用类型来说，还需要留意到此时依然是按值传递的，这个值依然是指引用的内存地址值。证明方法：需要先创建一个对象，传递函数中，此时在函数内部修改对象的属性，此时内外是一致的，因为他们是一种的一个对象。但是此时如果将参数重新初始化为一个对象，那么也就是说此时参数已经指向另一个变量了，和之前的一切无关。</p>\\n<h2>函数相关属性</h2>\\n<p><code>arguments</code>属性有一个叫做<code>callee</code>的指针，这个指针指向拥有这个<code>arguments</code>对象的函数。主要用来解除耦合，下面是关于递归算法的例子</p>\\n<pre><code class=\\\"language-js\\\">function fac (num) {\\n    switch (num){\\n        case 1 :\\n        return 1;\\n        default: return num * arguments.callee(num-1);\\n    }\\n}\\n</code></pre>\\n<p>函数的另外一个内部属性是<code>this</code>对象，<code>this</code>引用的是函数据以执行的环境对象，<code>this</code>是包含它的函数作为方法被调用是所属的对象 = 包含它的函数 + 作为方法被调用时 + 所属的对象。</p>\\n<h2>函数的方法</h2>\\n<p>主要有<code>apply</code>,<code>call</code>与<code>bind</code></p>\\n<h3><code>apply()</code>与<code>call()</code>：</h3>\\n<p>表示在特定的作用域内调用函数，与<code>call()</code>的区别在于<code>call</code>在使用时必须指定参数。</p>\\n<h2><code>bind()</code></h2>\\n<p>这个方法可以用来创建一个新的实例，实例的<code>this</code>值会被绑定到传给<code>bind()</code>的值上</p>\\n<h2>细碎的小点</h2>\\n<ul>\\n<li><code>return</code>语句，一旦<code>return</code>，后续的语句不会继续执行了，不加<code>return</code>的话，函数默认的返回值是<code>undefined</code>。</li>\\n</ul>\",\"fields\":{\"slug\":\"/2016-09-01----js-function-2/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-08-26---js-function-1/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"初探JS函数 有关函数相关的话题在网上讨论的并不够多，因为它比较复杂，这也是为什么现在网上会存在如此多的误解。 在这片文章里面，我会试着去总结有关函数的好的，坏的，丑陋的一面。 函数表达式 VS. 函数声明 在 ECMAScript…\",\"frontmatter\":{\"title\":\"初探JS函数\",\"date\":\"2016-08-26\",\"tags\":[\"JS\",\"function\"]},\"html\":\"<h1>初探JS函数</h1>\\n<p>有关函数相关的话题在网上讨论的并不够多，因为它比较复杂，这也是为什么现在网上会存在如此多的误解。 在这片文章里面，我会试着去总结有关函数的好的，坏的，丑陋的一面。</p>\\n<h2>函数表达式 VS. 函数声明</h2>\\n<p>在 ECMAScript 中，如果需要使用函数，最常用的两种方法就是通过函数表达式和函数声明。掌握它们区别非常重要，因为在JS 中两者的执行是有差别的，可惜很不爽，至少在看来， 两者之间的差别可以说是相当混乱，只有一件事是 ECMA 规范中讲清楚的—-函数声明必须要有一个函数名(规范中称为 identifier (标识)），函数表达式可以忽略函数名：</p>\\n<pre><code class=\\\"language-js\\\">// FunctionDeclaration :\\nfunction Identifier ( FormalParameterList &#x3C;opt> ){ FunctionBody }\\n// FunctionExpression :\\nfunction Identifier&#x3C;opt> ( FormalParameterList &#x3C;opt> ){ FunctionBody }\\n</code></pre>\\n<p>我们可以仔细瞧瞧，当忽略函数名时，只能是函数表达式，这个是没有争议的，因为规范中有说，函数表达式可以忽略函数名，但是如果加上函数名呢？这两种方式一模一样，我们别人说这是一个函数声明，还是一个函数表达式呢？</p>\\n<h2>区分函数表达式和函数声明</h2>\\n<p>看起来 ECMAScript 判断两者的不同是基于整个上下文的，如果<code>function foo () {}</code>是一行语句的某个部分，比如说赋值表达式的一部分，它应该是一个函数表达式，可以理解为当前赋值表达式有函数的参与。 如果<code>function foo () {}</code>被包含在一个函数体内或者直接暴露在最上层的作用域下，它就是一个函数声明。</p>\\n<pre><code class=\\\"language-js\\\">function foo(){} // 声明，因为它暴露在全局作用域下\\nvar bar = function foo () {} // 表达式，因为它是构成赋值表达式的一部分\\n new function bar () {} // 表达式，因为它是 new 语句的一部分\\n (funciton () {\\n     function bar () {} // 声明，因为它在函数体内\\n })();\\n</code></pre>\\n<p>上面的例子有个需要留意的地方，(function () {})这个函数应该算作哪一种。可以明确的说它是一个函数表达式，因为前后的两个()括号。两个括号组成一个分组运算符，而分组运算符可以包含表达式的，所以按照上面的说明，它是一部分，是一个函数表达式(注意区分编程中的语句和表达式，参考文章<a href=\\\"http://www.2ality.com/2012/09/expressions-vs-statements.html\\\">http://www.2ality.com/2012/09/expressions-vs-statements.html</a>。</p>\\n<p>区分清楚之后，来看他们之间的不同，首先在其他语句还没有执行之前，函数声明将会先被解析和执行。即便它的位置在整个页面资源的最底部，它会被在作用域中出现的时间将会先于其他的任何表达式。下面的例子演示了fn 函数声明的位置靠后，但是依然可以在声明的位置之前被调用。</p>\\n<pre><code class=\\\"language-js\\\">alert(fn());\\nfunction fn () {\\nreturn \\\"hello world~\\\"\\n}\\n</code></pre>\\n<p>另外一个绝对需要注意的特点，不要在条件语句声明函数，在不同的环境下，会有不同的处理结果，所以当遇到要依据不同条件来新建函数时，一定要使用函数表达式代替，看下面的例子：</p>\\n<pre><code class=\\\"language-js\\\">// 绝对不要这样做，由于函数声明会在其他语句没有执行之前就声明完毕，所以这里的处理逻辑比较混乱\\n// 某些浏览器会直接使用第一个声明，返回 'first'\\n// 某些会使用第二个声明 'second'\\nif (true) {\\n  function foo() {\\n    return 'first';\\n  }\\n}\\nelse {\\n  function foo() {\\n    return 'second';\\n  }\\n}\\nfoo();\\n// 当一定需要依据不同情况创建函数时，使用函数表达式的方法来代替\\nvar foo;\\nif (true) {\\n  foo = function() {\\n    return 'first';\\n  };\\n}\\nelse {\\n  foo = function() {\\n    return 'second';\\n  };\\n}\\nfoo();\\n</code></pre>\",\"fields\":{\"slug\":\"/2016-08-26---js-function-1/\"}}],\"Linux\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-06-03---shadowsocks-install/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"ShadowSocks 安装记录 这里使用的是  ubuntu 14.04 ,是我比较喜欢的一个系统。\\n首先更新  apt  源，保证获取最新的软件 之后安装  python  相关依赖， pip  包管理器，可能是类似  npm  的一种吧，没有细致研究过 通过  pip…\",\"frontmatter\":{\"title\":\"ShadowSocks 安装记录\",\"date\":\"2016-09-01\",\"tags\":[\"Linux\",\"shadowsocks\"]},\"html\":\"<h1>ShadowSocks 安装记录</h1>\\n<p>这里使用的是 <code>ubuntu 14.04</code>,是我比较喜欢的一个系统。\\n首先更新 <code>apt</code> 源，保证获取最新的软件</p>\\n<pre><code class=\\\"language-bash\\\">sudo apt-get update\\n</code></pre>\\n<p>之后安装 <code>python</code> 相关依赖，<code>pip</code> 包管理器，可能是类似 <code>npm</code> 的一种吧，没有细致研究过</p>\\n<pre><code class=\\\"language-bash\\\">sudo apt-get install python-gevent python-pip\\n</code></pre>\\n<p>通过 <code>pip</code> 安装 <code>ShadowSocks</code></p>\\n<pre><code class=\\\"language-bash\\\">sudo pip install shadowsocks\\napt-get install python-m2crypto\\n</code></pre>\\n<p>配置 <code>ShadowSocks</code> 的配置文件 <code>vim /etc/shadowsocks.json</code></p>\\n<pre><code class=\\\"language-bash\\\">{\\n    \\\"server\\\":\\\"0.0.0.0\\\",\\n    \\\"server_port\\\":8388,\\n    \\\"local_port\\\":1080,\\n    \\\"password\\\":\\\"password\\\",\\n    \\\"timeout\\\":600,\\n    \\\"method\\\":\\\"aes-256-cfb\\\"\\n}\\n</code></pre>\\n<p><code>server</code> 表示当前服务器的 <code>ip</code> 地址，<code>password</code> 更换成自己需要设置的密码</p>\\n<p>切换到 <code>root</code> 用户\\n之后启动 <code>shadowsocks</code></p>\\n<pre><code class=\\\"language-bash\\\">su -\\nssserver -c /etc/shadowsocks.json -d start\\nssserver -c /etc/shadowsocks.json -d stop\\n</code></pre>\\n<p>参考资料：\\n<a href=\\\"https://github.com/iMeiji/shadowsocks_install/wiki\\\">https://github.com/iMeiji/shadowsocks_install/wiki</a></p>\",\"fields\":{\"slug\":\"/2016-06-03---shadowsocks-install/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2017-01-22---tmux-operation/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"tmux基本操作 电脑换回了win10系统，使用bash on windows进行开发，有个问题一直很困扰。\\n在windows系统下面，少见非常优秀的，类似iTerm2那样的终端软件。使用cmder对于bash…\",\"frontmatter\":{\"title\":\"tmux日常操作\",\"date\":\"2017-01-22\",\"tags\":[\"Tmux\",\"Linux\"]},\"html\":\"<h1>tmux基本操作</h1>\\n<p>电脑换回了win10系统，使用bash on windows进行开发，有个问题一直很困扰。\\n在windows系统下面，少见非常优秀的，类似iTerm2那样的终端软件。使用cmder对于bash的美化确实起到了很大的作用，但是对屏幕的管理依然不方便。最近留意到了tmux这款终端复用工具，简单使用后，发现它的确非常棒，给我带来了不少的便利。</p>\\n<h2>Session</h2>\\n<p>创建一个Session，默认情况下，当在shell中输入<code>tmux</code>时，就会自动创建一个名称为<code>0</code>的Session</p>\\n<pre><code class=\\\"language-bash\\\">#　创建Session\\ntmux\\n# 查看当前建立的Session，使用下面两个命令\\ntmux list-session\\n# 缩写\\ntmux ls\\n0: 1 windows (created Sat Jan 21 11:27:33 2017) [55x35]\\n# 创建一个指定名称的Session\\ntmux new -s $name\\n# 使用t参数关闭指定的Session\\ntmux kill-session -t $name\\n# 将指定的Session放置到后台中\\ntmux detach -t  $name\\n# 加载处于在后台中的Session\\ntmux attach-session -t $name\\n# 完全退出，关闭所有的Session\\ntmux kill-server\\n</code></pre>\\n<h2>Window</h2>\\n<p>在Session之下，可以开设很多得当Window，其实当我们创建一个Session时，就已经会默认创建一个Window了。</p>\\n<p>在Window中，可以使用很多命令进行闪转腾挪了，默认调用命令的快捷键是<code>Ctrl-b</code>，看下面的例子：</p>\\n<pre><code class=\\\"language-bash\\\">#Ctrl-b &#x3C;command>\\n# 列出当前所有的Window\\nCtrl-b w \\n(0)  0: ~  \\\"DESKTOP-IE8ULOJ\\\"\\n(1)  1: ~  \\\"DESKTOP-IE8ULOJ\\\"\\n(2)  2: ~- \\\"DESKTOP-IE8ULOJ\\\"\\n(3)  3: ~* \\\"DESKTOP-IE8ULOJ\\\"\\n# 创建一个Wind ow （create）\\nCtrl-b c\\n# 切换到下一个Window （next）\\nCtrl-b n\\n# 切换到上一个Window（previous）\\nCtrl-b p\\n# 切换到指定序号的Window\\nCtrl-b [0-9]\\n# 重命名当前窗口的名称\\nCtrl-b ，\\n# 关闭当前窗口\\nCtrl-b &#x26;\\n</code></pre>\\n<h2>Pane</h2>\\n<p>在Window层级的切换时全屏的，可以继续分，往下的这个层级叫做Pane</p>\\n<pre><code class=\\\"language-bash\\\"># 垂直分割\\nCtrl-b %\\n# 水平分割\\nCtrl-b “”\\n# 在窗口之间切换\\nCtrl-b o\\n# 按照指定的方向切换\\nCtrl-b 方向键\\n# tmux默认有几种Pane的布局方式，这个命令用来在默认的布局方式中切换\\nCtrl-b 空格\\n# 关闭当前Pane\\nCtrl-b x\\n</code></pre>\",\"fields\":{\"slug\":\"/2017-01-22---tmux-operation/\"}}],\"shadowsocks\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-06-03---shadowsocks-install/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"ShadowSocks 安装记录 这里使用的是  ubuntu 14.04 ,是我比较喜欢的一个系统。\\n首先更新  apt  源，保证获取最新的软件 之后安装  python  相关依赖， pip  包管理器，可能是类似  npm  的一种吧，没有细致研究过 通过  pip…\",\"frontmatter\":{\"title\":\"ShadowSocks 安装记录\",\"date\":\"2016-09-01\",\"tags\":[\"Linux\",\"shadowsocks\"]},\"html\":\"<h1>ShadowSocks 安装记录</h1>\\n<p>这里使用的是 <code>ubuntu 14.04</code>,是我比较喜欢的一个系统。\\n首先更新 <code>apt</code> 源，保证获取最新的软件</p>\\n<pre><code class=\\\"language-bash\\\">sudo apt-get update\\n</code></pre>\\n<p>之后安装 <code>python</code> 相关依赖，<code>pip</code> 包管理器，可能是类似 <code>npm</code> 的一种吧，没有细致研究过</p>\\n<pre><code class=\\\"language-bash\\\">sudo apt-get install python-gevent python-pip\\n</code></pre>\\n<p>通过 <code>pip</code> 安装 <code>ShadowSocks</code></p>\\n<pre><code class=\\\"language-bash\\\">sudo pip install shadowsocks\\napt-get install python-m2crypto\\n</code></pre>\\n<p>配置 <code>ShadowSocks</code> 的配置文件 <code>vim /etc/shadowsocks.json</code></p>\\n<pre><code class=\\\"language-bash\\\">{\\n    \\\"server\\\":\\\"0.0.0.0\\\",\\n    \\\"server_port\\\":8388,\\n    \\\"local_port\\\":1080,\\n    \\\"password\\\":\\\"password\\\",\\n    \\\"timeout\\\":600,\\n    \\\"method\\\":\\\"aes-256-cfb\\\"\\n}\\n</code></pre>\\n<p><code>server</code> 表示当前服务器的 <code>ip</code> 地址，<code>password</code> 更换成自己需要设置的密码</p>\\n<p>切换到 <code>root</code> 用户\\n之后启动 <code>shadowsocks</code></p>\\n<pre><code class=\\\"language-bash\\\">su -\\nssserver -c /etc/shadowsocks.json -d start\\nssserver -c /etc/shadowsocks.json -d stop\\n</code></pre>\\n<p>参考资料：\\n<a href=\\\"https://github.com/iMeiji/shadowsocks_install/wiki\\\">https://github.com/iMeiji/shadowsocks_install/wiki</a></p>\",\"fields\":{\"slug\":\"/2016-06-03---shadowsocks-install/\"}}],\"ML\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2017-03-10---knn-2/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"机器学习之k-NN算法实战(二) 回顾上文，我们介绍了k-NN算法的原理，以及实例数据的格式，如何加载。万事俱备，下文我们来介绍k-NN算法的代码实现。 首先从store中取出样本数据，存到局部变量中 之后我们利用这些数据来进行k-NN…\",\"frontmatter\":{\"title\":\"机器学习之k-NN算法实战(二)\",\"date\":\"2017-03-10\",\"tags\":[\"ML\",\"KNN\"]},\"html\":\"<h1>机器学习之k-NN算法实战(二)</h1>\\n<p>回顾上文，我们介绍了k-NN算法的原理，以及实例数据的格式，如何加载。万事俱备，下文我们来介绍k-NN算法的代码实现。</p>\\n<p>首先从store中取出样本数据，存到局部变量中</p>\\n<pre><code class=\\\"language-py\\\">data_store = parse_data()\\n# 测试样本向量\\ntest_vectors = data_store[\\\"test_set\\\"][\\\"vectors\\\"]\\n# 测试样本的标签\\ntest_labels = data_store[\\\"test_set\\\"][\\\"labels\\\"]\\n# 训练样本的标签\\ntrain_vectors_labels = data_store[\\\"train_set\\\"][\\\"labels\\\"]\\n# 训练样本向量\\ntrain_vectors_mat = data_store[\\\"train_set\\\"][\\\"vectors\\\"]\\n</code></pre>\\n<p>之后我们利用这些数据来进行k-NN分类</p>\\n<pre><code class=\\\"language-py\\\">def classify(test_data_vector, training_data_mat, k):\\n    # 复制向量成矩阵\\n    test_data_mat = np.tile(test_data_vector, (training_data_mat.shape[0], 1))\\n    # 两个矩阵求内部向量的欧氏距离\\n    diff = test_data_mat - training_data_mat\\n    euclidean_dis = ((diff**2).sum(axis=1)) ** 0.5\\n    # 排序\\n    index_sorted = euclidean_dis.argsort()\\n    return index_sorted[:k]\\n</code></pre>\\n<p>上面的函数，我们需要的参数为测试向量，训练向量集，以及K值。我们将待测试的向量铺成和训练集相同shape的矩阵，之后直接求欧氏距离，按照预设去k个离被测试向量最近的训练向量，排序。</p>\\n<p>除了进行排序，我们还需要测试错误数据的占比，得出结论，这样才可以判断算法的优劣。</p>\\n<pre><code class=\\\"language-py\\\">def cal_vote(nearest_index, label, train_vectors_labels):\\n    # 统计错误的票数\\n    error_count = 0.0\\n    for i in range(len(nearest_index)):\\n        index = nearest_index[i]\\n        if train_vectors_labels[index] != label:\\n            error_count += 1\\n    # 错误数量过半时\\n    if error_count >= math.ceil(len(nearest_index)/2):\\n        return True\\n    else:\\n        return False\\n</code></pre>\\n<p>cal<em>vote函数接受三个参数，nearest</em>index是距离待测点最近的几个向量的索引，正确label，测试的label。之后计算投票，这里按照少数服从多数，有时候还可以按照距离的权重为各个向量加权。\\n之后我们调用上文的函数，代码如下</p>\\n<pre><code class=\\\"language-py\\\"># 分类错误的总数\\nsum_error_count = 0.0\\nfor i in range(len(test_vectors)):\\n    nearest_index = classify(test_vectors[i], train_vectors_mat, K)\\n    result = cal_vote(nearest_index, test_labels[i], train_vectors_labels)\\n    if not result:\\n        sum_error_count += 1\\n# 输出信息\\nprint(\\\"\\\\n当前位 k-NN 算法,k值为：{0}\\\".format(K))\\nprint(\\\"\\\\n分类结束，分类器分类总错误数为：{0}\\\".format(sum_error_count))\\nprint(\\\"\\\\n分类器分类错误率为：{0}%\\\".format((sum_error_count / len(train_vectors_labels))*100))\\n# 这里的k值设置为20，k值不同经常会影响分类器的效果，k=20时分类器在当前样本上，效果还不错\\n</code></pre>\\n<p>以上是算法部分，代码文件在<a href=\\\"https://github.com/getcha22/Machine-Learning/blob/master/k-NN/k-NN.py\\\">GITHUB</a>仓库中也存有备份,大家可以直接查看。</p>\\n<h2>总结</h2>\\n<p>k-NN算法的原理和实战代码部分见上文，接着我们来看看这个算法的优缺点，试用条件。</p>\\n<p>优点：</p>\\n<ul>\\n<li>简单明了，粗暴快速。这个是肯定的，核心原理就是计算两个向量的某种距离。</li>\\n<li>准确率尚可，对于一些基础的分类任务，它非常适合</li>\\n</ul>\\n<p>缺点：</p>\\n<ul>\\n<li>性能较弱，k-NN算法是懒惰学习方法，它是根据所给训练样本构造的分类器，是将所有训练样本首先存储起来，当要进行分类时，就直接进行计算处理。时间复杂度和空间复杂度都较高。</li>\\n<li>K值难以有一个确值，需要不断试。</li>\\n<li>对于非数值型的样本以及离散型的样本，我们需要对其进行数值化和连续化，比如红黄蓝等等。</li>\\n</ul>\",\"fields\":{\"slug\":\"/2017-03-10---knn-2/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2017-03-04---knn-1/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"机器学习之k-NN算法实战(一) 下文会介绍机器学习的k-NN算法，首先大致介绍k-NN算法的原理，之后我们会通过识别手写体数字这个小项目，来讲解k-NN分类算法的代码实现。 k-NN算法原理 所谓k-NN…\",\"frontmatter\":{\"title\":\"机器学习之k-NN算法实战(一)\",\"date\":\"2017-03-04\",\"tags\":[\"ML\",\"KNN\"]},\"html\":\"<h1>机器学习之k-NN算法实战(一)</h1>\\n<p>下文会介绍机器学习的k-NN算法，首先大致介绍k-NN算法的原理，之后我们会通过识别手写体数字这个小项目，来讲解k-NN分类算法的代码实现。</p>\\n<h2>k-NN算法原理</h2>\\n<p>所谓k-NN算法，全名为是一种分类算法，它属于监督式算法，也就是说对于这个算法，必须提前对数据打标签，否则无法完成分类。其次，k-NN又被人们称为是“懒汉”算法，或者说“惰性学习”，这是因为k-NN并不会像神经网络，线性回归那样直接训练出一个模型来，下文会逐步介绍。</p>\\n<p>使用k-NN算法进行分类，输入一个未知分类的测试数据，通过计算其与已知分类数据之间的某种距离，之后从训练数据中抽离出距离测试数据较近的样本，一一查看其分类，再进行多数表决，即可估算出测试数据的分类。\\n下面举个例子：</p>\\n<p><img src=\\\"\\\" alt=\\\"k-NN图例\\\"></p>\\n<p>绿圆是我们需要进行分类的测试数据，为了确定它的分类，我们可以通过欧式距离公式计算它和整个空间上所有样本的距离。按照我们预先设置的K值，找到离它最近的K个样本，上图我们假设了K值为3，我们发现实线圆中有三个训练样本与测试样本最接近，分别为两个红三角，一个蓝方块。于是我们推算出这个绿圆的分类与红三角相同。</p>\\n<h2>获取数据</h2>\\n<p>下面我们通过识别手写体数据这个实例来进行说明。手写体数字，就是下面图片展示的数据，他们没有完全统一的规则，我们需要让计算机在数据中发现规律，帮助我们识别新的手写体数字是几。</p>\\n<p><img src=\\\"\\\" alt=\\\"手写体数字\\\"></p>\\n<p>首先我们获取训练数据，还有测试数据。我们可以google MNIST这个关键字，之后从上面下载已经打好标签的数据，也可以直接从我的<a href=\\\"https://github.com/getcha22/Machine-Learning/tree/master/k-NN\\\">GITHUB仓库</a>里面直接复制粘贴，毕竟我们学习的目标是算法。</p>\\n<p>下面我们看看这些数据：</p>\\n<p><img src=\\\"\\\" alt=\\\"手写体数字1\\\">\\n<img src=\\\"\\\" alt=\\\"手写体数字2\\\"></p>\\n<p>每行数据会构成一个样本，训练集共有100个这样的样本，每个样本第一列是该样本的标签(见图一)。通过0-255表达某个像素的灰度值，0表示纯黑色，而255表示白色，其他值介于两者之间。\\n好，解释清楚样本的格式，我们现在需要加这些数据引入代码中，这样才可以对他们操作：</p>\\n<pre><code class=\\\"language-py\\\">    \\ndef parse_data():\\n    file_names = [\\n        'MNIST_data/mnist_train_100.csv',\\n        'MNIST_data/mnist_test_10.csv'\\n    ]\\n    # 整个存入dict，方便传递\\n    store = {}\\n    for file_name in range(2):\\n        # 拼接 dict 的 key 值\\n        type = file_names[file_name].split('_')[2] + '_set'\\n        labels = []\\n        vectors = []\\n        file = open(file_names[file_name])\\n        content = file.readlines()\\n        # 截取 str 中的 label， 将剩余部分转换成 ndarray，后续求距离会更高效\\n        for line in content:\\n            label = line[0]\\n            vector = line[2:-3].split(',')\\n            if (label and vector):\\n                labels.append(label)\\n                vectors.append(vector)\\n        vectors = np.array(vectors,dtype=float)\\n        store[type] = {\\n            \\\"labels\\\": labels,\\n            \\\"vectors\\\": vectors\\n        }\\n    return store\\n</code></pre>\\n<p>parse_data这个函数用来从存放数据的目录中加载数据，训练集中有100个样本，测试集中有10个测试样本，读取成功之后，将样本分类整理好，存放成dict格式，方便之后使用。\\n加载数据这个步骤完成了，接着我们就要进行分类代码的编写，请见下篇。</p>\",\"fields\":{\"slug\":\"/2017-03-04---knn-1/\"}}],\"KNN\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2017-03-10---knn-2/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"机器学习之k-NN算法实战(二) 回顾上文，我们介绍了k-NN算法的原理，以及实例数据的格式，如何加载。万事俱备，下文我们来介绍k-NN算法的代码实现。 首先从store中取出样本数据，存到局部变量中 之后我们利用这些数据来进行k-NN…\",\"frontmatter\":{\"title\":\"机器学习之k-NN算法实战(二)\",\"date\":\"2017-03-10\",\"tags\":[\"ML\",\"KNN\"]},\"html\":\"<h1>机器学习之k-NN算法实战(二)</h1>\\n<p>回顾上文，我们介绍了k-NN算法的原理，以及实例数据的格式，如何加载。万事俱备，下文我们来介绍k-NN算法的代码实现。</p>\\n<p>首先从store中取出样本数据，存到局部变量中</p>\\n<pre><code class=\\\"language-py\\\">data_store = parse_data()\\n# 测试样本向量\\ntest_vectors = data_store[\\\"test_set\\\"][\\\"vectors\\\"]\\n# 测试样本的标签\\ntest_labels = data_store[\\\"test_set\\\"][\\\"labels\\\"]\\n# 训练样本的标签\\ntrain_vectors_labels = data_store[\\\"train_set\\\"][\\\"labels\\\"]\\n# 训练样本向量\\ntrain_vectors_mat = data_store[\\\"train_set\\\"][\\\"vectors\\\"]\\n</code></pre>\\n<p>之后我们利用这些数据来进行k-NN分类</p>\\n<pre><code class=\\\"language-py\\\">def classify(test_data_vector, training_data_mat, k):\\n    # 复制向量成矩阵\\n    test_data_mat = np.tile(test_data_vector, (training_data_mat.shape[0], 1))\\n    # 两个矩阵求内部向量的欧氏距离\\n    diff = test_data_mat - training_data_mat\\n    euclidean_dis = ((diff**2).sum(axis=1)) ** 0.5\\n    # 排序\\n    index_sorted = euclidean_dis.argsort()\\n    return index_sorted[:k]\\n</code></pre>\\n<p>上面的函数，我们需要的参数为测试向量，训练向量集，以及K值。我们将待测试的向量铺成和训练集相同shape的矩阵，之后直接求欧氏距离，按照预设去k个离被测试向量最近的训练向量，排序。</p>\\n<p>除了进行排序，我们还需要测试错误数据的占比，得出结论，这样才可以判断算法的优劣。</p>\\n<pre><code class=\\\"language-py\\\">def cal_vote(nearest_index, label, train_vectors_labels):\\n    # 统计错误的票数\\n    error_count = 0.0\\n    for i in range(len(nearest_index)):\\n        index = nearest_index[i]\\n        if train_vectors_labels[index] != label:\\n            error_count += 1\\n    # 错误数量过半时\\n    if error_count >= math.ceil(len(nearest_index)/2):\\n        return True\\n    else:\\n        return False\\n</code></pre>\\n<p>cal<em>vote函数接受三个参数，nearest</em>index是距离待测点最近的几个向量的索引，正确label，测试的label。之后计算投票，这里按照少数服从多数，有时候还可以按照距离的权重为各个向量加权。\\n之后我们调用上文的函数，代码如下</p>\\n<pre><code class=\\\"language-py\\\"># 分类错误的总数\\nsum_error_count = 0.0\\nfor i in range(len(test_vectors)):\\n    nearest_index = classify(test_vectors[i], train_vectors_mat, K)\\n    result = cal_vote(nearest_index, test_labels[i], train_vectors_labels)\\n    if not result:\\n        sum_error_count += 1\\n# 输出信息\\nprint(\\\"\\\\n当前位 k-NN 算法,k值为：{0}\\\".format(K))\\nprint(\\\"\\\\n分类结束，分类器分类总错误数为：{0}\\\".format(sum_error_count))\\nprint(\\\"\\\\n分类器分类错误率为：{0}%\\\".format((sum_error_count / len(train_vectors_labels))*100))\\n# 这里的k值设置为20，k值不同经常会影响分类器的效果，k=20时分类器在当前样本上，效果还不错\\n</code></pre>\\n<p>以上是算法部分，代码文件在<a href=\\\"https://github.com/getcha22/Machine-Learning/blob/master/k-NN/k-NN.py\\\">GITHUB</a>仓库中也存有备份,大家可以直接查看。</p>\\n<h2>总结</h2>\\n<p>k-NN算法的原理和实战代码部分见上文，接着我们来看看这个算法的优缺点，试用条件。</p>\\n<p>优点：</p>\\n<ul>\\n<li>简单明了，粗暴快速。这个是肯定的，核心原理就是计算两个向量的某种距离。</li>\\n<li>准确率尚可，对于一些基础的分类任务，它非常适合</li>\\n</ul>\\n<p>缺点：</p>\\n<ul>\\n<li>性能较弱，k-NN算法是懒惰学习方法，它是根据所给训练样本构造的分类器，是将所有训练样本首先存储起来，当要进行分类时，就直接进行计算处理。时间复杂度和空间复杂度都较高。</li>\\n<li>K值难以有一个确值，需要不断试。</li>\\n<li>对于非数值型的样本以及离散型的样本，我们需要对其进行数值化和连续化，比如红黄蓝等等。</li>\\n</ul>\",\"fields\":{\"slug\":\"/2017-03-10---knn-2/\"}},{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2017-03-04---knn-1/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"机器学习之k-NN算法实战(一) 下文会介绍机器学习的k-NN算法，首先大致介绍k-NN算法的原理，之后我们会通过识别手写体数字这个小项目，来讲解k-NN分类算法的代码实现。 k-NN算法原理 所谓k-NN…\",\"frontmatter\":{\"title\":\"机器学习之k-NN算法实战(一)\",\"date\":\"2017-03-04\",\"tags\":[\"ML\",\"KNN\"]},\"html\":\"<h1>机器学习之k-NN算法实战(一)</h1>\\n<p>下文会介绍机器学习的k-NN算法，首先大致介绍k-NN算法的原理，之后我们会通过识别手写体数字这个小项目，来讲解k-NN分类算法的代码实现。</p>\\n<h2>k-NN算法原理</h2>\\n<p>所谓k-NN算法，全名为是一种分类算法，它属于监督式算法，也就是说对于这个算法，必须提前对数据打标签，否则无法完成分类。其次，k-NN又被人们称为是“懒汉”算法，或者说“惰性学习”，这是因为k-NN并不会像神经网络，线性回归那样直接训练出一个模型来，下文会逐步介绍。</p>\\n<p>使用k-NN算法进行分类，输入一个未知分类的测试数据，通过计算其与已知分类数据之间的某种距离，之后从训练数据中抽离出距离测试数据较近的样本，一一查看其分类，再进行多数表决，即可估算出测试数据的分类。\\n下面举个例子：</p>\\n<p><img src=\\\"\\\" alt=\\\"k-NN图例\\\"></p>\\n<p>绿圆是我们需要进行分类的测试数据，为了确定它的分类，我们可以通过欧式距离公式计算它和整个空间上所有样本的距离。按照我们预先设置的K值，找到离它最近的K个样本，上图我们假设了K值为3，我们发现实线圆中有三个训练样本与测试样本最接近，分别为两个红三角，一个蓝方块。于是我们推算出这个绿圆的分类与红三角相同。</p>\\n<h2>获取数据</h2>\\n<p>下面我们通过识别手写体数据这个实例来进行说明。手写体数字，就是下面图片展示的数据，他们没有完全统一的规则，我们需要让计算机在数据中发现规律，帮助我们识别新的手写体数字是几。</p>\\n<p><img src=\\\"\\\" alt=\\\"手写体数字\\\"></p>\\n<p>首先我们获取训练数据，还有测试数据。我们可以google MNIST这个关键字，之后从上面下载已经打好标签的数据，也可以直接从我的<a href=\\\"https://github.com/getcha22/Machine-Learning/tree/master/k-NN\\\">GITHUB仓库</a>里面直接复制粘贴，毕竟我们学习的目标是算法。</p>\\n<p>下面我们看看这些数据：</p>\\n<p><img src=\\\"\\\" alt=\\\"手写体数字1\\\">\\n<img src=\\\"\\\" alt=\\\"手写体数字2\\\"></p>\\n<p>每行数据会构成一个样本，训练集共有100个这样的样本，每个样本第一列是该样本的标签(见图一)。通过0-255表达某个像素的灰度值，0表示纯黑色，而255表示白色，其他值介于两者之间。\\n好，解释清楚样本的格式，我们现在需要加这些数据引入代码中，这样才可以对他们操作：</p>\\n<pre><code class=\\\"language-py\\\">    \\ndef parse_data():\\n    file_names = [\\n        'MNIST_data/mnist_train_100.csv',\\n        'MNIST_data/mnist_test_10.csv'\\n    ]\\n    # 整个存入dict，方便传递\\n    store = {}\\n    for file_name in range(2):\\n        # 拼接 dict 的 key 值\\n        type = file_names[file_name].split('_')[2] + '_set'\\n        labels = []\\n        vectors = []\\n        file = open(file_names[file_name])\\n        content = file.readlines()\\n        # 截取 str 中的 label， 将剩余部分转换成 ndarray，后续求距离会更高效\\n        for line in content:\\n            label = line[0]\\n            vector = line[2:-3].split(',')\\n            if (label and vector):\\n                labels.append(label)\\n                vectors.append(vector)\\n        vectors = np.array(vectors,dtype=float)\\n        store[type] = {\\n            \\\"labels\\\": labels,\\n            \\\"vectors\\\": vectors\\n        }\\n    return store\\n</code></pre>\\n<p>parse_data这个函数用来从存放数据的目录中加载数据，训练集中有100个样本，测试集中有10个测试样本，读取成功之后，将样本分类整理好，存放成dict格式，方便之后使用。\\n加载数据这个步骤完成了，接着我们就要进行分类代码的编写，请见下篇。</p>\",\"fields\":{\"slug\":\"/2017-03-04---knn-1/\"}}],\"Node\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-10-01---node-file-system/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"Node文件系统 Node 通过封装基本的 POSIX 函数来提供文件系统，使用 require('fs…\",\"frontmatter\":{\"title\":\"Node文件系统\",\"date\":\"2016-10-01\",\"tags\":[\"Node\",\"JS\"]},\"html\":\"<h1>Node文件系统</h1>\\n<p><code>Node</code>通过封装基本的<code>POSIX</code>函数来提供文件系统，使用<code>require('fs')</code>来使用这个模块，所有与文件相关的方法，都提供了异步和同步的形式。 异步的方法通常会将一个可选的回调函数作为最后一个参数，回调函数的第一个参数通常留给意外情况，如果操作是成功的，第一个参数将是<code>null</code>或者<code>undeefined</code>。 使用同步方法，对于任何意外都会即时抛出，可以使用<code>try/catch</code>语句来处理意外情况，或者让错误时间向上冒泡。 下面是一个有关异步方法的基本例子：</p>\\n<pre><code class=\\\"language-js\\\">const fs = require('fs');\\nfs.unlink('/tmp/hello', (err) => {\\n  if (err) throw err;\\n  console.log('sucessfully deleted /tmp/hello');\\n}\\n</code></pre>\\n<p>再跟着一个同步的例子：</p>\\n<pre><code class=\\\"language-js\\\">const fs = require('fs');\\nfs.unlink('/tmp/hello');\\nconsole.log('successfully deleted /tmp/hello');\\n</code></pre>\\n<p>使用异步方法时，需要注意异步方法的执行不一定按照书写顺序，比如下面这种写法很容易出错：</p>\\n<pre><code class=\\\"language-js\\\">fs.rename('/tmp/hello', '/tmp/world', (err) => {\\n   if (err) throw err;\\n   console.log('renamed compelte');\\n});\\nfs.stat('/tmp/world', (err, stats) => {if (err) throw err;\\nconsole.log(`stats: ${JSON.stringify(stats)}`)});\\n</code></pre>\\n<p>在这里，很可能<code>fs.stat</code>函数先于<code>fs.rename</code>，这样会出现一些不必要的错误，正确的方法应该是写在回调函数中:</p>\\n<pre><code class=\\\"language-js\\\">fs.rename('/tmp/hello/', '/tmp/world', (err) ss=> {\\n    if (err) throw err;\\n    fs.stat('/tmp/world'),(err, stats) => {\\n        console.log(`stats: ${JSON.stringfy(stats)});\\n    });\\n});\\n</code></pre>\\n<p>执行复杂耗时的方法，强烈建议使用异步版本，同步方法在它们执行结束之前，会一直锁住当前线程，阻断所有操作。 在<code>fs</code>模块中，可以使用相对路径，但是需要留意参照的路径来自于<code>process.cwd()</code>的返回值。 很多<code>fs</code>函数可以忽略掉回调参数，如果这样进行使用，默认会抛出错误，为了跟踪到函数调用的位置，可以设置<code>NODE_DEBUG</code>环境变量：</p>\\n<pre><code class=\\\"language-bash\\\">$ cat script.js\\nfunction bad() {\\n  require('fs').readFile('/');\\n}\\nbad();\\n$ env NODE_DEBUG=fs node script.js\\nfs.js:66\\n        throw err;\\n              ^\\nError: EISDIR, read\\n    at rethrow (fs.js:61:21)\\n    at maybeCallback (fs.js:79:42)\\n    at Object.fs.readFile (fs.js:153:18)\\n    at bad (/path/to/script.js:2:17)\\n    at Object.&#x3C;anonymous> (/path/to/script.js:5:1)\\n    &#x3C;etc.>\\n</code></pre>\\n<p><code>fs.watch(filename[, options][, listener])</code>监听制定文件或者目录的变化情况，<code>filename</code>参数可以是文件或者目录，这个方法返回一个<code>fs.FSWather</code>对象。 第二个参数是可选的，提供的<code>options</code>参数应该是一个对象，里面要求的成员是<code>persistent</code>和<code>recursive</code>，这个两个成员都是布尔类型的值。 用做监听的回调函数有两个参数，分别是(<code>event</code>, <code>filename</code>)，<code>event</code>的值视情况，返回字符串<code>change</code>，<code>rename</code>，文件名指的是触发事件的这个文件。看下面的这个例子：</p>\\n<pre><code class=\\\"language-js\\\">// node.md\\n// 被监听的文件\\nthis is cat.\\n// app.js\\n// 用来监听文件改变\\n    fs.watch('./node.md', (event, filename) => {\\n        console.log('下面是event参数，event参数的类型，filename');\\n        console.log(typeof event);\\n        console.log(filename);\\n    });\\n// node.md\\n// 这里修改了监听的node.md文件\\nthis is dog.\\n// console\\n// 执行结果\\n下面是event参数，event参数的类型，filename\\nchange\\nstring\\nnode.md\\n// node.md => node1.md\\n// 修改文件的名字\\n// console\\n// 执行结果\\n下面是event参数，event参数的类型，filename\\nrename\\nstring\\nnode1.md\\n</code></pre>\\n<p>注意事项： <code>fs.watch</code>并不是跨所有平台的，在某些常见下不一定可用。 第二个参数中的布尔值<code>recursive</code>只在<code>osx</code>和<code>window</code>下可以使用。</p>\\n<h2>可用性</h2>\\n<ul>\\n<li><code>fs.watch</code>依赖于操作系统底层模块，由操作系统底层模块通知Node文件的变化。</li>\\n<li>如果某个操作系统底层模块对于文件的监听本身就有问题，那么<code>fs.watch</code>是无法发挥作用的，比如监听了一些不可靠的目录和文件，网络文件系统，虚拟机系统中的文件。</li>\\n<li>在<code>Linux</code>，<code>osx</code>系统中，<code>fs.watch</code>解析路径成一个索引节点，并且监听这个节点，但是如果监听的节点被删除或者重新创建，那么此时它就成了一个新节点了，<code>watch</code>将会发送一个<code>delete</code>事件，但是仍然监听原来的节点，原来的事件不会响应新节点的改变，这种处理是符合预期的。</li>\\n<li><code>filename</code>参数只支持在<code>Linux</code>和<code>windows</code>上面指定(<code>osx</code>也可以，但是有些情况可能会有异常)，事实上，即便是在可以使用的平台上，也不建议直接使用这个参数，因为在回调函数内部，建议增加一些逻辑判断，看一下<code>filename</code>是否为<code>null</code>，如下面的例子：</li>\\n</ul>\\n<pre><code class=\\\"language-js\\\">fs.watch('somedir', (event, filename) => {\\n    console.log(`event is: ${event}`);\\n    if (filename) {\\n         console.log(`filename provided: ${filename}`);\\n     } else {\\n         console.log('filename not provided');\\n     }\\n});\\n</code></pre>\",\"fields\":{\"slug\":\"/2016-10-01---node-file-system/\"}}],\"Tmux\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2017-01-22---tmux-operation/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"tmux基本操作 电脑换回了win10系统，使用bash on windows进行开发，有个问题一直很困扰。\\n在windows系统下面，少见非常优秀的，类似iTerm2那样的终端软件。使用cmder对于bash…\",\"frontmatter\":{\"title\":\"tmux日常操作\",\"date\":\"2017-01-22\",\"tags\":[\"Tmux\",\"Linux\"]},\"html\":\"<h1>tmux基本操作</h1>\\n<p>电脑换回了win10系统，使用bash on windows进行开发，有个问题一直很困扰。\\n在windows系统下面，少见非常优秀的，类似iTerm2那样的终端软件。使用cmder对于bash的美化确实起到了很大的作用，但是对屏幕的管理依然不方便。最近留意到了tmux这款终端复用工具，简单使用后，发现它的确非常棒，给我带来了不少的便利。</p>\\n<h2>Session</h2>\\n<p>创建一个Session，默认情况下，当在shell中输入<code>tmux</code>时，就会自动创建一个名称为<code>0</code>的Session</p>\\n<pre><code class=\\\"language-bash\\\">#　创建Session\\ntmux\\n# 查看当前建立的Session，使用下面两个命令\\ntmux list-session\\n# 缩写\\ntmux ls\\n0: 1 windows (created Sat Jan 21 11:27:33 2017) [55x35]\\n# 创建一个指定名称的Session\\ntmux new -s $name\\n# 使用t参数关闭指定的Session\\ntmux kill-session -t $name\\n# 将指定的Session放置到后台中\\ntmux detach -t  $name\\n# 加载处于在后台中的Session\\ntmux attach-session -t $name\\n# 完全退出，关闭所有的Session\\ntmux kill-server\\n</code></pre>\\n<h2>Window</h2>\\n<p>在Session之下，可以开设很多得当Window，其实当我们创建一个Session时，就已经会默认创建一个Window了。</p>\\n<p>在Window中，可以使用很多命令进行闪转腾挪了，默认调用命令的快捷键是<code>Ctrl-b</code>，看下面的例子：</p>\\n<pre><code class=\\\"language-bash\\\">#Ctrl-b &#x3C;command>\\n# 列出当前所有的Window\\nCtrl-b w \\n(0)  0: ~  \\\"DESKTOP-IE8ULOJ\\\"\\n(1)  1: ~  \\\"DESKTOP-IE8ULOJ\\\"\\n(2)  2: ~- \\\"DESKTOP-IE8ULOJ\\\"\\n(3)  3: ~* \\\"DESKTOP-IE8ULOJ\\\"\\n# 创建一个Wind ow （create）\\nCtrl-b c\\n# 切换到下一个Window （next）\\nCtrl-b n\\n# 切换到上一个Window（previous）\\nCtrl-b p\\n# 切换到指定序号的Window\\nCtrl-b [0-9]\\n# 重命名当前窗口的名称\\nCtrl-b ，\\n# 关闭当前窗口\\nCtrl-b &#x26;\\n</code></pre>\\n<h2>Pane</h2>\\n<p>在Window层级的切换时全屏的，可以继续分，往下的这个层级叫做Pane</p>\\n<pre><code class=\\\"language-bash\\\"># 垂直分割\\nCtrl-b %\\n# 水平分割\\nCtrl-b “”\\n# 在窗口之间切换\\nCtrl-b o\\n# 按照指定的方向切换\\nCtrl-b 方向键\\n# tmux默认有几种Pane的布局方式，这个命令用来在默认的布局方式中切换\\nCtrl-b 空格\\n# 关闭当前Pane\\nCtrl-b x\\n</code></pre>\",\"fields\":{\"slug\":\"/2017-01-22---tmux-operation/\"}}],\"summary\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2017-01-01---final-summary-2016/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"2016年终总结 2016年，已经2…\",\"frontmatter\":{\"title\":\"2016年终总结\",\"date\":\"2017-01-01\",\"tags\":[\"summary\"]},\"html\":\"<h1>2016年终总结</h1>\\n<p>2016年，已经22岁的我最终没有留下来继续工作，选择了求学。这一年很多事情都很矛盾，开始选择自己做大决定。像孩子第一次进入糖果店一样，我尝到了努力和学习的甜头，开始越来越不可收拾。</p>\\n<h2>年初的复习</h2>\\n<p>当时我算是彻底的一无所有，虽然琢磨制作网页小半年的时间了，越来越了解相关知识，但与知乎上回答问题的那些年轻人依然相差很远，自己知道自己的斤两。那时候身边的大部分事情都比较糟糕，我本专业学的差劲，也不感兴趣。就这样断断续续的拖到放假。</p>\\n<p>按照惯性，我就和之前十几年重复的事情一样，被动的去尝试一切的可能性，也还和高考中考一样，父母永远会对我有期待，永远倾尽他们的一切来为我的可能性很小的未来让路，这一路走来我上很一般的高中，上大专，都一直没有变过。</p>\\n<p>但这次有些不一样，我也记不得转变是从什么时候开始的，但是肯定不会是突然开始的。可能是由于半年断断续续，三天打鱼两天晒网的学习前端吧，好多个三天打鱼两天晒网连在一起不知道算不算打鱼晒网了。</p>\\n<p>总之我开始一个人找安静的地方做自己的小东西，学点别人不懂的东西，偶尔一个下午窝在图书馆学点自己的东西，这样间接的为我带来了断断续续的成就感。结果确实如常人所说的不重要，做这些事情换来在性格上的提升影响了后面的专转本复习过程。</p>\\n<p>到专转本复习的那段时间，我开始像书上说的一样，每天就是学习，但也并没有对专转本保证非常强烈的渴望，只是很平淡的学习。父亲惊讶于我的改变，奶奶也很吃惊，逢人就说。那个时候我心里可真是五味杂陈，过去作为一个学生，10多年的学生，却从未像学生一样努力学习过。第一次努力学习就成为别人眼中的异类。本来一件很普通，很理所当然应该去做的事情，我拖了这么多年才做成，在别人眼中依然是惊叹。但我也感谢这些现象，我没有太多的分心和彷徨。</p>\\n<p>在复习的初期，有件非常重要的事情，也是非常好运的事情，美团那边的三面来了，是我在火车上的时候，技术工程部这边的未来同事通知我参加三面，当时非常惊讶，因为二面20道题，我仅仅做出了2道题，已经不抱有希望了。事后我觉得可能是因为益国给我布置的作业我写的比较认真吧，一个不算难的问题我用了好多种方法，而且写满了注释来解释自己的思路。</p>\\n<p>不管如何，迎来了三面，我把这件事情告诉了父亲。他在县城呆了太多年，对美团是什么样子的公司根本不了解，觉得应该上不了台面，也可能因为过去十几年我从未让父亲自豪过，父亲觉得我很难成功，但是父亲碍于我的面子，依然允许我抽几天时间准备前端的面试。</p>\\n<p>我没有准备太久，三面非常快就来了，主要是面试官提示，引导。我自己把自己会的东西一股脑的往出说，那时可真是痛快，在原来专科是没有人听我这么倾诉的。最棒的是面试官的知识非常的广，基本我这里提到什么，他都能问到难点上，我就开动脑子尽量去想，放大胆说，遇到实在不会的，我就尽量说说相关的内容，我学习前端知识时间有限，掌握和了解的知识其实不多，但是面试气氛是非常的不错，总共进行了大约一个半小时。之前我担心会需要写代码，怕家里的网络不好，还专门去了县城的网吧， 后来因为网吧太吵了，而且信号不好，我干脆到街上，一边说一边找安静的地方，最后在一个叫不出名字的小区落脚。哈哈，有一说一，会就会，不会就大致说说相关的内容，但是不瞎说。这次面试我非常的满意，我的计算机基础可能与科班出身差很多，但是关于CSS，JS的了解我还相对自信一些。面试结束后大概三天左右，就有结果通知我，处理掉一些另外的小插曲，约定好专转本结束（周六）后的周一去报到。</p>\\n<p>无话可说的日子才是最好的日子，专转本的复习远远超过我高考的复习强度，爸爸和奶奶见证我的变化，也不断的给我支持。到考试前2天我从县城回到太原坐车前往徐州，参加专转本的考试。</p>\\n<p>回想专转本考试也非常有趣，因为我没有报过什么补习班，也没有做过模拟题和技巧类的训练，导致我的时间规划非常差，英语甚至没有写完，一道题磨磨蹭蹭，老是不放心结果。数学从前到后才写了一次，遗漏都没有足够的时间检查，就要交卷了，计算机是我的强项，也仅仅是刚刚好。想想也好玩，这么多年，包括高考在内的考试从来都是把自己掏干净，却什么也写不出，剩余的时间就是不断的东张西望，现在是心里面有很多东西，却来不及写，哈哈。</p>\\n<p>不管如何专转本就结束了，和几个在校的同学吃了点东西，就拉着行李去北京，我父亲提前一天在那里提前帮我找房子。当时其实也是战战兢兢，担心去了北京之后，美团万一又说不要我了，到时候该怎么办，之前在加工厂干活时，加工一块4m长的阳光板只给我5毛钱，一天累死累活挣30块钱。现在让我相信自己将来工作的地方有苹果顶配的笔记本，有3000块钱的工程椅，还有健身房，简直是奇幻了。</p>\\n<p>报到的那边早上，怕父亲忙，就让他先回去了，我准时去了公司，从hr那里填写了入职相关的内容，部门的负责人崔凯迟迟不来接我去工位，大概10点半了。hr让我给崔凯打个电话。崔凯江湖气的声音在电话里面响起：郝翔？你到了吗？好，你就在那里等着，我现在还回不回去，被堵路上了，我让兄弟们接你去。哈哈，也是这个时候心才放了下去。不一会儿益国来接我的，他是我后边为我引路的师傅。</p>\\n<h2>美团半年</h2>\\n<p>在美团那里的一切都充满了快乐。因为之前使用ubuntu的进行开发，这让我用一周时间熟悉了工作工具，三周学习了React相关的技术栈，之后改线上的bug，leader帮我review代码，这些和大多数人的过程一样。因为我慌张着担心自己是新人中最慢的，所以每天总是拖着到最后一个才敢离开，放松当天紧张的心情。</p>\\n<p>那时的我总是喜欢没话找话说，抓住和别人在一起聊天的时间问问题，不断的询问同事我的成长是否慢了，我如何改进。父亲也每天给我打电话，询问我的进展，给我鼓励。女朋友给我打气，陪伴我。因为好不容易才拥有的，所以那段时间非常珍惜。</p>\\n<p>到4月份我已经完成了第一次的业务开发，返校处理毕业的问题。现在想想那时被毕业设计真是搞得焦头烂额。学校的某些奇葩规定让人瞠目结算，论文的要求高过我们的水平，主动让我们抄袭袭。不去留意内容，仅仅不断的给我们找排版上的毛病，学生们普遍比较无奈，只有不断的花钱去整篇整篇的重新打印。一本施工组织设计厚一些的三百来页，往事不堪回首啊。</p>\\n<p>不管如何结束了毕业问题，回到美团继续工作。这段时间我过得紧张且充满挑战性。产品那边觉得公司关于登陆验证方面重复开发比较频繁，点评和美团和并之后更甚，浪费了不少开发资源。想要我和后端抽离现在的验证页面，开发一种适配公司各种业务，嵌入到网页中可以直接使用的验证模块。这个模块从产品构思，开发到部署的过程我都经历了，在三个月的时间内，我积累了不少的开发和编程经验。leader没有因为我是实习生就仅仅让我打打杂，他给我足够多的自主性，这些是传统企业中少有的，非常感激这段时光。</p>\\n<p>让我印象深刻的一个同事也是一个胖子，他的水平很高，经常分享一些技术文章，我们时常在一些热门论坛上看到他的文章。我们争议两点：一是因为我想为项目开发一个简单的，类似解析器的函数，在JS中写HTML时，可以为DOM元素自动绑定上对应的响应函数，方便后边的开发。当时我摆出的观点是编程不应该重复，不该写一些easy代码。同时可以提高后续开发的效率，因为整个解析函数非常的简单，干净。他的观点与我相反，觉得我不应该做这个解析器，因为这样后续维护我代码的人必须了解这个解析函数，哪怕他足够简单。</p>\\n<p>第二件事情就是我想走之后将项目交给他，他因为解析函数的问题，觉得我的项目里面都是坑，不情愿接。同时表明了他后半年的工作任务必须围绕React，他不想接触其他的技术栈，担心隔一段时间之后就会忘记React的。给我留下记忆的是他口述过程中对于工作的规划非常清晰，且独立强烈的工作学习方向。他的想法没有问题，但这些与我的观念不合，我认为我当时刚来的时候也是学习React 的，我做这个项目不也是牺牲了自己学习新技术的机会吗？为什么我可以为了业务转变，而他就不行呢，况且转换也不以为着没有新挑战。</p>\\n<h2>爱情</h2>\\n<p>贯穿在2016年的事情，除了亲情，便是爱情了。</p>\\n<p>2014年中我们在一起，到2016年便是我们在一起的第1.5年。他离开了学校，正式工作。我从学校切换到工作再切换到学校。我们这一年没有了2015年的轻松活泼感，对未来的焦虑和我们身份上的区别不断的代入和影响我们的感情。</p>\\n<p>回想起来她背着布袋，在街上走，傻傻的样子就感觉很甜蜜。记得早一年的冬天，因为工资过低，她又不想和家里人要钱，白天去工作，晚上回来之后还要去鸡公煲店里面打工，去端盘子，洗碗。本该窝在家里的冬天，小小的她却为了生活去忍受冰冷。我真的很庆幸有她，她小小的身体里面有着坚强和勇敢的种子，愿意吃苦去忍受。</p>\\n<p>过程总是充满了磕磕绊绊，但是在结束时，留在心中回忆起来，甜的更多些。</p>\\n<p>回想这一年走来，和我女朋友的感情一波三折，都说理不清楚的就是爱情。在一起也二年多了，哪里分得清楚谁欠谁，谁付出的多一些，所有的事情都搅在了一起。</p>\\n<p>我们在一起就想要甜甜的度过每一天。但这一年可能是我们所有弱点都完全展示给对方的一年了，我们都是两个孩子。</p>\\n<p>年初一切还好，我在全身心的准备考试，基本每天的交流时间很少，并没有留下多少记忆。三月底到北京工作时候，我们的交流开始增多了，美团的实习工资很高，我当时其实是难以相信的，一向没有经济规划的我兴冲冲的想要购置物品，买零食，买手机。</p>\\n<p>我们在假期一起去清华北大，但是到了之后发现那边真的好大啊，人好多。顶级学府门口的保安都感觉和镀了金一样，里面的学生看起来非常的忙，骑车子的速度很快，我当时感觉很诧异，想着他们也不怕撞了人。但本着宽容的心态，我无耻的换位思考了一下，作为清北的学生，每天和猴子一样被参观者指指点点，总是会有些不适应的。\\n其实我们从北大出来之后，就没有去清华了，感觉那里好大，莫名其妙就下午快四点了，两只肥仔我们必须去觅食了，走走停停，嘟嘟嚷嚷的去吃自助，一路上她不断的抱怨“走不动了，还有多远，还有那么远啊”，哈哈！</p>\\n<p>我们去天安门，吃天安门侧门售卖的5元钱一根的烤肠，感觉是那么好吃，哈哈。一起去逛护城河，拍照片，我每次拍照片都不拍不好，别人给我的时候我还老是扭捏。也从小到大一直没有积累照片的习惯，不知道将来年纪再大些会不会后悔。</p>\\n<p>去天安门后，我们还去了天安门对面的街上闲逛，一家店铺是卖首饰零碎的，我看到门口有卖酥饼的，我当时非常饿，看到两块钱一个，就进去买了一个。买的时候问的很好：这个里面是什么馅呢？一个男的说是黑芝麻的。我仔细瞧瞧，感觉不像啊，我继续追问，真是黑芝麻的？他又很肯定的说是。我交了两块钱，拿上饼子出门，结果咬开根本看不到芝麻，知道掰成两半才发现中间有几颗芝麻粒。我当时真的感觉莫名其妙，以及被欺骗非常不好受。我进去找到那个男的，你这个是黑芝麻馅的？他依然说是，我说你这就这么几颗黑芝麻也敢叫黑芝麻馅，你骗谁呢。他一脸看穷逼的样子，尖酸刻薄：你一共就两块钱，你想买多少芝麻。真是不可理喻，我把吃过的饼子直接扔到他门口的饼堆里面，扭头就走了。结果他追出来，不让我走。我当时心里想着不走就不走，怕你什么，天安门你还想搞事情。但又一想，到时候真的被拦住万一有警察，我和她怎么办，最后女老板也来了，我当时莫名其妙就怂了，后来女老板让我走吧，我说不是故意的。女老板也不想把事情闹大，就让我们走了。</p>\\n<p>在工作期间我记得我们吵过几次架，有一次是因为我第二天要上班，我给她规划了路线，让她一个人去北京西站坐火车回太原。一路上其实还好好的，回去之后我们就开始吵架了。当时报道北京颐和酒店那里有个女孩子莫名其妙被暴打，因为打人者误以为是同行来抢生意的。她当时非常的害怕，嫌我不关心她，想象她要是遇到那种情况又该怎么办呢，我对于这件事情感觉非常莫名其妙，现在治安这么好，为什么会想到这些呢，新闻上的事情就是因为难以遇到才被报道的，真的要是常见哪里还叫新闻啊。现在想想，在这一整年，我对她的关心始终不够，因为自己靠自己的努力和运气走出了一条可以解决温饱，过得开心的路，让自己处于非常膨胀的心态中，感觉什么事情都已经不重要了。</p>\\n<p>后半年我放弃继续美团的工作，想要回来考研，我想圆自己的清华梦，缩小和同龄人之间的差距。想在未来，给家里人，她更好的生活环境。</p>\\n<p>于是在进入新学校之后我就尽可能的沉浸在自己一个人的世界里面，每天拿出大量的时间和书本做斗争，整体学习和生活趋于稳定。而她由于工作出现了问题，需要换工作，每天充满了焦虑，我们开始频繁的陷入争吵。她因为工作不顺利，情绪总是不好。我们开始因为一些莫名其妙，有的我现在甚至已经想不起来的源头吵架，我总是埋怨她对于工作不满而频繁出现的抱怨，埋怨她对于其他朋友的攀比。</p>\\n<p>我们在身边时总是很好的。如果是在身边，我可能会给她一个拥抱，让我们继续鼓起勇气往前走，可是异地网恋，隔着千山万水，我们所有的情感只能通过声音和文字表达。\\n我们便吵架，好多次吵架，吵到最后，觉得对方仿佛就是世界上最恶毒的人，两个人都哭哭啼啼，闹着要分手。但在最后，她总是更早的回到理性，我们又会和好，真的好庆幸有她。在生活上她其实就是我们这个小班子的船长，是我们继续前进的方向。</p>\\n<p>吵架是件不好的事情，但是它确实催生了很多改变。我们为我们的小轮船继续投入燃料，开始将两个人的工作压力和学习压力注意方法的进行释放，更加照顾对方的感受。到几个月前她更换了新工作之后，她开始对工作富有更高的责任心，经常会在下班之后，仍然留在公司加班，比较晚了才回去。</p>\\n<p>她有不少该我学习的地方，她在理财方面也做的非常好。记得她贷款买下苹果手机之后，我一直担心分期那么多，要拖到什么时候才可以换完啊，我们的生活会因为这个过得很辛苦的。但结果是因为她在工资上的规划，在生活上的节俭，才两个多月就还完了。</p>\\n<p>我最喜欢的歌曲里面，唱最长情的莫过于陪伴。我觉得最幸福的事情莫过于两个人互相陪伴。任何时候想到对方，充满笑意和暖心，多么幸福，难怪很多人为了爱情死生挈阔，因为它的确有这样的魔力，让人温暖，充满勇气。年末想起这些，我非常想继续陪伴着她，我们现在越来越少发送争吵了。</p>\\n<p>我感谢她做出的牺牲。她开始减少了和其他朋友间的比较，疏远了一些可有可无的朋友，将更多的时间花在更有意义的事情上。开始想着不断的提高自己的工作技能。\\n什么事情都有个过错，我相信既然有了想法，且开始付诸一点点行动，那么慢慢总会有收获的，不断是斜着上坡还是垂直上坡，都是在向上的。</p>\\n<h2>2017年的展望</h2>\\n<p>站在今天看我们的一切都真的很棒，坎坎坷坷，但都过来了，我们从这一年中更加了解对方，了解对方的家庭成员，更加的情投意合，找到了更好的相处模式。我们越来越勇敢了，在2017我们便要甩开膀子，大干一场，绝不彷徨。让家里人因为我们努力更加幸福自豪，让自己有足够的能力建立一个小家，也希望在更遥远的时候可以为祖国添砖加瓦。</p>\",\"fields\":{\"slug\":\"/2017-01-01---final-summary-2016/\"}}]},\"post\":[{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-10-01---node-file-system/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"Node文件系统 Node 通过封装基本的 POSIX 函数来提供文件系统，使用 require('fs…\",\"frontmatter\":{\"title\":\"Node文件系统\",\"date\":\"2016-10-01\",\"tags\":[\"Node\",\"JS\"]},\"html\":\"<h1>Node文件系统</h1>\\n<p><code>Node</code>通过封装基本的<code>POSIX</code>函数来提供文件系统，使用<code>require('fs')</code>来使用这个模块，所有与文件相关的方法，都提供了异步和同步的形式。 异步的方法通常会将一个可选的回调函数作为最后一个参数，回调函数的第一个参数通常留给意外情况，如果操作是成功的，第一个参数将是<code>null</code>或者<code>undeefined</code>。 使用同步方法，对于任何意外都会即时抛出，可以使用<code>try/catch</code>语句来处理意外情况，或者让错误时间向上冒泡。 下面是一个有关异步方法的基本例子：</p>\\n<pre><code class=\\\"language-js\\\">const fs = require('fs');\\nfs.unlink('/tmp/hello', (err) => {\\n  if (err) throw err;\\n  console.log('sucessfully deleted /tmp/hello');\\n}\\n</code></pre>\\n<p>再跟着一个同步的例子：</p>\\n<pre><code class=\\\"language-js\\\">const fs = require('fs');\\nfs.unlink('/tmp/hello');\\nconsole.log('successfully deleted /tmp/hello');\\n</code></pre>\\n<p>使用异步方法时，需要注意异步方法的执行不一定按照书写顺序，比如下面这种写法很容易出错：</p>\\n<pre><code class=\\\"language-js\\\">fs.rename('/tmp/hello', '/tmp/world', (err) => {\\n   if (err) throw err;\\n   console.log('renamed compelte');\\n});\\nfs.stat('/tmp/world', (err, stats) => {if (err) throw err;\\nconsole.log(`stats: ${JSON.stringify(stats)}`)});\\n</code></pre>\\n<p>在这里，很可能<code>fs.stat</code>函数先于<code>fs.rename</code>，这样会出现一些不必要的错误，正确的方法应该是写在回调函数中:</p>\\n<pre><code class=\\\"language-js\\\">fs.rename('/tmp/hello/', '/tmp/world', (err) ss=> {\\n    if (err) throw err;\\n    fs.stat('/tmp/world'),(err, stats) => {\\n        console.log(`stats: ${JSON.stringfy(stats)});\\n    });\\n});\\n</code></pre>\\n<p>执行复杂耗时的方法，强烈建议使用异步版本，同步方法在它们执行结束之前，会一直锁住当前线程，阻断所有操作。 在<code>fs</code>模块中，可以使用相对路径，但是需要留意参照的路径来自于<code>process.cwd()</code>的返回值。 很多<code>fs</code>函数可以忽略掉回调参数，如果这样进行使用，默认会抛出错误，为了跟踪到函数调用的位置，可以设置<code>NODE_DEBUG</code>环境变量：</p>\\n<pre><code class=\\\"language-bash\\\">$ cat script.js\\nfunction bad() {\\n  require('fs').readFile('/');\\n}\\nbad();\\n$ env NODE_DEBUG=fs node script.js\\nfs.js:66\\n        throw err;\\n              ^\\nError: EISDIR, read\\n    at rethrow (fs.js:61:21)\\n    at maybeCallback (fs.js:79:42)\\n    at Object.fs.readFile (fs.js:153:18)\\n    at bad (/path/to/script.js:2:17)\\n    at Object.&#x3C;anonymous> (/path/to/script.js:5:1)\\n    &#x3C;etc.>\\n</code></pre>\\n<p><code>fs.watch(filename[, options][, listener])</code>监听制定文件或者目录的变化情况，<code>filename</code>参数可以是文件或者目录，这个方法返回一个<code>fs.FSWather</code>对象。 第二个参数是可选的，提供的<code>options</code>参数应该是一个对象，里面要求的成员是<code>persistent</code>和<code>recursive</code>，这个两个成员都是布尔类型的值。 用做监听的回调函数有两个参数，分别是(<code>event</code>, <code>filename</code>)，<code>event</code>的值视情况，返回字符串<code>change</code>，<code>rename</code>，文件名指的是触发事件的这个文件。看下面的这个例子：</p>\\n<pre><code class=\\\"language-js\\\">// node.md\\n// 被监听的文件\\nthis is cat.\\n// app.js\\n// 用来监听文件改变\\n    fs.watch('./node.md', (event, filename) => {\\n        console.log('下面是event参数，event参数的类型，filename');\\n        console.log(typeof event);\\n        console.log(filename);\\n    });\\n// node.md\\n// 这里修改了监听的node.md文件\\nthis is dog.\\n// console\\n// 执行结果\\n下面是event参数，event参数的类型，filename\\nchange\\nstring\\nnode.md\\n// node.md => node1.md\\n// 修改文件的名字\\n// console\\n// 执行结果\\n下面是event参数，event参数的类型，filename\\nrename\\nstring\\nnode1.md\\n</code></pre>\\n<p>注意事项： <code>fs.watch</code>并不是跨所有平台的，在某些常见下不一定可用。 第二个参数中的布尔值<code>recursive</code>只在<code>osx</code>和<code>window</code>下可以使用。</p>\\n<h2>可用性</h2>\\n<ul>\\n<li><code>fs.watch</code>依赖于操作系统底层模块，由操作系统底层模块通知Node文件的变化。</li>\\n<li>如果某个操作系统底层模块对于文件的监听本身就有问题，那么<code>fs.watch</code>是无法发挥作用的，比如监听了一些不可靠的目录和文件，网络文件系统，虚拟机系统中的文件。</li>\\n<li>在<code>Linux</code>，<code>osx</code>系统中，<code>fs.watch</code>解析路径成一个索引节点，并且监听这个节点，但是如果监听的节点被删除或者重新创建，那么此时它就成了一个新节点了，<code>watch</code>将会发送一个<code>delete</code>事件，但是仍然监听原来的节点，原来的事件不会响应新节点的改变，这种处理是符合预期的。</li>\\n<li><code>filename</code>参数只支持在<code>Linux</code>和<code>windows</code>上面指定(<code>osx</code>也可以，但是有些情况可能会有异常)，事实上，即便是在可以使用的平台上，也不建议直接使用这个参数，因为在回调函数内部，建议增加一些逻辑判断，看一下<code>filename</code>是否为<code>null</code>，如下面的例子：</li>\\n</ul>\\n<pre><code class=\\\"language-js\\\">fs.watch('somedir', (event, filename) => {\\n    console.log(`event is: ${event}`);\\n    if (filename) {\\n         console.log(`filename provided: ${filename}`);\\n     } else {\\n         console.log('filename not provided');\\n     }\\n});\\n</code></pre>\",\"fields\":{\"slug\":\"/2016-10-01---node-file-system/\"}}],\"tag\":\"Node\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/tags-node.json\n// module id = 447\n// module chunks = 71230123872026"],"sourceRoot":""}