{"version":3,"sources":["webpack:///path---index-4b60d6e947b8d5c721d7.js","webpack:///./.cache/json/index.json"],"names":["webpackJsonp","424","module","exports","data","allMarkdownRemark","edges","node","id","excerpt","frontmatter","title","date","tags","popular","wordCount","paragraphs","sentences","words","fields","slug","totalCount","pathContext"],"mappings":"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","file":"path---index-4b60d6e947b8d5c721d7.js","sourcesContent":["webpackJsonp([142629428675168],{\n\n/***/ 424:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"allMarkdownRemark\":{\"edges\":[{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2018-01-12---os-2/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"操作系统（二） 操作系统如何管理物理主存？ 计算机体系结构、主存结构分层 CPU芯片内部有寄存器和Cache，操作系统无法直接访问管理，这一层次的主存容量小但是数据很快。 在主存结构中有一块很大的区域，即主存或者物理主存。这块区域可以用来放置操作系统本身代码以及其他要运行的程序，主存容量大，速度慢。 计算机中可以在主存中存放着多个可运行的程序，若CPU的运行速度很快，且这些可运行的程序都需要很大的主存，那么CPU…\",\"frontmatter\":{\"title\":\"操作系统（二）\",\"date\":\"2018-01-12\",\"tags\":[\"os\",\"memory\"],\"popular\":null},\"wordCount\":{\"paragraphs\":40,\"sentences\":40,\"words\":170},\"fields\":{\"slug\":\"/2018-01-12---os-2/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2018-01-10---os-1/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"操作系统（一） 按下电源之后，如何加载操作系统？ 操作系统如何与外设、应用程序交互？ BIOS、BootLoader、OS的关系 BIOS即基本输入输出系统，存在CMOS中，OS即操作系统，操作系统存在硬盘中。硬盘中还存另一个简单的小程序BootLoader，它可以将OS从硬盘放到内存中去，使cpu可以执行OS相关的代码。 一开始加电，CPU从一个预先约定的地址处开始执行BIOS程序，进行加电自检（显卡，键鼠，硬盘），检查成功，即外设均可正常工作，接着要将BootLoader…\",\"frontmatter\":{\"title\":\"操作系统（一）\",\"date\":\"2018-01-10\",\"tags\":[\"os\",\"Bootloader\"],\"popular\":null},\"wordCount\":{\"paragraphs\":36,\"sentences\":36,\"words\":161},\"fields\":{\"slug\":\"/2018-01-10---os-1/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-10-02---git-develop-workflow/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"Git 学习小记之开发工作流 经过上面几次学习，再结合日常的使用，现在对于分支已经有了比较细致的了解，今天补充的是利用分支进行开发的工作流，有利于帮助工程更快更安全的开发。 长期分支 浏览GitHub上的仓库，很多都是在 master 分支上保留着稳定代码，这部分可能是需要发布或者已经在使用的代码。在此基础上，可能还会有 dev 开发分支， staging 测试分支等等，这些分支专门用来开发测试，当这些开发分支到达一定程度，可以提供稳定的特性；或者完成了开发任务，就可以合并到 master…\",\"frontmatter\":{\"title\":\"Git 学习小记之开发工作流\",\"date\":\"2017-10-02\",\"tags\":[\"Git\"],\"popular\":null},\"wordCount\":{\"paragraphs\":18,\"sentences\":18,\"words\":111},\"fields\":{\"slug\":\"/2016-10-02---git-develop-workflow/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2017-04-30---numpy-ndarray/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"numpy入门——ndarray介绍 下文主要围绕ndarray类型，介绍相关运算。 ndarray是numpy支持的数据类型，numpy相关运算的对象都是它。我们知道python已经自带了很多基础类型，比如列表，元组等等，numpy的ndarray可以理解为自由受限，但功能加强版的list类型。之所以抛弃更开放的list…\",\"frontmatter\":{\"title\":\"numpy入门——ndarray介绍\",\"date\":\"2017-04-30\",\"tags\":[\"Numpy\",\"ML\",\"Python\"],\"popular\":null},\"wordCount\":{\"paragraphs\":29,\"sentences\":30,\"words\":122},\"fields\":{\"slug\":\"/2017-04-30---numpy-ndarray/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2015-07-10---anaconda-introduction/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"Anaconda介绍 Anaconda 是一个第三方开源免费IDE，它本质上是第三方库和主流工具的集成平台。支持市面上主流的第三方库和工具，非常适合数据计算相关领域，且它支持跨平台。\\nAnaconda可以直接从官网上面下载，它会随着Python版本的更新不断更新。 conda 很多人听过conda，它是什么？\\nconda其实是一个进行用户包管理（类似pip）和Python环境管理（切换Python版本）的工具。日常中我们经常使用conda为旧程序配置Python2，新程序配置Python…\",\"frontmatter\":{\"title\":\"Anaconda介绍\",\"date\":\"2017-04-10\",\"tags\":[\"Python\",\"Anaconda\"],\"popular\":null},\"wordCount\":{\"paragraphs\":12,\"sentences\":12,\"words\":52},\"fields\":{\"slug\":\"/2015-07-10---anaconda-introduction/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2017-03-10---knn-2/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"机器学习之k-NN算法实战(二) 回顾上文，我们介绍了k-NN算法的原理，以及实例数据的格式，如何加载。万事俱备，下文我们来介绍k-NN算法的代码实现。 首先从store中取出样本数据，存到局部变量中 之后我们利用这些数据来进行k-NN分类 上面的函数，我们需要的参数为测试向量，训练向量集，以及K值。我们将待测试的向量铺成和训练集相同shape的矩阵，之后直接求欧氏距离，按照预设去k…\",\"frontmatter\":{\"title\":\"机器学习之k-NN算法实战(二)\",\"date\":\"2017-03-10\",\"tags\":[\"ML\",\"KNN\"],\"popular\":null},\"wordCount\":{\"paragraphs\":19,\"sentences\":19,\"words\":68},\"fields\":{\"slug\":\"/2017-03-10---knn-2/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2017-03-04---knn-1/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"机器学习之k-NN算法实战(一) 下文会介绍机器学习的k-NN算法，首先大致介绍k-NN算法的原理，之后我们会通过识别手写体数字这个小项目，来讲解k-NN分类算法的代码实现。 k-NN算法原理 所谓k-NN算法，全名为是一种分类算法，它属于监督式算法，也就是说对于这个算法，必须提前对数据打标签，否则无法完成分类。其次，k-NN又被人们称为是“懒汉”算法，或者说“惰性学习”，这是因为k-NN并不会像神经网络，线性回归那样直接训练出一个模型来，下文会逐步介绍。 使用k-NN…\",\"frontmatter\":{\"title\":\"机器学习之k-NN算法实战(一)\",\"date\":\"2017-03-04\",\"tags\":[\"ML\",\"KNN\"],\"popular\":true},\"wordCount\":{\"paragraphs\":17,\"sentences\":17,\"words\":91},\"fields\":{\"slug\":\"/2017-03-04---knn-1/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2017-02-12---mysql-operation/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"MySQL常用操作 下文整理一些常用的操作 初始信息 MySQL默认的端口号码是3306，服务器是本地localhost\\n查看MySQL版本 常用规范 关键字函数名一律使用大写（但使用小写不会报错） 数据库名，变量名使用小写 末尾要加分号 数据库 数据库广义上说应该是一个框架，我们针对这个框架创造它所包含的数据库文件。 创建数据库 CREATE DATABASE  IF NOT EXSITS  database name\\n[CHARACTER SET character set…\",\"frontmatter\":{\"title\":\" MySQL常用操作\",\"date\":\"2017-02-12\",\"tags\":[\"MySQL\"],\"popular\":null},\"wordCount\":{\"paragraphs\":31,\"sentences\":31,\"words\":92},\"fields\":{\"slug\":\"/2017-02-12---mysql-operation/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2017-01-22---tmux-operation/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"tmux基本操作 电脑换回了win10系统，使用bash on windows进行开发，有个问题一直很困扰。\\n在windows系统下面，少见非常优秀的，类似iTerm2那样的终端软件。使用cmder对于bash的美化确实起到了很大的作用，但是对屏幕的管理依然不方便。最近留意到了tmux这款终端复用工具，简单使用后，发现它的确非常棒，给我带来了不少的便利。 Session 创建一个Session，默认情况下，当在shell中输入 tmux 时，就会自动创建一个名称为 0 的Session…\",\"frontmatter\":{\"title\":\"tmux日常操作\",\"date\":\"2017-01-22\",\"tags\":[\"Tmux\",\"Linux\"],\"popular\":null},\"wordCount\":{\"paragraphs\":11,\"sentences\":11,\"words\":42},\"fields\":{\"slug\":\"/2017-01-22---tmux-operation/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2017-01-01---final-summary-2016/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"2016年终总结 2016年，已经2…\",\"frontmatter\":{\"title\":\"2016年终总结\",\"date\":\"2017-01-01\",\"tags\":[\"summary\"],\"popular\":null},\"wordCount\":{\"paragraphs\":45,\"sentences\":45,\"words\":530},\"fields\":{\"slug\":\"/2017-01-01---final-summary-2016/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-11-12---node-module-loader/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"Node原生模块加载器 Node.js包含一个简单的模块加载器，在Node.js 中，文件和模块是一一对应的，比如下面这个例子， foo.js 装载在处于相同目录的 circle.js foo.js 中的内容： circle.js 中的内容: circle.js 模块导出了两个函数 area() 和 circumference() 。 为了将函数或者对象添加到模块上，你可以将它们添加给特殊的对象 exports 。 模块中的局部变量是模块私有的，因为模块最终会被包裹在 Node.js…\",\"frontmatter\":{\"title\":\"Node原生模块加载器\",\"date\":\"2016-11-12\",\"tags\":[\"Node\"],\"popular\":null},\"wordCount\":{\"paragraphs\":34,\"sentences\":35,\"words\":83},\"fields\":{\"slug\":\"/2016-11-12---node-module-loader/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-10-01---node-file-system/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"Node文件系统 Node 通过封装基本的 POSIX 函数来提供文件系统，使用 require('fs') 来使用这个模块，所有与文件相关的方法，都提供了异步和同步的形式。 异步的方法通常会将一个可选的回调函数作为最后一个参数，回调函数的第一个参数通常留给意外情况，如果操作是成功的，第一个参数将是 null 或者 undeefined 。 使用同步方法，对于任何意外都会即时抛出，可以使用 try/catch…\",\"frontmatter\":{\"title\":\"Node文件系统\",\"date\":\"2016-10-01\",\"tags\":[\"Node\",\"JS\"],\"popular\":null},\"wordCount\":{\"paragraphs\":15,\"sentences\":15,\"words\":107},\"fields\":{\"slug\":\"/2016-10-01---node-file-system/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-09-10---git-alias/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"Git 学习小记之使用别名 Git 是在开发中需要频繁使用的工具，如何高效使用，除了深刻理解用法之外，还可以利用一些别名来减少操作。 Git 中的省略其实无处不在，事实上在我们 push 的时候使用的  git push origin master ，意思就是 git push origin master:master （将本地的 master 分支推送至远端的 master 分支，如果没有就新建一个），这就是一个省略了。 哈哈，开玩笑的，下面开始进入正题了，想要使用别名，需要先在 Git…\",\"frontmatter\":{\"title\":\"Git 学习小记之使用别名\",\"date\":\"2016-09-10\",\"tags\":[\"Git\"],\"popular\":true},\"wordCount\":{\"paragraphs\":10,\"sentences\":10,\"words\":59},\"fields\":{\"slug\":\"/2016-09-10---git-alias/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-09-07---js-function-2/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"再探JS函数 函数是JS的核心概念，主要用来封装语句，封装单独的功能。 函数参数 函数不在意它本身到底接收多少参数，不关心最后会使用多少参数。因为函数只会接收一个数组，函数可以通过 arguments 属性来访问这个参数数组。关于这个数组，他其实是个对象，如下: 但是为什么又说它是数组呢，因为它本身很数组很像，可以通过方括号加数字的方法来访问具体的参数，同时还有数组对象有的 length 属性。一个有趣的例子： 这样子依然是有效的，在函数执行的时候，通过 arguments 对象的 length…\",\"frontmatter\":{\"title\":\"再探JS函数\",\"date\":\"2016-09-07\",\"tags\":[\"JS\",\"function\"],\"popular\":null},\"wordCount\":{\"paragraphs\":20,\"sentences\":20,\"words\":84},\"fields\":{\"slug\":\"/2016-09-07---js-function-2/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-06-03---shadowsocks-install/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"ShadowSocks 安装记录 这里使用的是  ubuntu 14.04 ,是我比较喜欢的一个系统。\\n首先更新  apt  源，保证获取最新的软件 之后安装  python  相关依赖， pip  包管理器，可能是类似  npm  的一种吧，没有细致研究过 通过  pip  安装  ShadowSocks 配置  ShadowSocks  的配置文件  vim /etc/shadowsocks.json server  表示当前服务器的  ip  地址， password…\",\"frontmatter\":{\"title\":\"ShadowSocks 安装记录\",\"date\":\"2016-09-01\",\"tags\":[\"Linux\",\"shadowsocks\"],\"popular\":null},\"wordCount\":{\"paragraphs\":10,\"sentences\":10,\"words\":37},\"fields\":{\"slug\":\"/2016-06-03---shadowsocks-install/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-09-01---git-branch/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"Git学习小记之分支原理 如果想要熟练使用Git，没有分支理念是绝对行不通的，在用 Git 管理项目的时候，经常需要使用 commit 这个命令，那么这个 commit 到底是指什么呢？ 按照官方的解释，这应该成为一个对象，它包含着一个指向暂存内容(被 add 的文件)快照的指针，包含本次提交的附属信息，比如说作者等等，指向父 commit 对象(如果被 merge 而成，可能有多个父 commit 对象)的指针。 举下面这个例子来分析： add ：暂存操作会对文件计算校验和(SHA-…\",\"frontmatter\":{\"title\":\"Git学习小记之分支原理\",\"date\":\"2016-09-01\",\"tags\":[\"Git\"],\"popular\":null},\"wordCount\":{\"paragraphs\":35,\"sentences\":35,\"words\":232},\"fields\":{\"slug\":\"/2016-09-01---git-branch/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-08-26---js-function-1/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"初探JS函数 有关函数相关的话题在网上讨论的并不够多，因为它比较复杂，这也是为什么现在网上会存在如此多的误解。 在这片文章里面，我会试着去总结有关函数的好的，坏的，丑陋的一面。 函数表达式 VS. 函数声明 在 ECMAScript 中，如果需要使用函数，最常用的两种方法就是通过函数表达式和函数声明。掌握它们区别非常重要，因为在JS 中两者的执行是有差别的，可惜很不爽，至少在看来， 两者之间的差别可以说是相当混乱，只有一件事是 ECMA…\",\"frontmatter\":{\"title\":\"初探JS函数\",\"date\":\"2016-08-26\",\"tags\":[\"JS\",\"function\"],\"popular\":null},\"wordCount\":{\"paragraphs\":12,\"sentences\":13,\"words\":92},\"fields\":{\"slug\":\"/2016-08-26---js-function-1/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-08-20---git-add/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"Git 学习小记之 add 所谓 add 操作，就是 add file into staged area 。下面针对两种情况进行讨论： 新建的文件 旧文件 新建的文件 我们了解 add 是一个重要的操作。假设有一个空目录，此时里面没有任何文件。\\n我们新建一个文件，这个文件就是处于 untrack 状态的，可以理解为未被跟踪状态。 此时修改这个文件，依然是处于 untrack 状态。在此时使用 add 操作，有两个作用： 将新文件添加到暂存区( staged ) 将文件标记为  track…\",\"frontmatter\":{\"title\":\"Git 学习小记之 add\",\"date\":\"2016-08-20\",\"tags\":[\"Git\"],\"popular\":true},\"wordCount\":{\"paragraphs\":21,\"sentences\":21,\"words\":94},\"fields\":{\"slug\":\"/2016-08-20---git-add/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-08-12---pixel-layout/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"布局像素的辨析 下文主要介绍了一些关于分辨率的基础概念。 物理分辨率 所谓物理分辨率，是指一块屏幕上，横向有多少个像素点，纵向有多少个像素点，比如苹果5的分辨率是640x1136，代表它横向有640个像素点，纵向拥有1136个像素点。看官也听出来了，这个物理分辨率是屏幕自带的固定参数，无法更改。 屏幕尺寸 屏幕尺寸指屏幕对角线的长度，根据横向长度和纵向长度进一步计算得到，使用英寸为单位，比如苹果5的尺寸为4.…\",\"frontmatter\":{\"title\":\"布局像素的辨析\",\"date\":\"2016-08-12\",\"tags\":[\"CSS\"],\"popular\":true},\"wordCount\":{\"paragraphs\":21,\"sentences\":21,\"words\":119},\"fields\":{\"slug\":\"/2016-08-12---pixel-layout/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-07-03---es6-string/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"ES6中的字符串 在ES6中， Iterator 也被添加给了字符串，这样代表字符串可以使用 for ... of 循环了。 字符串查找 接下来介绍一些可以通过 ES5 PolyFill的方法，但是现在 ES6 原生实现了 Method Param Return Description includes() 需要验证是否被包含的字符串 Boolean 表示是否调用此方法的字符串是否包含参数中的字符串 startsWith() 需要被验证的字符串 Boolean…\",\"frontmatter\":{\"title\":\"ES6中的字符串\",\"date\":\"2016-07-03\",\"tags\":[\"ES6\",\"JS\"],\"popular\":null},\"wordCount\":{\"paragraphs\":14,\"sentences\":14,\"words\":44},\"fields\":{\"slug\":\"/2016-07-03---es6-string/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-05-07---js-logic-operation/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"JS 中的逻辑运算总结，FOR效率 在编程中，布尔操作符占了很大一部分，判断语句除了依赖相等操作符，还严重依赖这些布尔操作符，逻辑运算中的布尔操作符也有很多“奇淫巧计”。最近我抱着学习的态度不断浏览一些简单开源的项目，发现对于这一块太不熟练了，急需做个学习整理。 在正式开始之前，先需要区分 && 、 ||  与 if 语句，他们完全是没有关联， if…\",\"frontmatter\":{\"title\":\"JS 中的逻辑运算总结，FOR效率\",\"date\":\"2016-05-07\",\"tags\":[\"JS\"],\"popular\":null},\"wordCount\":{\"paragraphs\":11,\"sentences\":11,\"words\":80},\"fields\":{\"slug\":\"/2016-05-07---js-logic-operation/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-05-03---opensauce/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"opensauce单元测试 为开源项目提供免费的云测试\\n https://saucelabs.com/opensauce/ 推荐文章 https://philipwalton.com/articles/learning-how-to-set-up-automated-cross-browser-javascript-unit-testing/ 中文版\\n http://www.jianshu.com/p/d079b9c61450\",\"frontmatter\":{\"title\":\"opensauce单元测试\",\"date\":\"2016-05-03\",\"tags\":[\"opensauce\",\"unit testing\"],\"popular\":null},\"wordCount\":{\"paragraphs\":6,\"sentences\":6,\"words\":22},\"fields\":{\"slug\":\"/2016-05-03---opensauce/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-04-21---react-summary/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"React学习总结 参考官方文档，整理一些应该被重视的知识点 React中的事件相关 类似HTML中事件的使用方法，可以直接将事件处理函数作为属性值，赋给用驼峰式命名的事件属性。之后的事情交给React，React自己有一个事件系统，它可以保证事件在所有浏览器中的一致性，React知道如何去冒泡和捕获事件，这个实现是根据w3c的规范，不管使用的是什么浏览器 State 相关 State是可以用来动态渲染，和props是一对好基友。 State 的异步工作方式 setState…\",\"frontmatter\":{\"title\":\"React学习总结\",\"date\":\"2016-04-21\",\"tags\":[\"React\",\"JS\"],\"popular\":null},\"wordCount\":{\"paragraphs\":20,\"sentences\":20,\"words\":136},\"fields\":{\"slug\":\"/2016-04-21---react-summary/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-04-06---regular-expression-2/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"正则表达式进阶 接上一篇内容，上一篇主要介绍了正则表达式的核心内容，非常的简单易懂，现在对核心内容进行拓展。 界定符 表示正则表达式的开始和结束，具体的由解析器决定 /[0-9]/ #[0-9]# 元字符 元字符定义了原子的筛选方式，可以将某一类原子归类，并且给出缩写，简化正则： | 匹配两个或者多个分支 [] 中括号内部的任意一个原子 [^] 匹配除括号内部原子之外的任何字符 原子的筛选 使用 [] 可以进行原子的筛选，代表或者的关系， [^] 代表非的关系 [Dd]uang (D|d…\",\"frontmatter\":{\"title\":\"正则表达式进阶\",\"date\":\"2016-04-06\",\"tags\":[\"regular expression\"],\"popular\":null},\"wordCount\":{\"paragraphs\":43,\"sentences\":43,\"words\":84},\"fields\":{\"slug\":\"/2016-04-06---regular-expression-2/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-04-05---regular-expression-1/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"正则表达式核心 若有多个字符串，其中一个字符串中包含部分内容，我们使用正则来进行匹配，匹配的结果到底什么？是包含匹配内容的那个字符串？还是只有匹配的内容？ Go Ahead~ 正则表达式的核心概念就是元字符，它一点也不复杂，掌握了元字符，就可以正则表达式的能力有所了解。 接下来的每一节，我都会介绍数个元字符，最终本文结束时，读者就会对正则表达式的核心元字符有大概的了解。 从 hi, Hao 开始 hi, Hao 这样一个字符串，如果使用正则表达式匹配到 hi ？这非常简单，我们使用 js…\",\"frontmatter\":{\"title\":\"正则表达式核心\",\"date\":\"2016-04-05\",\"tags\":[\"regular expression\"],\"popular\":true},\"wordCount\":{\"paragraphs\":38,\"sentences\":39,\"words\":203},\"fields\":{\"slug\":\"/2016-04-05---regular-expression-1/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-02-07---js-in/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"JavaScript 中的 in 关键字 在 JavaScript 中,我经常会使用 for(key in ..) 语句来遍历对象的 key  ,这是一种很常用的方式.\\n这里需要留意, 其实 for(.. in ..) 语句也可以用来遍历数组,其中的 key 就是数组的 index (索引值,0开始) 。\\n除了在 for(.. in ..) 语句中使用, in 也可以作为一个单独的关键字使用,用来判断某个属性或者元素是否存在与数组或者对象.一般会用在判断语句中,下面进行说明。 数组 通过 in…\",\"frontmatter\":{\"title\":\"JavaScript 中的 in 关键字\",\"date\":\"2016-02-07\",\"tags\":[\"JS\"],\"popular\":true},\"wordCount\":{\"paragraphs\":13,\"sentences\":13,\"words\":69},\"fields\":{\"slug\":\"/2016-02-07---js-in/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2015-10-05---css-summary/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"CSS 总结 计划总结常用的CSS知识 基本布局 下面汇总了传统的绝对，浮动，表格与凝胶等布局方式的优缺点 绝对布局 优点：主内容随页面宽度，固定边栏 缺点：浏览器变宽的时候，页脚可能会遮住边栏，同时浏览器变宽后，主内容区和边栏的比例会不协调。 表格显示布局 优点：使用 table 标签，随窗口缩放 缺点：对于语义化不利 凝胶布局 优点：主内容区建立后，设置左右margin为…\",\"frontmatter\":{\"title\":\"CSS 总结\",\"date\":\"2015-10-5\",\"tags\":[\"css\"],\"popular\":null},\"wordCount\":{\"paragraphs\":22,\"sentences\":22,\"words\":67},\"fields\":{\"slug\":\"/2015-10-05---css-summary/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2015-07-10---rails-install/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"Rails 安装记录 本文 ubuntu 版本为 14.04stl 64bit ，参考教程： http://rails-practice.com/content/Chapter_1/1.1.html，  需要翻墙 Git ubuntu安装完毕之后，首先安装git，以便之后会用到： 配置身份信息： 核实信息是否有误： 此时已经能通过 http 正常拉去git上的内容，若想进一步配置 ssh ，可以参考 https://help.github.com/articles/generating-ssh…\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"],\"popular\":null},\"wordCount\":{\"paragraphs\":29,\"sentences\":30,\"words\":116},\"fields\":{\"slug\":\"/2015-07-10---rails-install/\"}}}],\"totalCount\":28}},\"pathContext\":{}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---index-4b60d6e947b8d5c721d7.js","module.exports = {\"data\":{\"allMarkdownRemark\":{\"edges\":[{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2018-01-12---os-2/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"操作系统（二） 操作系统如何管理物理主存？ 计算机体系结构、主存结构分层 CPU芯片内部有寄存器和Cache，操作系统无法直接访问管理，这一层次的主存容量小但是数据很快。 在主存结构中有一块很大的区域，即主存或者物理主存。这块区域可以用来放置操作系统本身代码以及其他要运行的程序，主存容量大，速度慢。 计算机中可以在主存中存放着多个可运行的程序，若CPU的运行速度很快，且这些可运行的程序都需要很大的主存，那么CPU…\",\"frontmatter\":{\"title\":\"操作系统（二）\",\"date\":\"2018-01-12\",\"tags\":[\"os\",\"memory\"],\"popular\":null},\"wordCount\":{\"paragraphs\":40,\"sentences\":40,\"words\":170},\"fields\":{\"slug\":\"/2018-01-12---os-2/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2018-01-10---os-1/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"操作系统（一） 按下电源之后，如何加载操作系统？ 操作系统如何与外设、应用程序交互？ BIOS、BootLoader、OS的关系 BIOS即基本输入输出系统，存在CMOS中，OS即操作系统，操作系统存在硬盘中。硬盘中还存另一个简单的小程序BootLoader，它可以将OS从硬盘放到内存中去，使cpu可以执行OS相关的代码。 一开始加电，CPU从一个预先约定的地址处开始执行BIOS程序，进行加电自检（显卡，键鼠，硬盘），检查成功，即外设均可正常工作，接着要将BootLoader…\",\"frontmatter\":{\"title\":\"操作系统（一）\",\"date\":\"2018-01-10\",\"tags\":[\"os\",\"Bootloader\"],\"popular\":null},\"wordCount\":{\"paragraphs\":36,\"sentences\":36,\"words\":161},\"fields\":{\"slug\":\"/2018-01-10---os-1/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-10-02---git-develop-workflow/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"Git 学习小记之开发工作流 经过上面几次学习，再结合日常的使用，现在对于分支已经有了比较细致的了解，今天补充的是利用分支进行开发的工作流，有利于帮助工程更快更安全的开发。 长期分支 浏览GitHub上的仓库，很多都是在 master 分支上保留着稳定代码，这部分可能是需要发布或者已经在使用的代码。在此基础上，可能还会有 dev 开发分支， staging 测试分支等等，这些分支专门用来开发测试，当这些开发分支到达一定程度，可以提供稳定的特性；或者完成了开发任务，就可以合并到 master…\",\"frontmatter\":{\"title\":\"Git 学习小记之开发工作流\",\"date\":\"2017-10-02\",\"tags\":[\"Git\"],\"popular\":null},\"wordCount\":{\"paragraphs\":18,\"sentences\":18,\"words\":111},\"fields\":{\"slug\":\"/2016-10-02---git-develop-workflow/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2017-04-30---numpy-ndarray/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"numpy入门——ndarray介绍 下文主要围绕ndarray类型，介绍相关运算。 ndarray是numpy支持的数据类型，numpy相关运算的对象都是它。我们知道python已经自带了很多基础类型，比如列表，元组等等，numpy的ndarray可以理解为自由受限，但功能加强版的list类型。之所以抛弃更开放的list…\",\"frontmatter\":{\"title\":\"numpy入门——ndarray介绍\",\"date\":\"2017-04-30\",\"tags\":[\"Numpy\",\"ML\",\"Python\"],\"popular\":null},\"wordCount\":{\"paragraphs\":29,\"sentences\":30,\"words\":122},\"fields\":{\"slug\":\"/2017-04-30---numpy-ndarray/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2015-07-10---anaconda-introduction/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"Anaconda介绍 Anaconda 是一个第三方开源免费IDE，它本质上是第三方库和主流工具的集成平台。支持市面上主流的第三方库和工具，非常适合数据计算相关领域，且它支持跨平台。\\nAnaconda可以直接从官网上面下载，它会随着Python版本的更新不断更新。 conda 很多人听过conda，它是什么？\\nconda其实是一个进行用户包管理（类似pip）和Python环境管理（切换Python版本）的工具。日常中我们经常使用conda为旧程序配置Python2，新程序配置Python…\",\"frontmatter\":{\"title\":\"Anaconda介绍\",\"date\":\"2017-04-10\",\"tags\":[\"Python\",\"Anaconda\"],\"popular\":null},\"wordCount\":{\"paragraphs\":12,\"sentences\":12,\"words\":52},\"fields\":{\"slug\":\"/2015-07-10---anaconda-introduction/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2017-03-10---knn-2/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"机器学习之k-NN算法实战(二) 回顾上文，我们介绍了k-NN算法的原理，以及实例数据的格式，如何加载。万事俱备，下文我们来介绍k-NN算法的代码实现。 首先从store中取出样本数据，存到局部变量中 之后我们利用这些数据来进行k-NN分类 上面的函数，我们需要的参数为测试向量，训练向量集，以及K值。我们将待测试的向量铺成和训练集相同shape的矩阵，之后直接求欧氏距离，按照预设去k…\",\"frontmatter\":{\"title\":\"机器学习之k-NN算法实战(二)\",\"date\":\"2017-03-10\",\"tags\":[\"ML\",\"KNN\"],\"popular\":null},\"wordCount\":{\"paragraphs\":19,\"sentences\":19,\"words\":68},\"fields\":{\"slug\":\"/2017-03-10---knn-2/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2017-03-04---knn-1/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"机器学习之k-NN算法实战(一) 下文会介绍机器学习的k-NN算法，首先大致介绍k-NN算法的原理，之后我们会通过识别手写体数字这个小项目，来讲解k-NN分类算法的代码实现。 k-NN算法原理 所谓k-NN算法，全名为是一种分类算法，它属于监督式算法，也就是说对于这个算法，必须提前对数据打标签，否则无法完成分类。其次，k-NN又被人们称为是“懒汉”算法，或者说“惰性学习”，这是因为k-NN并不会像神经网络，线性回归那样直接训练出一个模型来，下文会逐步介绍。 使用k-NN…\",\"frontmatter\":{\"title\":\"机器学习之k-NN算法实战(一)\",\"date\":\"2017-03-04\",\"tags\":[\"ML\",\"KNN\"],\"popular\":true},\"wordCount\":{\"paragraphs\":17,\"sentences\":17,\"words\":91},\"fields\":{\"slug\":\"/2017-03-04---knn-1/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2017-02-12---mysql-operation/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"MySQL常用操作 下文整理一些常用的操作 初始信息 MySQL默认的端口号码是3306，服务器是本地localhost\\n查看MySQL版本 常用规范 关键字函数名一律使用大写（但使用小写不会报错） 数据库名，变量名使用小写 末尾要加分号 数据库 数据库广义上说应该是一个框架，我们针对这个框架创造它所包含的数据库文件。 创建数据库 CREATE DATABASE  IF NOT EXSITS  database name\\n[CHARACTER SET character set…\",\"frontmatter\":{\"title\":\" MySQL常用操作\",\"date\":\"2017-02-12\",\"tags\":[\"MySQL\"],\"popular\":null},\"wordCount\":{\"paragraphs\":31,\"sentences\":31,\"words\":92},\"fields\":{\"slug\":\"/2017-02-12---mysql-operation/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2017-01-22---tmux-operation/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"tmux基本操作 电脑换回了win10系统，使用bash on windows进行开发，有个问题一直很困扰。\\n在windows系统下面，少见非常优秀的，类似iTerm2那样的终端软件。使用cmder对于bash的美化确实起到了很大的作用，但是对屏幕的管理依然不方便。最近留意到了tmux这款终端复用工具，简单使用后，发现它的确非常棒，给我带来了不少的便利。 Session 创建一个Session，默认情况下，当在shell中输入 tmux 时，就会自动创建一个名称为 0 的Session…\",\"frontmatter\":{\"title\":\"tmux日常操作\",\"date\":\"2017-01-22\",\"tags\":[\"Tmux\",\"Linux\"],\"popular\":null},\"wordCount\":{\"paragraphs\":11,\"sentences\":11,\"words\":42},\"fields\":{\"slug\":\"/2017-01-22---tmux-operation/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2017-01-01---final-summary-2016/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"2016年终总结 2016年，已经2…\",\"frontmatter\":{\"title\":\"2016年终总结\",\"date\":\"2017-01-01\",\"tags\":[\"summary\"],\"popular\":null},\"wordCount\":{\"paragraphs\":45,\"sentences\":45,\"words\":530},\"fields\":{\"slug\":\"/2017-01-01---final-summary-2016/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-11-12---node-module-loader/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"Node原生模块加载器 Node.js包含一个简单的模块加载器，在Node.js 中，文件和模块是一一对应的，比如下面这个例子， foo.js 装载在处于相同目录的 circle.js foo.js 中的内容： circle.js 中的内容: circle.js 模块导出了两个函数 area() 和 circumference() 。 为了将函数或者对象添加到模块上，你可以将它们添加给特殊的对象 exports 。 模块中的局部变量是模块私有的，因为模块最终会被包裹在 Node.js…\",\"frontmatter\":{\"title\":\"Node原生模块加载器\",\"date\":\"2016-11-12\",\"tags\":[\"Node\"],\"popular\":null},\"wordCount\":{\"paragraphs\":34,\"sentences\":35,\"words\":83},\"fields\":{\"slug\":\"/2016-11-12---node-module-loader/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-10-01---node-file-system/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"Node文件系统 Node 通过封装基本的 POSIX 函数来提供文件系统，使用 require('fs') 来使用这个模块，所有与文件相关的方法，都提供了异步和同步的形式。 异步的方法通常会将一个可选的回调函数作为最后一个参数，回调函数的第一个参数通常留给意外情况，如果操作是成功的，第一个参数将是 null 或者 undeefined 。 使用同步方法，对于任何意外都会即时抛出，可以使用 try/catch…\",\"frontmatter\":{\"title\":\"Node文件系统\",\"date\":\"2016-10-01\",\"tags\":[\"Node\",\"JS\"],\"popular\":null},\"wordCount\":{\"paragraphs\":15,\"sentences\":15,\"words\":107},\"fields\":{\"slug\":\"/2016-10-01---node-file-system/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-09-10---git-alias/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"Git 学习小记之使用别名 Git 是在开发中需要频繁使用的工具，如何高效使用，除了深刻理解用法之外，还可以利用一些别名来减少操作。 Git 中的省略其实无处不在，事实上在我们 push 的时候使用的  git push origin master ，意思就是 git push origin master:master （将本地的 master 分支推送至远端的 master 分支，如果没有就新建一个），这就是一个省略了。 哈哈，开玩笑的，下面开始进入正题了，想要使用别名，需要先在 Git…\",\"frontmatter\":{\"title\":\"Git 学习小记之使用别名\",\"date\":\"2016-09-10\",\"tags\":[\"Git\"],\"popular\":true},\"wordCount\":{\"paragraphs\":10,\"sentences\":10,\"words\":59},\"fields\":{\"slug\":\"/2016-09-10---git-alias/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-09-07---js-function-2/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"再探JS函数 函数是JS的核心概念，主要用来封装语句，封装单独的功能。 函数参数 函数不在意它本身到底接收多少参数，不关心最后会使用多少参数。因为函数只会接收一个数组，函数可以通过 arguments 属性来访问这个参数数组。关于这个数组，他其实是个对象，如下: 但是为什么又说它是数组呢，因为它本身很数组很像，可以通过方括号加数字的方法来访问具体的参数，同时还有数组对象有的 length 属性。一个有趣的例子： 这样子依然是有效的，在函数执行的时候，通过 arguments 对象的 length…\",\"frontmatter\":{\"title\":\"再探JS函数\",\"date\":\"2016-09-07\",\"tags\":[\"JS\",\"function\"],\"popular\":null},\"wordCount\":{\"paragraphs\":20,\"sentences\":20,\"words\":84},\"fields\":{\"slug\":\"/2016-09-07---js-function-2/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-06-03---shadowsocks-install/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"ShadowSocks 安装记录 这里使用的是  ubuntu 14.04 ,是我比较喜欢的一个系统。\\n首先更新  apt  源，保证获取最新的软件 之后安装  python  相关依赖， pip  包管理器，可能是类似  npm  的一种吧，没有细致研究过 通过  pip  安装  ShadowSocks 配置  ShadowSocks  的配置文件  vim /etc/shadowsocks.json server  表示当前服务器的  ip  地址， password…\",\"frontmatter\":{\"title\":\"ShadowSocks 安装记录\",\"date\":\"2016-09-01\",\"tags\":[\"Linux\",\"shadowsocks\"],\"popular\":null},\"wordCount\":{\"paragraphs\":10,\"sentences\":10,\"words\":37},\"fields\":{\"slug\":\"/2016-06-03---shadowsocks-install/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-09-01---git-branch/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"Git学习小记之分支原理 如果想要熟练使用Git，没有分支理念是绝对行不通的，在用 Git 管理项目的时候，经常需要使用 commit 这个命令，那么这个 commit 到底是指什么呢？ 按照官方的解释，这应该成为一个对象，它包含着一个指向暂存内容(被 add 的文件)快照的指针，包含本次提交的附属信息，比如说作者等等，指向父 commit 对象(如果被 merge 而成，可能有多个父 commit 对象)的指针。 举下面这个例子来分析： add ：暂存操作会对文件计算校验和(SHA-…\",\"frontmatter\":{\"title\":\"Git学习小记之分支原理\",\"date\":\"2016-09-01\",\"tags\":[\"Git\"],\"popular\":null},\"wordCount\":{\"paragraphs\":35,\"sentences\":35,\"words\":232},\"fields\":{\"slug\":\"/2016-09-01---git-branch/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-08-26---js-function-1/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"初探JS函数 有关函数相关的话题在网上讨论的并不够多，因为它比较复杂，这也是为什么现在网上会存在如此多的误解。 在这片文章里面，我会试着去总结有关函数的好的，坏的，丑陋的一面。 函数表达式 VS. 函数声明 在 ECMAScript 中，如果需要使用函数，最常用的两种方法就是通过函数表达式和函数声明。掌握它们区别非常重要，因为在JS 中两者的执行是有差别的，可惜很不爽，至少在看来， 两者之间的差别可以说是相当混乱，只有一件事是 ECMA…\",\"frontmatter\":{\"title\":\"初探JS函数\",\"date\":\"2016-08-26\",\"tags\":[\"JS\",\"function\"],\"popular\":null},\"wordCount\":{\"paragraphs\":12,\"sentences\":13,\"words\":92},\"fields\":{\"slug\":\"/2016-08-26---js-function-1/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-08-20---git-add/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"Git 学习小记之 add 所谓 add 操作，就是 add file into staged area 。下面针对两种情况进行讨论： 新建的文件 旧文件 新建的文件 我们了解 add 是一个重要的操作。假设有一个空目录，此时里面没有任何文件。\\n我们新建一个文件，这个文件就是处于 untrack 状态的，可以理解为未被跟踪状态。 此时修改这个文件，依然是处于 untrack 状态。在此时使用 add 操作，有两个作用： 将新文件添加到暂存区( staged ) 将文件标记为  track…\",\"frontmatter\":{\"title\":\"Git 学习小记之 add\",\"date\":\"2016-08-20\",\"tags\":[\"Git\"],\"popular\":true},\"wordCount\":{\"paragraphs\":21,\"sentences\":21,\"words\":94},\"fields\":{\"slug\":\"/2016-08-20---git-add/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-08-12---pixel-layout/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"布局像素的辨析 下文主要介绍了一些关于分辨率的基础概念。 物理分辨率 所谓物理分辨率，是指一块屏幕上，横向有多少个像素点，纵向有多少个像素点，比如苹果5的分辨率是640x1136，代表它横向有640个像素点，纵向拥有1136个像素点。看官也听出来了，这个物理分辨率是屏幕自带的固定参数，无法更改。 屏幕尺寸 屏幕尺寸指屏幕对角线的长度，根据横向长度和纵向长度进一步计算得到，使用英寸为单位，比如苹果5的尺寸为4.…\",\"frontmatter\":{\"title\":\"布局像素的辨析\",\"date\":\"2016-08-12\",\"tags\":[\"CSS\"],\"popular\":true},\"wordCount\":{\"paragraphs\":21,\"sentences\":21,\"words\":119},\"fields\":{\"slug\":\"/2016-08-12---pixel-layout/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-07-03---es6-string/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"ES6中的字符串 在ES6中， Iterator 也被添加给了字符串，这样代表字符串可以使用 for ... of 循环了。 字符串查找 接下来介绍一些可以通过 ES5 PolyFill的方法，但是现在 ES6 原生实现了 Method Param Return Description includes() 需要验证是否被包含的字符串 Boolean 表示是否调用此方法的字符串是否包含参数中的字符串 startsWith() 需要被验证的字符串 Boolean…\",\"frontmatter\":{\"title\":\"ES6中的字符串\",\"date\":\"2016-07-03\",\"tags\":[\"ES6\",\"JS\"],\"popular\":null},\"wordCount\":{\"paragraphs\":14,\"sentences\":14,\"words\":44},\"fields\":{\"slug\":\"/2016-07-03---es6-string/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-05-07---js-logic-operation/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"JS 中的逻辑运算总结，FOR效率 在编程中，布尔操作符占了很大一部分，判断语句除了依赖相等操作符，还严重依赖这些布尔操作符，逻辑运算中的布尔操作符也有很多“奇淫巧计”。最近我抱着学习的态度不断浏览一些简单开源的项目，发现对于这一块太不熟练了，急需做个学习整理。 在正式开始之前，先需要区分 && 、 ||  与 if 语句，他们完全是没有关联， if…\",\"frontmatter\":{\"title\":\"JS 中的逻辑运算总结，FOR效率\",\"date\":\"2016-05-07\",\"tags\":[\"JS\"],\"popular\":null},\"wordCount\":{\"paragraphs\":11,\"sentences\":11,\"words\":80},\"fields\":{\"slug\":\"/2016-05-07---js-logic-operation/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-05-03---opensauce/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"opensauce单元测试 为开源项目提供免费的云测试\\n https://saucelabs.com/opensauce/ 推荐文章 https://philipwalton.com/articles/learning-how-to-set-up-automated-cross-browser-javascript-unit-testing/ 中文版\\n http://www.jianshu.com/p/d079b9c61450\",\"frontmatter\":{\"title\":\"opensauce单元测试\",\"date\":\"2016-05-03\",\"tags\":[\"opensauce\",\"unit testing\"],\"popular\":null},\"wordCount\":{\"paragraphs\":6,\"sentences\":6,\"words\":22},\"fields\":{\"slug\":\"/2016-05-03---opensauce/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-04-21---react-summary/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"React学习总结 参考官方文档，整理一些应该被重视的知识点 React中的事件相关 类似HTML中事件的使用方法，可以直接将事件处理函数作为属性值，赋给用驼峰式命名的事件属性。之后的事情交给React，React自己有一个事件系统，它可以保证事件在所有浏览器中的一致性，React知道如何去冒泡和捕获事件，这个实现是根据w3c的规范，不管使用的是什么浏览器 State 相关 State是可以用来动态渲染，和props是一对好基友。 State 的异步工作方式 setState…\",\"frontmatter\":{\"title\":\"React学习总结\",\"date\":\"2016-04-21\",\"tags\":[\"React\",\"JS\"],\"popular\":null},\"wordCount\":{\"paragraphs\":20,\"sentences\":20,\"words\":136},\"fields\":{\"slug\":\"/2016-04-21---react-summary/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-04-06---regular-expression-2/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"正则表达式进阶 接上一篇内容，上一篇主要介绍了正则表达式的核心内容，非常的简单易懂，现在对核心内容进行拓展。 界定符 表示正则表达式的开始和结束，具体的由解析器决定 /[0-9]/ #[0-9]# 元字符 元字符定义了原子的筛选方式，可以将某一类原子归类，并且给出缩写，简化正则： | 匹配两个或者多个分支 [] 中括号内部的任意一个原子 [^] 匹配除括号内部原子之外的任何字符 原子的筛选 使用 [] 可以进行原子的筛选，代表或者的关系， [^] 代表非的关系 [Dd]uang (D|d…\",\"frontmatter\":{\"title\":\"正则表达式进阶\",\"date\":\"2016-04-06\",\"tags\":[\"regular expression\"],\"popular\":null},\"wordCount\":{\"paragraphs\":43,\"sentences\":43,\"words\":84},\"fields\":{\"slug\":\"/2016-04-06---regular-expression-2/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-04-05---regular-expression-1/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"正则表达式核心 若有多个字符串，其中一个字符串中包含部分内容，我们使用正则来进行匹配，匹配的结果到底什么？是包含匹配内容的那个字符串？还是只有匹配的内容？ Go Ahead~ 正则表达式的核心概念就是元字符，它一点也不复杂，掌握了元字符，就可以正则表达式的能力有所了解。 接下来的每一节，我都会介绍数个元字符，最终本文结束时，读者就会对正则表达式的核心元字符有大概的了解。 从 hi, Hao 开始 hi, Hao 这样一个字符串，如果使用正则表达式匹配到 hi ？这非常简单，我们使用 js…\",\"frontmatter\":{\"title\":\"正则表达式核心\",\"date\":\"2016-04-05\",\"tags\":[\"regular expression\"],\"popular\":true},\"wordCount\":{\"paragraphs\":38,\"sentences\":39,\"words\":203},\"fields\":{\"slug\":\"/2016-04-05---regular-expression-1/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-02-07---js-in/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"JavaScript 中的 in 关键字 在 JavaScript 中,我经常会使用 for(key in ..) 语句来遍历对象的 key  ,这是一种很常用的方式.\\n这里需要留意, 其实 for(.. in ..) 语句也可以用来遍历数组,其中的 key 就是数组的 index (索引值,0开始) 。\\n除了在 for(.. in ..) 语句中使用, in 也可以作为一个单独的关键字使用,用来判断某个属性或者元素是否存在与数组或者对象.一般会用在判断语句中,下面进行说明。 数组 通过 in…\",\"frontmatter\":{\"title\":\"JavaScript 中的 in 关键字\",\"date\":\"2016-02-07\",\"tags\":[\"JS\"],\"popular\":true},\"wordCount\":{\"paragraphs\":13,\"sentences\":13,\"words\":69},\"fields\":{\"slug\":\"/2016-02-07---js-in/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2015-10-05---css-summary/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"CSS 总结 计划总结常用的CSS知识 基本布局 下面汇总了传统的绝对，浮动，表格与凝胶等布局方式的优缺点 绝对布局 优点：主内容随页面宽度，固定边栏 缺点：浏览器变宽的时候，页脚可能会遮住边栏，同时浏览器变宽后，主内容区和边栏的比例会不协调。 表格显示布局 优点：使用 table 标签，随窗口缩放 缺点：对于语义化不利 凝胶布局 优点：主内容区建立后，设置左右margin为…\",\"frontmatter\":{\"title\":\"CSS 总结\",\"date\":\"2015-10-5\",\"tags\":[\"css\"],\"popular\":null},\"wordCount\":{\"paragraphs\":22,\"sentences\":22,\"words\":67},\"fields\":{\"slug\":\"/2015-10-05---css-summary/\"}}},{\"node\":{\"id\":\"C:/Users/hao/center/gatsbyblog/src/pages/posts/2015-07-10---rails-install/index.md absPath of file >>> MarkdownRemark\",\"excerpt\":\"Rails 安装记录 本文 ubuntu 版本为 14.04stl 64bit ，参考教程： http://rails-practice.com/content/Chapter_1/1.1.html，  需要翻墙 Git ubuntu安装完毕之后，首先安装git，以便之后会用到： 配置身份信息： 核实信息是否有误： 此时已经能通过 http 正常拉去git上的内容，若想进一步配置 ssh ，可以参考 https://help.github.com/articles/generating-ssh…\",\"frontmatter\":{\"title\":\"Rails 安装记录\",\"date\":\"2015-07-10\",\"tags\":[\"Ruby\",\"Rails\",\"installtion-record\"],\"popular\":null},\"wordCount\":{\"paragraphs\":29,\"sentences\":30,\"words\":116},\"fields\":{\"slug\":\"/2015-07-10---rails-install/\"}}}],\"totalCount\":28}},\"pathContext\":{}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/index.json\n// module id = 424\n// module chunks = 142629428675168"],"sourceRoot":""}