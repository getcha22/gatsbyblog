{"version":3,"sources":["webpack:///path---posts-2016-11-12-node-module-loader-b063e70c44d9a0925375.js","webpack:///./.cache/json/posts-2016-11-12-node-module-loader.json"],"names":["webpackJsonp","433","module","exports","data","markdownRemark","html","frontmatter","title","date","tags","pathContext","slug"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,ilFAA68CC,aAA0pCC,MAAA,cAAAC,KAAA,aAAAC,MAAA,WAA4DC,aAAgBC,KAAA","file":"path---posts-2016-11-12-node-module-loader-b063e70c44d9a0925375.js","sourcesContent":["webpackJsonp([88902746007230],{\n\n/***/ 433:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h1>Node原生模块加载器</h1>\\n<p>Node.js包含一个简单的模块加载器，在Node.js 中，文件和模块是一一对应的，比如下面这个例子，<code>foo.js</code>装载在处于相同目录的<code>circle.js</code></p>\\n<p><code>foo.js</code>中的内容：</p>\\n<pre><code class=\\\"language-js\\\">const circle = require('./circle.js');\\nconsole.log(`The area of a circle of radius 4 is ${circle.area(4)}`);\\n</code></pre>\\n<p><code>circle.js</code>中的内容:</p>\\n<pre><code class=\\\"language-js\\\">const PI = Math.PI;\\nexports.area = (r) => PI * r * r;\\nexports.circumference = (r) => 2 * PI * r;\\n</code></pre>\\n<p><code>circle.js</code>模块导出了两个函数<code>area()</code>和<code>circumference()</code>。</p>\\n<p>为了将函数或者对象添加到模块上，你可以将它们添加给特殊的对象<code>exports</code>。</p>\\n<p>模块中的局部变量是模块私有的，因为模块最终会被包裹在 Node.js的一个函数中。在这个例子中，变量<code>PI</code>是 <code>circle.js</code>的私有变量。</p>\\n<h2>exports 和 module 的关系</h2>\\n<p>如果想要一次赋值，就直接导出一个对象或者函数，那么应该是用<code>module.exports</code>而不是使用<code>exports</code>。</p>\\n<pre><code class=\\\"language-js\\\">const square = require('./square.js');\\nvar mySquare = square(2);\\nconsole.log(`The area of my square is ${mySquare.area()}`);\\n</code></pre>\\n<p>使用<code>module.exports</code></p>\\n<pre><code class=\\\"language-js\\\">module.exports = (width) => {\\n   return {\\n    area: () => width * width\\n   };\\n}\\n</code></pre>\\n<h2>require 对象的解析逻辑</h2>\\n<p>在<code>Y</code>路径的模块内<code>require(x)</code>，总体会经过下面的过程</p>\\n<ol>\\n<li>\\n<p>检查是否为核心模块(<code>fs</code>, <code>assert</code>)</p>\\n<ol>\\n<li>return 核心模块</li>\\n<li>停止</li>\\n</ol>\\n</li>\\n<li>\\n<p>检查是否为相对路径('./', '../');</p>\\n<ol>\\n<li>装载文件</li>\\n<li>装载目录</li>\\n</ol>\\n</li>\\n<li>检查是否为<code>node_modules</code>中的模块，如果没有，抛出错误</li>\\n</ol>\\n<p>其中装载文件又有如下过程：</p>\\n<ol>\\n<li>文件是<code>X</code>， 装载为<code>JS text</code></li>\\n<li>是一个文件，文件名为<code>X.js</code>，装载为<code>js text</code></li>\\n<li>文件是<code>X.json</code>，parse为<code>js object</code></li>\\n<li>文件是<code>.node</code>，装在为二进制</li>\\n</ol>\\n<p>装载目录的过程如下：</p>\\n<ol>\\n<li><code>X/package.json</code>是否存在，解析<code>package.json</code>中的 <code>main</code>字段的值</li>\\n<li>依次检查<code>X/index.js</code> ,<code>X/index.json</code>, <code>X/index.node</code>是否存在，按照上面的相同规则引入</li>\\n</ol>\\n<p>装载<code>node_modules</code>中的模块的过程如下：</p>\\n<p>执行类似下面的函数，生成标识<code>node_modules</code>目录位置的数组，将当前当前目录通过<code>split</code>方法解析为数组：</p>\\n<pre><code class=\\\"language-js\\\">/demo/tmp/src\\nsplit =>\\n['','demo', 'tmp', 'src','']\\n</code></pre>\\n<p>遍历每个层级，追加字符串<code>'node_modules'</code></p>\\n<pre><code class=\\\"language-js\\\">DIRS: ['demo/node_module','tmp/node_module', 'src/node_modules']\\n</code></pre>\\n<p>返回数组<code>DIRS</code>，遍历上面数组，装载：</p>\\n<pre><code class=\\\"language-js\\\">for each DIR in DIRS:\\n</code></pre>\\n<p>先优先按文件解析<code>（DIR/x）</code>，再按照目录解析。</p>\",\"frontmatter\":{\"title\":\"Node原生模块加载器\",\"date\":\"2016-11-12\",\"tags\":[\"Node\"]}}},\"pathContext\":{\"slug\":\"/2016-11-12---node-module-loader/\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---posts-2016-11-12-node-module-loader-b063e70c44d9a0925375.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h1>Node原生模块加载器</h1>\\n<p>Node.js包含一个简单的模块加载器，在Node.js 中，文件和模块是一一对应的，比如下面这个例子，<code>foo.js</code>装载在处于相同目录的<code>circle.js</code></p>\\n<p><code>foo.js</code>中的内容：</p>\\n<pre><code class=\\\"language-js\\\">const circle = require('./circle.js');\\nconsole.log(`The area of a circle of radius 4 is ${circle.area(4)}`);\\n</code></pre>\\n<p><code>circle.js</code>中的内容:</p>\\n<pre><code class=\\\"language-js\\\">const PI = Math.PI;\\nexports.area = (r) => PI * r * r;\\nexports.circumference = (r) => 2 * PI * r;\\n</code></pre>\\n<p><code>circle.js</code>模块导出了两个函数<code>area()</code>和<code>circumference()</code>。</p>\\n<p>为了将函数或者对象添加到模块上，你可以将它们添加给特殊的对象<code>exports</code>。</p>\\n<p>模块中的局部变量是模块私有的，因为模块最终会被包裹在 Node.js的一个函数中。在这个例子中，变量<code>PI</code>是 <code>circle.js</code>的私有变量。</p>\\n<h2>exports 和 module 的关系</h2>\\n<p>如果想要一次赋值，就直接导出一个对象或者函数，那么应该是用<code>module.exports</code>而不是使用<code>exports</code>。</p>\\n<pre><code class=\\\"language-js\\\">const square = require('./square.js');\\nvar mySquare = square(2);\\nconsole.log(`The area of my square is ${mySquare.area()}`);\\n</code></pre>\\n<p>使用<code>module.exports</code></p>\\n<pre><code class=\\\"language-js\\\">module.exports = (width) => {\\n   return {\\n    area: () => width * width\\n   };\\n}\\n</code></pre>\\n<h2>require 对象的解析逻辑</h2>\\n<p>在<code>Y</code>路径的模块内<code>require(x)</code>，总体会经过下面的过程</p>\\n<ol>\\n<li>\\n<p>检查是否为核心模块(<code>fs</code>, <code>assert</code>)</p>\\n<ol>\\n<li>return 核心模块</li>\\n<li>停止</li>\\n</ol>\\n</li>\\n<li>\\n<p>检查是否为相对路径('./', '../');</p>\\n<ol>\\n<li>装载文件</li>\\n<li>装载目录</li>\\n</ol>\\n</li>\\n<li>检查是否为<code>node_modules</code>中的模块，如果没有，抛出错误</li>\\n</ol>\\n<p>其中装载文件又有如下过程：</p>\\n<ol>\\n<li>文件是<code>X</code>， 装载为<code>JS text</code></li>\\n<li>是一个文件，文件名为<code>X.js</code>，装载为<code>js text</code></li>\\n<li>文件是<code>X.json</code>，parse为<code>js object</code></li>\\n<li>文件是<code>.node</code>，装在为二进制</li>\\n</ol>\\n<p>装载目录的过程如下：</p>\\n<ol>\\n<li><code>X/package.json</code>是否存在，解析<code>package.json</code>中的 <code>main</code>字段的值</li>\\n<li>依次检查<code>X/index.js</code> ,<code>X/index.json</code>, <code>X/index.node</code>是否存在，按照上面的相同规则引入</li>\\n</ol>\\n<p>装载<code>node_modules</code>中的模块的过程如下：</p>\\n<p>执行类似下面的函数，生成标识<code>node_modules</code>目录位置的数组，将当前当前目录通过<code>split</code>方法解析为数组：</p>\\n<pre><code class=\\\"language-js\\\">/demo/tmp/src\\nsplit =>\\n['','demo', 'tmp', 'src','']\\n</code></pre>\\n<p>遍历每个层级，追加字符串<code>'node_modules'</code></p>\\n<pre><code class=\\\"language-js\\\">DIRS: ['demo/node_module','tmp/node_module', 'src/node_modules']\\n</code></pre>\\n<p>返回数组<code>DIRS</code>，遍历上面数组，装载：</p>\\n<pre><code class=\\\"language-js\\\">for each DIR in DIRS:\\n</code></pre>\\n<p>先优先按文件解析<code>（DIR/x）</code>，再按照目录解析。</p>\",\"frontmatter\":{\"title\":\"Node原生模块加载器\",\"date\":\"2016-11-12\",\"tags\":[\"Node\"]}}},\"pathContext\":{\"slug\":\"/2016-11-12---node-module-loader/\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/posts-2016-11-12-node-module-loader.json\n// module id = 433\n// module chunks = 88902746007230"],"sourceRoot":""}