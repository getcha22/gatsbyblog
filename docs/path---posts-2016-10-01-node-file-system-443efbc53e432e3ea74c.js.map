{"version":3,"sources":["webpack:///path---posts-2016-10-01-node-file-system-443efbc53e432e3ea74c.js","webpack:///./.cache/json/posts-2016-10-01-node-file-system.json"],"names":["webpackJsonp","431","module","exports","data","markdownRemark","html","frontmatter","title","date","tags","pathContext","slug"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,67HAAm7HC,aAAgCC,MAAA,WAAAC,KAAA,aAAAC,MAAA,gBAA8DC,aAAgBC,KAAA","file":"path---posts-2016-10-01-node-file-system-443efbc53e432e3ea74c.js","sourcesContent":["webpackJsonp([110826550075370],{\n\n/***/ 431:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h1>Node文件系统</h1>\\n<p><code>Node</code>通过封装基本的<code>POSIX</code>函数来提供文件系统，使用<code>require('fs')</code>来使用这个模块，所有与文件相关的方法，都提供了异步和同步的形式。 异步的方法通常会将一个可选的回调函数作为最后一个参数，回调函数的第一个参数通常留给意外情况，如果操作是成功的，第一个参数将是<code>null</code>或者<code>undeefined</code>。 使用同步方法，对于任何意外都会即时抛出，可以使用<code>try/catch</code>语句来处理意外情况，或者让错误时间向上冒泡。 下面是一个有关异步方法的基本例子：</p>\\n<pre><code class=\\\"language-js\\\">const fs = require('fs');\\nfs.unlink('/tmp/hello', (err) => {\\n  if (err) throw err;\\n  console.log('sucessfully deleted /tmp/hello');\\n}\\n</code></pre>\\n<p>再跟着一个同步的例子：</p>\\n<pre><code class=\\\"language-js\\\">const fs = require('fs');\\nfs.unlink('/tmp/hello');\\nconsole.log('successfully deleted /tmp/hello');\\n</code></pre>\\n<p>使用异步方法时，需要注意异步方法的执行不一定按照书写顺序，比如下面这种写法很容易出错：</p>\\n<pre><code class=\\\"language-js\\\">fs.rename('/tmp/hello', '/tmp/world', (err) => {\\n   if (err) throw err;\\n   console.log('renamed compelte');\\n});\\nfs.stat('/tmp/world', (err, stats) => {if (err) throw err;\\nconsole.log(`stats: ${JSON.stringify(stats)}`)});\\n</code></pre>\\n<p>在这里，很可能<code>fs.stat</code>函数先于<code>fs.rename</code>，这样会出现一些不必要的错误，正确的方法应该是写在回调函数中:</p>\\n<pre><code class=\\\"language-js\\\">fs.rename('/tmp/hello/', '/tmp/world', (err) ss=> {\\n    if (err) throw err;\\n    fs.stat('/tmp/world'),(err, stats) => {\\n        console.log(`stats: ${JSON.stringfy(stats)});\\n    });\\n});\\n</code></pre>\\n<p>执行复杂耗时的方法，强烈建议使用异步版本，同步方法在它们执行结束之前，会一直锁住当前线程，阻断所有操作。 在<code>fs</code>模块中，可以使用相对路径，但是需要留意参照的路径来自于<code>process.cwd()</code>的返回值。 很多<code>fs</code>函数可以忽略掉回调参数，如果这样进行使用，默认会抛出错误，为了跟踪到函数调用的位置，可以设置<code>NODE_DEBUG</code>环境变量：</p>\\n<pre><code class=\\\"language-bash\\\">$ cat script.js\\nfunction bad() {\\n  require('fs').readFile('/');\\n}\\nbad();\\n$ env NODE_DEBUG=fs node script.js\\nfs.js:66\\n        throw err;\\n              ^\\nError: EISDIR, read\\n    at rethrow (fs.js:61:21)\\n    at maybeCallback (fs.js:79:42)\\n    at Object.fs.readFile (fs.js:153:18)\\n    at bad (/path/to/script.js:2:17)\\n    at Object.&#x3C;anonymous> (/path/to/script.js:5:1)\\n    &#x3C;etc.>\\n</code></pre>\\n<p><code>fs.watch(filename[, options][, listener])</code>监听制定文件或者目录的变化情况，<code>filename</code>参数可以是文件或者目录，这个方法返回一个<code>fs.FSWather</code>对象。 第二个参数是可选的，提供的<code>options</code>参数应该是一个对象，里面要求的成员是<code>persistent</code>和<code>recursive</code>，这个两个成员都是布尔类型的值。 用做监听的回调函数有两个参数，分别是(<code>event</code>, <code>filename</code>)，<code>event</code>的值视情况，返回字符串<code>change</code>，<code>rename</code>，文件名指的是触发事件的这个文件。看下面的这个例子：</p>\\n<pre><code class=\\\"language-js\\\">// node.md\\n// 被监听的文件\\nthis is cat.\\n// app.js\\n// 用来监听文件改变\\n    fs.watch('./node.md', (event, filename) => {\\n        console.log('下面是event参数，event参数的类型，filename');\\n        console.log(typeof event);\\n        console.log(filename);\\n    });\\n// node.md\\n// 这里修改了监听的node.md文件\\nthis is dog.\\n// console\\n// 执行结果\\n下面是event参数，event参数的类型，filename\\nchange\\nstring\\nnode.md\\n// node.md => node1.md\\n// 修改文件的名字\\n// console\\n// 执行结果\\n下面是event参数，event参数的类型，filename\\nrename\\nstring\\nnode1.md\\n</code></pre>\\n<p>注意事项： <code>fs.watch</code>并不是跨所有平台的，在某些常见下不一定可用。 第二个参数中的布尔值<code>recursive</code>只在<code>osx</code>和<code>window</code>下可以使用。</p>\\n<h2>可用性</h2>\\n<ul>\\n<li><code>fs.watch</code>依赖于操作系统底层模块，由操作系统底层模块通知Node文件的变化。</li>\\n<li>如果某个操作系统底层模块对于文件的监听本身就有问题，那么<code>fs.watch</code>是无法发挥作用的，比如监听了一些不可靠的目录和文件，网络文件系统，虚拟机系统中的文件。</li>\\n<li>在<code>Linux</code>，<code>osx</code>系统中，<code>fs.watch</code>解析路径成一个索引节点，并且监听这个节点，但是如果监听的节点被删除或者重新创建，那么此时它就成了一个新节点了，<code>watch</code>将会发送一个<code>delete</code>事件，但是仍然监听原来的节点，原来的事件不会响应新节点的改变，这种处理是符合预期的。</li>\\n<li><code>filename</code>参数只支持在<code>Linux</code>和<code>windows</code>上面指定(<code>osx</code>也可以，但是有些情况可能会有异常)，事实上，即便是在可以使用的平台上，也不建议直接使用这个参数，因为在回调函数内部，建议增加一些逻辑判断，看一下<code>filename</code>是否为<code>null</code>，如下面的例子：</li>\\n</ul>\\n<pre><code class=\\\"language-js\\\">fs.watch('somedir', (event, filename) => {\\n    console.log(`event is: ${event}`);\\n    if (filename) {\\n         console.log(`filename provided: ${filename}`);\\n     } else {\\n         console.log('filename not provided');\\n     }\\n});\\n</code></pre>\",\"frontmatter\":{\"title\":\"Node文件系统\",\"date\":\"2016-10-01\",\"tags\":[\"Node\",\"JS\"]}}},\"pathContext\":{\"slug\":\"/2016-10-01---node-file-system/\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---posts-2016-10-01-node-file-system-443efbc53e432e3ea74c.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h1>Node文件系统</h1>\\n<p><code>Node</code>通过封装基本的<code>POSIX</code>函数来提供文件系统，使用<code>require('fs')</code>来使用这个模块，所有与文件相关的方法，都提供了异步和同步的形式。 异步的方法通常会将一个可选的回调函数作为最后一个参数，回调函数的第一个参数通常留给意外情况，如果操作是成功的，第一个参数将是<code>null</code>或者<code>undeefined</code>。 使用同步方法，对于任何意外都会即时抛出，可以使用<code>try/catch</code>语句来处理意外情况，或者让错误时间向上冒泡。 下面是一个有关异步方法的基本例子：</p>\\n<pre><code class=\\\"language-js\\\">const fs = require('fs');\\nfs.unlink('/tmp/hello', (err) => {\\n  if (err) throw err;\\n  console.log('sucessfully deleted /tmp/hello');\\n}\\n</code></pre>\\n<p>再跟着一个同步的例子：</p>\\n<pre><code class=\\\"language-js\\\">const fs = require('fs');\\nfs.unlink('/tmp/hello');\\nconsole.log('successfully deleted /tmp/hello');\\n</code></pre>\\n<p>使用异步方法时，需要注意异步方法的执行不一定按照书写顺序，比如下面这种写法很容易出错：</p>\\n<pre><code class=\\\"language-js\\\">fs.rename('/tmp/hello', '/tmp/world', (err) => {\\n   if (err) throw err;\\n   console.log('renamed compelte');\\n});\\nfs.stat('/tmp/world', (err, stats) => {if (err) throw err;\\nconsole.log(`stats: ${JSON.stringify(stats)}`)});\\n</code></pre>\\n<p>在这里，很可能<code>fs.stat</code>函数先于<code>fs.rename</code>，这样会出现一些不必要的错误，正确的方法应该是写在回调函数中:</p>\\n<pre><code class=\\\"language-js\\\">fs.rename('/tmp/hello/', '/tmp/world', (err) ss=> {\\n    if (err) throw err;\\n    fs.stat('/tmp/world'),(err, stats) => {\\n        console.log(`stats: ${JSON.stringfy(stats)});\\n    });\\n});\\n</code></pre>\\n<p>执行复杂耗时的方法，强烈建议使用异步版本，同步方法在它们执行结束之前，会一直锁住当前线程，阻断所有操作。 在<code>fs</code>模块中，可以使用相对路径，但是需要留意参照的路径来自于<code>process.cwd()</code>的返回值。 很多<code>fs</code>函数可以忽略掉回调参数，如果这样进行使用，默认会抛出错误，为了跟踪到函数调用的位置，可以设置<code>NODE_DEBUG</code>环境变量：</p>\\n<pre><code class=\\\"language-bash\\\">$ cat script.js\\nfunction bad() {\\n  require('fs').readFile('/');\\n}\\nbad();\\n$ env NODE_DEBUG=fs node script.js\\nfs.js:66\\n        throw err;\\n              ^\\nError: EISDIR, read\\n    at rethrow (fs.js:61:21)\\n    at maybeCallback (fs.js:79:42)\\n    at Object.fs.readFile (fs.js:153:18)\\n    at bad (/path/to/script.js:2:17)\\n    at Object.&#x3C;anonymous> (/path/to/script.js:5:1)\\n    &#x3C;etc.>\\n</code></pre>\\n<p><code>fs.watch(filename[, options][, listener])</code>监听制定文件或者目录的变化情况，<code>filename</code>参数可以是文件或者目录，这个方法返回一个<code>fs.FSWather</code>对象。 第二个参数是可选的，提供的<code>options</code>参数应该是一个对象，里面要求的成员是<code>persistent</code>和<code>recursive</code>，这个两个成员都是布尔类型的值。 用做监听的回调函数有两个参数，分别是(<code>event</code>, <code>filename</code>)，<code>event</code>的值视情况，返回字符串<code>change</code>，<code>rename</code>，文件名指的是触发事件的这个文件。看下面的这个例子：</p>\\n<pre><code class=\\\"language-js\\\">// node.md\\n// 被监听的文件\\nthis is cat.\\n// app.js\\n// 用来监听文件改变\\n    fs.watch('./node.md', (event, filename) => {\\n        console.log('下面是event参数，event参数的类型，filename');\\n        console.log(typeof event);\\n        console.log(filename);\\n    });\\n// node.md\\n// 这里修改了监听的node.md文件\\nthis is dog.\\n// console\\n// 执行结果\\n下面是event参数，event参数的类型，filename\\nchange\\nstring\\nnode.md\\n// node.md => node1.md\\n// 修改文件的名字\\n// console\\n// 执行结果\\n下面是event参数，event参数的类型，filename\\nrename\\nstring\\nnode1.md\\n</code></pre>\\n<p>注意事项： <code>fs.watch</code>并不是跨所有平台的，在某些常见下不一定可用。 第二个参数中的布尔值<code>recursive</code>只在<code>osx</code>和<code>window</code>下可以使用。</p>\\n<h2>可用性</h2>\\n<ul>\\n<li><code>fs.watch</code>依赖于操作系统底层模块，由操作系统底层模块通知Node文件的变化。</li>\\n<li>如果某个操作系统底层模块对于文件的监听本身就有问题，那么<code>fs.watch</code>是无法发挥作用的，比如监听了一些不可靠的目录和文件，网络文件系统，虚拟机系统中的文件。</li>\\n<li>在<code>Linux</code>，<code>osx</code>系统中，<code>fs.watch</code>解析路径成一个索引节点，并且监听这个节点，但是如果监听的节点被删除或者重新创建，那么此时它就成了一个新节点了，<code>watch</code>将会发送一个<code>delete</code>事件，但是仍然监听原来的节点，原来的事件不会响应新节点的改变，这种处理是符合预期的。</li>\\n<li><code>filename</code>参数只支持在<code>Linux</code>和<code>windows</code>上面指定(<code>osx</code>也可以，但是有些情况可能会有异常)，事实上，即便是在可以使用的平台上，也不建议直接使用这个参数，因为在回调函数内部，建议增加一些逻辑判断，看一下<code>filename</code>是否为<code>null</code>，如下面的例子：</li>\\n</ul>\\n<pre><code class=\\\"language-js\\\">fs.watch('somedir', (event, filename) => {\\n    console.log(`event is: ${event}`);\\n    if (filename) {\\n         console.log(`filename provided: ${filename}`);\\n     } else {\\n         console.log('filename not provided');\\n     }\\n});\\n</code></pre>\",\"frontmatter\":{\"title\":\"Node文件系统\",\"date\":\"2016-10-01\",\"tags\":[\"Node\",\"JS\"]}}},\"pathContext\":{\"slug\":\"/2016-10-01---node-file-system/\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/posts-2016-10-01-node-file-system.json\n// module id = 431\n// module chunks = 110826550075370"],"sourceRoot":""}