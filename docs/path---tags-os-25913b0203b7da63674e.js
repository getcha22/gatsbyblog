webpackJsonp([0xf8e6c14cef74],{438:function(e,t){e.exports={pathContext:{posts:{Ruby:[{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/es6-string.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/es6-string/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/git-alias.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/git-alias/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/final-summary-2016.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/final-summary-2016/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/git-develop-workflow.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/git-develop-workflow/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/js-logic-operation.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/js-logic-operation/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/js-function-1.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/js-function-1/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/knn-1.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/knn-1/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/knn-2.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/knn-2/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/mysql-operation.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/mysql-operation/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/node-file-system.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/node-file-system/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/numpy-ndarray.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/numpy-ndarray/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/node-module-loader.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/node-module-loader/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/rails-install.md absPath of file >>> MarkdownRemark",excerpt:"Rails 安装记录 本文 ubuntu 版本为 14.04stl 64bit ，参考教程： http://rails-practice.com/content/Chapter_1/1.1.html，  需要翻墙 Git ubuntu安装完毕之后，首先安装git…",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:'<h1>Rails 安装记录</h1>\n<blockquote>\n<p>本文<code>ubuntu</code>版本为<code>14.04stl 64bit</code>，参考教程：<a href="http://rails-practice.com/content/Chapter_1/1.1.html%EF%BC%8C">http://rails-practice.com/content/Chapter_1/1.1.html，</a> 需要翻墙</p>\n</blockquote>\n<h2>Git</h2>\n<p>ubuntu安装完毕之后，首先安装git，以便之后会用到：</p>\n<pre><code class="language-bash">sudo apt-get update\nsudo apt-get install git-core\n</code></pre>\n<p>配置身份信息：</p>\n<pre><code class="language-bash">git config --global user.name "xxx"\ngit config --global user.email "xx@gmail.com"\n</code></pre>\n<p>核实信息是否有误：</p>\n<pre><code class="language-bash">git config --list\n</code></pre>\n<p>此时已经能通过<code>http</code>正常拉去git上的内容，若想进一步配置<code>ssh</code>，可以参考<a href="https://help.github.com/articles/generating-ssh-keys/1323">https://help.github.com/articles/generating-ssh-keys/1323</a></p>\n<h2>RVM</h2>\n<p><code>rails</code>需要先安装<code>Ruby</code>环境，<code>RVM</code>是<code>Ruby</code>管理工具，可以方便的安装、管理、切换多个<code>Ruby</code>，管理<code>Gemset</code>。</p>\n<pre><code class="language-bash">curl -sSL https://get.rvm.io | bash -s stable\n</code></pre>\n<p>此时会有如下提示：</p>\n<pre><code class="language-bash">getcha22@ubuntu:~/Desktop$ curl -sSL https://get.rvm.io | bash -s stable\nDownloading https://github.com/rvm/rvm/archive/1.26.11.tar.gz\nDownloading https://github.com/rvm/rvm/releases/download/1.26.11/1.26.11.tar.gz.asc\ngpg: Signature made Mon 30 Mar 2015 02:52:13 PM PDT using RSA key ID BF04FF17\ngpg: Can\'t check signature: public key not found\nWarning, RVM 1.26.0 introduces signed releases and automated check of signatures when GPG software found.\nAssuming you trust Michal Papis import the mpapis public key (downloading the signatures).\nGPG signature verification failed for \'/home/getcha22/.rvm/archives/rvm-1.26.11.tgz\' - \'https://github.com/rvm/rvm/releases/download/1.26.11/1.26.11.tar.gz.asc\'!\ntry downloading the signatures:\n    gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3\nor if it fails:\n    command curl -sSL https://rvm.io/mpapis.asc | gpg --import -\nthe key can be compared with:\n    https://rvm.io/mpapis.asc\n    https://keybase.io/mpapi\n</code></pre>\n<p>按照提示，执行：</p>\n<pre><code class="language-bash">gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0\n</code></pre>\n<p>依然warring，继续按照提示</p>\n<pre><code class="language-bash">sudo curl -sSL https://rvm.io/mpapis.asc | gpg --import -\n</code></pre>\n<p>提示Thank you for using RVM!，OK，安装成功</p>\n<h2>Ruby</h2>\n<p>重启终端，开始安装<code>Ruby</code>，先使用<code>rvm list known</code>来查看可以按照的<code>Ruby</code>列表，按照参考的教程，我选择使用<code>2.2.0</code></p>\n<pre><code class="language-bash">rvm install 2.2.0123\n</code></pre>\n<p>在我安装的过程中，由于vpn不算稳定，出现了404的提示，我尝试重新安装，这次安装成功。 通过下面的命令检查当前的版本：</p>\n<pre><code class="language-bash">rvm list\n</code></pre>\n<p>提示结果：</p>\n<pre><code class="language-bash">rvm rubies\n   ruby-2.2.0 [ x86_64 ]\n</code></pre>\n<p>再进一步核实<code>ruby</code>的版本， 此时由于<code>ubuntu</code>存在其他版本的<code>ruby</code>，需要制定默认的<code>ruby</code>版本，此时可以使用:</p>\n<pre><code class="language-bash">rvm --default use 2.2.0\n</code></pre>\n<p>发现有错误提示<code>RVM is not a function</code>,这个问题是由于<code>ubuntu</code>系统的终端导致 ，为了解决这个问题，需要<code>Run command as login shell</code>，参考这个链接进行解决：<a href="https://rvm.io/integration/gnome-terminal">https://rvm.io/integration/gnome-terminal</a> ，之后重新制定默认版本，提示OK。</p>\n<pre><code class="language-bash">ruby 2.2.0p0 (2014-12-25 revision 49005) [x86_64-linux]\n</code></pre>\n<p>到此为止，<code>ruby</code>的安装告一段落，开始进行<code>Rails</code>的安装。</p>\n<h2>Rails</h2>\n<p>先设置<code>Gemset</code>。<code>Gemset</code> 是一个独立的 <code>Gem</code> 集合，可以为每个项目设置自己的 <code>Gemset</code>，而不会相互干扰：</p>\n<pre><code class="language-bash">rvm gemset create rails4.2\nrvm use 2.2.0@rails4.2 --default\ngem install rails -v 4.2.0 --no-ri --no-rdoc\n</code></pre>\n<p>出现如下问题:</p>\n<pre><code class="language-bash">ERROR:  While executing gem ... (Gem::RemoteFetcher::FetchError)\n    Errno::ECONNRESET: Connection reset by peer - connect(2) for "rubygems.global.ssl.fastly.net" port 443 (https://api.rubygems.org/quick/Marshal.4.8/rails-4.2.4.gemspec.rz)\n</code></pre>\n<p>遇到这个问题，还提示端口是443.可能是<code>gem</code>源导致的网络问题，尝试修改https为http。通过以下命令:</p>\n<pre><code class="language-bash">gem sources\ngem sources -a url //添加\ngem sources -r url  //删除\n更新source cache\ngem sources -u\n// other :\ngem sources --add https://ruby.taobao.org/ --remove https://rubygems.org/\ngem sources -l\n</code></pre>\n<p>之后重新进行安装，最后结束安装</p>\n<pre><code class="language-bash">Successfully installed rails-4.2.0\n30 gems installed\n</code></pre>\n<h2>其他情况</h2>\n<ul>\n<li><code>bundle install</code>如果遇到问题，可以先把<code>gemfile</code>中的<code>source</code>修改成<code>http</code>开头即可，如果在操作时提示需要<code>javascript run time</code>，只要安装<code>Node.js</code>即可</li>\n</ul>',fields:{slug:"/rails-install/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/2015-07-10---anaconda-introduction/index.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/2015-07-10---anaconda-introduction/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/shadowsocks-install.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/shadowsocks-install/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/tmux-operation.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/tmux-operation/"}}],Rails:[{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/es6-string.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/es6-string/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/git-alias.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/git-alias/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/final-summary-2016.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/final-summary-2016/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/git-develop-workflow.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/git-develop-workflow/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/js-logic-operation.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/js-logic-operation/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/js-function-1.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/js-function-1/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/knn-1.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/knn-1/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/knn-2.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/knn-2/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/mysql-operation.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/mysql-operation/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/node-file-system.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/node-file-system/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/numpy-ndarray.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/numpy-ndarray/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/node-module-loader.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/node-module-loader/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/rails-install.md absPath of file >>> MarkdownRemark",excerpt:"Rails 安装记录 本文 ubuntu 版本为 14.04stl 64bit ，参考教程： http://rails-practice.com/content/Chapter_1/1.1.html，  需要翻墙 Git ubuntu安装完毕之后，首先安装git…",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:'<h1>Rails 安装记录</h1>\n<blockquote>\n<p>本文<code>ubuntu</code>版本为<code>14.04stl 64bit</code>，参考教程：<a href="http://rails-practice.com/content/Chapter_1/1.1.html%EF%BC%8C">http://rails-practice.com/content/Chapter_1/1.1.html，</a> 需要翻墙</p>\n</blockquote>\n<h2>Git</h2>\n<p>ubuntu安装完毕之后，首先安装git，以便之后会用到：</p>\n<pre><code class="language-bash">sudo apt-get update\nsudo apt-get install git-core\n</code></pre>\n<p>配置身份信息：</p>\n<pre><code class="language-bash">git config --global user.name "xxx"\ngit config --global user.email "xx@gmail.com"\n</code></pre>\n<p>核实信息是否有误：</p>\n<pre><code class="language-bash">git config --list\n</code></pre>\n<p>此时已经能通过<code>http</code>正常拉去git上的内容，若想进一步配置<code>ssh</code>，可以参考<a href="https://help.github.com/articles/generating-ssh-keys/1323">https://help.github.com/articles/generating-ssh-keys/1323</a></p>\n<h2>RVM</h2>\n<p><code>rails</code>需要先安装<code>Ruby</code>环境，<code>RVM</code>是<code>Ruby</code>管理工具，可以方便的安装、管理、切换多个<code>Ruby</code>，管理<code>Gemset</code>。</p>\n<pre><code class="language-bash">curl -sSL https://get.rvm.io | bash -s stable\n</code></pre>\n<p>此时会有如下提示：</p>\n<pre><code class="language-bash">getcha22@ubuntu:~/Desktop$ curl -sSL https://get.rvm.io | bash -s stable\nDownloading https://github.com/rvm/rvm/archive/1.26.11.tar.gz\nDownloading https://github.com/rvm/rvm/releases/download/1.26.11/1.26.11.tar.gz.asc\ngpg: Signature made Mon 30 Mar 2015 02:52:13 PM PDT using RSA key ID BF04FF17\ngpg: Can\'t check signature: public key not found\nWarning, RVM 1.26.0 introduces signed releases and automated check of signatures when GPG software found.\nAssuming you trust Michal Papis import the mpapis public key (downloading the signatures).\nGPG signature verification failed for \'/home/getcha22/.rvm/archives/rvm-1.26.11.tgz\' - \'https://github.com/rvm/rvm/releases/download/1.26.11/1.26.11.tar.gz.asc\'!\ntry downloading the signatures:\n    gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3\nor if it fails:\n    command curl -sSL https://rvm.io/mpapis.asc | gpg --import -\nthe key can be compared with:\n    https://rvm.io/mpapis.asc\n    https://keybase.io/mpapi\n</code></pre>\n<p>按照提示，执行：</p>\n<pre><code class="language-bash">gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0\n</code></pre>\n<p>依然warring，继续按照提示</p>\n<pre><code class="language-bash">sudo curl -sSL https://rvm.io/mpapis.asc | gpg --import -\n</code></pre>\n<p>提示Thank you for using RVM!，OK，安装成功</p>\n<h2>Ruby</h2>\n<p>重启终端，开始安装<code>Ruby</code>，先使用<code>rvm list known</code>来查看可以按照的<code>Ruby</code>列表，按照参考的教程，我选择使用<code>2.2.0</code></p>\n<pre><code class="language-bash">rvm install 2.2.0123\n</code></pre>\n<p>在我安装的过程中，由于vpn不算稳定，出现了404的提示，我尝试重新安装，这次安装成功。 通过下面的命令检查当前的版本：</p>\n<pre><code class="language-bash">rvm list\n</code></pre>\n<p>提示结果：</p>\n<pre><code class="language-bash">rvm rubies\n   ruby-2.2.0 [ x86_64 ]\n</code></pre>\n<p>再进一步核实<code>ruby</code>的版本， 此时由于<code>ubuntu</code>存在其他版本的<code>ruby</code>，需要制定默认的<code>ruby</code>版本，此时可以使用:</p>\n<pre><code class="language-bash">rvm --default use 2.2.0\n</code></pre>\n<p>发现有错误提示<code>RVM is not a function</code>,这个问题是由于<code>ubuntu</code>系统的终端导致 ，为了解决这个问题，需要<code>Run command as login shell</code>，参考这个链接进行解决：<a href="https://rvm.io/integration/gnome-terminal">https://rvm.io/integration/gnome-terminal</a> ，之后重新制定默认版本，提示OK。</p>\n<pre><code class="language-bash">ruby 2.2.0p0 (2014-12-25 revision 49005) [x86_64-linux]\n</code></pre>\n<p>到此为止，<code>ruby</code>的安装告一段落，开始进行<code>Rails</code>的安装。</p>\n<h2>Rails</h2>\n<p>先设置<code>Gemset</code>。<code>Gemset</code> 是一个独立的 <code>Gem</code> 集合，可以为每个项目设置自己的 <code>Gemset</code>，而不会相互干扰：</p>\n<pre><code class="language-bash">rvm gemset create rails4.2\nrvm use 2.2.0@rails4.2 --default\ngem install rails -v 4.2.0 --no-ri --no-rdoc\n</code></pre>\n<p>出现如下问题:</p>\n<pre><code class="language-bash">ERROR:  While executing gem ... (Gem::RemoteFetcher::FetchError)\n    Errno::ECONNRESET: Connection reset by peer - connect(2) for "rubygems.global.ssl.fastly.net" port 443 (https://api.rubygems.org/quick/Marshal.4.8/rails-4.2.4.gemspec.rz)\n</code></pre>\n<p>遇到这个问题，还提示端口是443.可能是<code>gem</code>源导致的网络问题，尝试修改https为http。通过以下命令:</p>\n<pre><code class="language-bash">gem sources\ngem sources -a url //添加\ngem sources -r url  //删除\n更新source cache\ngem sources -u\n// other :\ngem sources --add https://ruby.taobao.org/ --remove https://rubygems.org/\ngem sources -l\n</code></pre>\n<p>之后重新进行安装，最后结束安装</p>\n<pre><code class="language-bash">Successfully installed rails-4.2.0\n30 gems installed\n</code></pre>\n<h2>其他情况</h2>\n<ul>\n<li><code>bundle install</code>如果遇到问题，可以先把<code>gemfile</code>中的<code>source</code>修改成<code>http</code>开头即可，如果在操作时提示需要<code>javascript run time</code>，只要安装<code>Node.js</code>即可</li>\n</ul>',fields:{slug:"/rails-install/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/2015-07-10---anaconda-introduction/index.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/2015-07-10---anaconda-introduction/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/shadowsocks-install.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/shadowsocks-install/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/tmux-operation.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/tmux-operation/"}}],"installtion-record":[{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/es6-string.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/es6-string/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/git-alias.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/git-alias/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/final-summary-2016.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/final-summary-2016/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/git-develop-workflow.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/git-develop-workflow/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/js-logic-operation.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/js-logic-operation/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/js-function-1.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/js-function-1/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/knn-1.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/knn-1/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/knn-2.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/knn-2/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/mysql-operation.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/mysql-operation/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/node-file-system.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/node-file-system/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/numpy-ndarray.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/numpy-ndarray/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/node-module-loader.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/node-module-loader/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/rails-install.md absPath of file >>> MarkdownRemark",excerpt:"Rails 安装记录 本文 ubuntu 版本为 14.04stl 64bit ，参考教程： http://rails-practice.com/content/Chapter_1/1.1.html，  需要翻墙 Git ubuntu安装完毕之后，首先安装git…",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:'<h1>Rails 安装记录</h1>\n<blockquote>\n<p>本文<code>ubuntu</code>版本为<code>14.04stl 64bit</code>，参考教程：<a href="http://rails-practice.com/content/Chapter_1/1.1.html%EF%BC%8C">http://rails-practice.com/content/Chapter_1/1.1.html，</a> 需要翻墙</p>\n</blockquote>\n<h2>Git</h2>\n<p>ubuntu安装完毕之后，首先安装git，以便之后会用到：</p>\n<pre><code class="language-bash">sudo apt-get update\nsudo apt-get install git-core\n</code></pre>\n<p>配置身份信息：</p>\n<pre><code class="language-bash">git config --global user.name "xxx"\ngit config --global user.email "xx@gmail.com"\n</code></pre>\n<p>核实信息是否有误：</p>\n<pre><code class="language-bash">git config --list\n</code></pre>\n<p>此时已经能通过<code>http</code>正常拉去git上的内容，若想进一步配置<code>ssh</code>，可以参考<a href="https://help.github.com/articles/generating-ssh-keys/1323">https://help.github.com/articles/generating-ssh-keys/1323</a></p>\n<h2>RVM</h2>\n<p><code>rails</code>需要先安装<code>Ruby</code>环境，<code>RVM</code>是<code>Ruby</code>管理工具，可以方便的安装、管理、切换多个<code>Ruby</code>，管理<code>Gemset</code>。</p>\n<pre><code class="language-bash">curl -sSL https://get.rvm.io | bash -s stable\n</code></pre>\n<p>此时会有如下提示：</p>\n<pre><code class="language-bash">getcha22@ubuntu:~/Desktop$ curl -sSL https://get.rvm.io | bash -s stable\nDownloading https://github.com/rvm/rvm/archive/1.26.11.tar.gz\nDownloading https://github.com/rvm/rvm/releases/download/1.26.11/1.26.11.tar.gz.asc\ngpg: Signature made Mon 30 Mar 2015 02:52:13 PM PDT using RSA key ID BF04FF17\ngpg: Can\'t check signature: public key not found\nWarning, RVM 1.26.0 introduces signed releases and automated check of signatures when GPG software found.\nAssuming you trust Michal Papis import the mpapis public key (downloading the signatures).\nGPG signature verification failed for \'/home/getcha22/.rvm/archives/rvm-1.26.11.tgz\' - \'https://github.com/rvm/rvm/releases/download/1.26.11/1.26.11.tar.gz.asc\'!\ntry downloading the signatures:\n    gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3\nor if it fails:\n    command curl -sSL https://rvm.io/mpapis.asc | gpg --import -\nthe key can be compared with:\n    https://rvm.io/mpapis.asc\n    https://keybase.io/mpapi\n</code></pre>\n<p>按照提示，执行：</p>\n<pre><code class="language-bash">gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0\n</code></pre>\n<p>依然warring，继续按照提示</p>\n<pre><code class="language-bash">sudo curl -sSL https://rvm.io/mpapis.asc | gpg --import -\n</code></pre>\n<p>提示Thank you for using RVM!，OK，安装成功</p>\n<h2>Ruby</h2>\n<p>重启终端，开始安装<code>Ruby</code>，先使用<code>rvm list known</code>来查看可以按照的<code>Ruby</code>列表，按照参考的教程，我选择使用<code>2.2.0</code></p>\n<pre><code class="language-bash">rvm install 2.2.0123\n</code></pre>\n<p>在我安装的过程中，由于vpn不算稳定，出现了404的提示，我尝试重新安装，这次安装成功。 通过下面的命令检查当前的版本：</p>\n<pre><code class="language-bash">rvm list\n</code></pre>\n<p>提示结果：</p>\n<pre><code class="language-bash">rvm rubies\n   ruby-2.2.0 [ x86_64 ]\n</code></pre>\n<p>再进一步核实<code>ruby</code>的版本， 此时由于<code>ubuntu</code>存在其他版本的<code>ruby</code>，需要制定默认的<code>ruby</code>版本，此时可以使用:</p>\n<pre><code class="language-bash">rvm --default use 2.2.0\n</code></pre>\n<p>发现有错误提示<code>RVM is not a function</code>,这个问题是由于<code>ubuntu</code>系统的终端导致 ，为了解决这个问题，需要<code>Run command as login shell</code>，参考这个链接进行解决：<a href="https://rvm.io/integration/gnome-terminal">https://rvm.io/integration/gnome-terminal</a> ，之后重新制定默认版本，提示OK。</p>\n<pre><code class="language-bash">ruby 2.2.0p0 (2014-12-25 revision 49005) [x86_64-linux]\n</code></pre>\n<p>到此为止，<code>ruby</code>的安装告一段落，开始进行<code>Rails</code>的安装。</p>\n<h2>Rails</h2>\n<p>先设置<code>Gemset</code>。<code>Gemset</code> 是一个独立的 <code>Gem</code> 集合，可以为每个项目设置自己的 <code>Gemset</code>，而不会相互干扰：</p>\n<pre><code class="language-bash">rvm gemset create rails4.2\nrvm use 2.2.0@rails4.2 --default\ngem install rails -v 4.2.0 --no-ri --no-rdoc\n</code></pre>\n<p>出现如下问题:</p>\n<pre><code class="language-bash">ERROR:  While executing gem ... (Gem::RemoteFetcher::FetchError)\n    Errno::ECONNRESET: Connection reset by peer - connect(2) for "rubygems.global.ssl.fastly.net" port 443 (https://api.rubygems.org/quick/Marshal.4.8/rails-4.2.4.gemspec.rz)\n</code></pre>\n<p>遇到这个问题，还提示端口是443.可能是<code>gem</code>源导致的网络问题，尝试修改https为http。通过以下命令:</p>\n<pre><code class="language-bash">gem sources\ngem sources -a url //添加\ngem sources -r url  //删除\n更新source cache\ngem sources -u\n// other :\ngem sources --add https://ruby.taobao.org/ --remove https://rubygems.org/\ngem sources -l\n</code></pre>\n<p>之后重新进行安装，最后结束安装</p>\n<pre><code class="language-bash">Successfully installed rails-4.2.0\n30 gems installed\n</code></pre>\n<h2>其他情况</h2>\n<ul>\n<li><code>bundle install</code>如果遇到问题，可以先把<code>gemfile</code>中的<code>source</code>修改成<code>http</code>开头即可，如果在操作时提示需要<code>javascript run time</code>，只要安装<code>Node.js</code>即可</li>\n</ul>',fields:{slug:"/rails-install/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/2015-07-10---anaconda-introduction/index.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/2015-07-10---anaconda-introduction/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/shadowsocks-install.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/shadowsocks-install/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/tmux-operation.md absPath of file >>> MarkdownRemark",excerpt:"",frontmatter:{title:"Rails 安装记录",date:"2015-07-10",tags:["Ruby","Rails","installtion-record"]},html:"",fields:{slug:"/tmux-operation/"}}],JS:[{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/js-function-2.md absPath of file >>> MarkdownRemark",excerpt:"再探JS函数 函数是JS的核心概念，主要用来封装语句，封装单独的功能。 函数参数 函数不在意它本身到底接收多少参数，不关心最后会使用多少参数。因为函数只会接收一个数组，函数可以通过 arguments…",frontmatter:{title:"再探JS函数",date:"2016-01-10",tags:["JS","function"]},html:'<h1>再探JS函数</h1>\n<p>函数是JS的核心概念，主要用来封装语句，封装单独的功能。</p>\n<h2>函数参数</h2>\n<p>函数不在意它本身到底接收多少参数，不关心最后会使用多少参数。因为函数只会接收一个数组，函数可以通过<code>arguments</code>属性来访问这个参数数组。关于这个数组，他其实是个对象，如下:</p>\n<pre><code class="language-js">var a = function () {var b= 1; var c = 0} //a是一个函数\ntypeof a.arguments  // Object\n</code></pre>\n<p>但是为什么又说它是数组呢，因为它本身很数组很像，可以通过方括号加数字的方法来访问具体的参数，同时还有数组对象有的<code>length</code>属性。一个有趣的例子：</p>\n<pre><code class="language-js">function a (){\n  console.log("hello" +　arguments[0] + arguments[1]);\n}\na("hao","xiang"); //hellohaoxiang\n</code></pre>\n<p>这样子依然是有效的，在函数执行的时候，通过<code>arguments</code>对象的<code>length</code>属性可以知道被传递的参数个数，还有个更有趣的例子，是关于<code>arguments</code>的同步性的：</p>\n<pre><code class="language-js">function doAdd (num1,num2){\n  arguments[1]=10;\n  alert(arguments[0] + num2);\n  }\n  doAdd(1,1); //11，arguments[1]和num2是同步的\n</code></pre>\n<p>参数就是局部变量，对于函数来说，传递参数是按值的，基本类型的很好理解，相当于变量的复制。对于引用类型来说，还需要留意到此时依然是按值传递的，这个值依然是指引用的内存地址值。证明方法：需要先创建一个对象，传递函数中，此时在函数内部修改对象的属性，此时内外是一致的，因为他们是一种的一个对象。但是此时如果将参数重新初始化为一个对象，那么也就是说此时参数已经指向另一个变量了，和之前的一切无关。</p>\n<h2>函数相关属性</h2>\n<p><code>arguments</code>属性有一个叫做<code>callee</code>的指针，这个指针指向拥有这个<code>arguments</code>对象的函数。主要用来解除耦合，下面是关于递归算法的例子</p>\n<pre><code class="language-js">function fac (num) {\n    switch (num){\n        case 1 :\n        return 1;\n        default: return num * arguments.callee(num-1);\n    }\n}\n</code></pre>\n<p>函数的另外一个内部属性是<code>this</code>对象，<code>this</code>引用的是函数据以执行的环境对象，<code>this</code>是包含它的函数作为方法被调用是所属的对象 = 包含它的函数 + 作为方法被调用时 + 所属的对象。</p>\n<h2>函数的方法</h2>\n<p>主要有<code>apply</code>,<code>call</code>与<code>bind</code></p>\n<h3><code>apply()</code>与<code>call()</code>：</h3>\n<p>表示在特定的作用域内调用函数，与<code>call()</code>的区别在于<code>call</code>在使用时必须指定参数。</p>\n<h2><code>bind()</code></h2>\n<p>这个方法可以用来创建一个新的实例，实例的<code>this</code>值会被绑定到传给<code>bind()</code>的值上</p>\n<h2>细碎的小点</h2>\n<ul>\n<li><code>return</code>语句，一旦<code>return</code>，后续的语句不会继续执行了，不加<code>return</code>的话，函数默认的返回值是<code>undefined</code>。</li>\n</ul>',fields:{slug:"/js-function-2/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/js-in.md absPath of file >>> MarkdownRemark",excerpt:"JavaScript 中的 in 关键字 在 JavaScript 中,我经常会使用 for(key in ..) 语句来遍历对象的 key  ,这是一种很常用的方式.\n这里需要留意, 其实 for(.. in ..) 语句也可以用来遍历数组,其中的 key…",frontmatter:{title:"JavaScript 中的 in 关键字",date:"2016-02-07",tags:["JS"]},html:"<h1>JavaScript 中的 in 关键字</h1>\n<p>在<code>JavaScript</code>中,我经常会使用<code>for(key in ..)</code>语句来遍历对象的<code>key</code> ,这是一种很常用的方式.\n这里需要留意, 其实<code>for(.. in ..)</code>语句也可以用来遍历数组,其中的<code>key</code>就是数组的<code>index</code>(索引值,0开始) 。\n除了在<code>for(.. in ..)</code>语句中使用,<code>in</code>也可以作为一个单独的关键字使用,用来判断某个属性或者元素是否存在与数组或者对象.一般会用在判断语句中,下面进行说明。</p>\n<h2>数组</h2>\n<pre><code class=\"language-js\">var pig = ['head', 'hand', 'leg'];\nconsole.log('head' in pig); // false\nconsole.log('0' in pig); // true\nconsole.log(4 in pig); // false\n</code></pre>\n<p>通过<code>in</code>操作判断数组是否存在某个索引,逐个分析：</p>\n<ol>\n<li>判断<code>head</code>字符串是否为<code>pig</code>的索引,很明显,索引应该是数字,所以<code>false</code>。</li>\n<li>判断<code>pig</code>是否有索引为字符串 '0',可以看到最后判断结果为 true, 这是因为执行<code>in</code>关键字判断时, <code>JS</code>引擎进行了隐式转换。</li>\n<li>判断数字<code>4</code>是否为<code>pig</code>数组的索引,结果<code>false</code>。</li>\n</ol>\n<h2>对象</h2>\n<pre><code class=\"language-js\">var pig = {head: 'head', hand: 'head', leg: 'leg'};\nconsole.log(head in pig); // false\nconsole.log('head' in pig); // true\n</code></pre>\n<p>通过<code>in</code>操作判断对象是否有某个键名,逐个分析：</p>\n<ol>\n<li>判断变量<code>head</code>是否为<code>pig</code>的键名, <code>head</code>是一个未声明未赋值的变量,当然不会是<code>pig</code>的键名,返回<code>false</code>。\n判断字符串<code>head</code>是否为<code>pig</code>的键名,返回<code>true</code>。</li>\n</ol>",fields:{slug:"/js-in/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/react-summary.md absPath of file >>> MarkdownRemark",excerpt:"React学习总结 参考官方文档，整理一些应该被重视的知识点 React中的事件相关 类似HTML中事件的使用方法，可以直接将事件处理函数作为属性值，赋给用驼峰式命名的事件属性。之后的事情交给React，React…",frontmatter:{title:"React学习总结",date:"2016-04-21",tags:["React","JS"]},html:'<h1>React学习总结</h1>\n<p>参考官方文档，整理一些应该被重视的知识点</p>\n<h2>React中的事件相关</h2>\n<p>类似HTML中事件的使用方法，可以直接将事件处理函数作为属性值，赋给用驼峰式命名的事件属性。之后的事情交给React，React自己有一个事件系统，它可以保证事件在所有浏览器中的一致性，React知道如何去冒泡和捕获事件，这个实现是根据w3c的规范，不管使用的是什么浏览器</p>\n<h2>State 相关</h2>\n<p>State是可以用来动态渲染，和props是一对好基友。</p>\n<h3>State 的异步工作方式</h3>\n<p><code>setState</code> 方法本身是异步的，有一种常见的方式是当React数据改变时，通过 setState(data,callback) 这个方法会将新数据合并到this.state对象上，之后重新渲染组件。当组件结束了重新渲染(re-render），可选的第二个参数callback会被执行。</p>\n<h3>组件在什么时候需要State</h3>\n<p>大多数的组件应该简单的通过props获取数据，之后渲染组件，然而有时候会需要一些复杂的数据处理，比如说响应用户的操作，一个请求，此时需要用到state。但尽可能多的让组件无状态话，减少冗余。一种常见的模式是创建许多无状态的组件，它们仅仅负责渲染数据，有一个拥有状态组件在它们层级之上，经过一系列的逻辑处理，通过props将state传递给它的子组件。有状态的组件囊括了尽可能多的逻辑，而无状态的组件仅仅负责渲染数据。</p>\n<h3>哪些数据应该作为State</h3>\n<p>尽量使用 props 作为唯一的数据源，事件处理函数会响应用户的事件，此时可能会更新影响用户界面的数据，这些数据应该被 State 包含。真实环境下，这个数据应该很小且可以被 JSON 序列化 。\n在创建包含状态的组件时，让它尽可能少的包含状态，并且将这些状态存入 this.state 对象中，后续的 render 方法再根据可能有的状态来计算出需要的其他数据，逻辑处理在 render ，通过状态来计算 render 的内容。</p>\n<h2>组件复用</h2>\n<p>React 因为新的 render 而导致 DOM 发生更新的过程称为组件校正，这个校正过程是根据组件的顺序决定，比如</p>\n<pre><code class="language-html">// Render Pass 1\n&#x3C;Card>\n    &#x3C;p>Paragraph 1&#x3C;/p>\n    &#x3C;p>Paragraph 2&#x3C;/p>\n&#x3C;/Card>\n// Render Pass 2\n&#x3C;Card>\n    &#x3C;p>Paragraph 2&#x3C;/p>\n&#x3C;/Card>\n</code></pre>\n<p>看起来像是 React 通过 diff 删除了第一个标签，但实际上 React 按照组件的顺序，修改了第一个标签的文本，删除了第二个组件。考虑一个组件由很多状态决定，内部的DOM需要来回的切换，由于组件校正的原理，可能会有些性能问题。此时可以选择为组件添加 <code>display: none</code> ，而不是直接选择删除。有些情况可能比较复杂，比如说有一个很长的列表，需要不断的重排序或者向首尾插入删除新子组件，这种情况如果按照顺序来校正，可能会出现性能问题，此时可以为这些子组件指定独一无二的key。当 React 校正这些组件的时候，就会直接重排序或者销毁，而不是按照顺序，修改子组件的内容来校正。</p>\n<h2>PropTypes</h2>\n<p>当项目越来越大，组件的复用越来越频繁，为了确保每次复用接收到的 props 是可用的，需要指定PropTypes。</p>\n<p>类似于 export，React.PropTypes 对象导出很多验证器，这些验证器可以保证传递来的 props 是正确的。\n当一个不可用的值被传递给当前组件的 props，那么在控制台中就会显示异常。\n具体的属性可以参考这个<a href="http://facebook.github.io/react/docs/reusable-components.html">页面</a>，可以为对象或者数组指定具体的内部 Child。</p>',
fields:{slug:"/react-summary/"}}],function:[{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/js-function-2.md absPath of file >>> MarkdownRemark",excerpt:"再探JS函数 函数是JS的核心概念，主要用来封装语句，封装单独的功能。 函数参数 函数不在意它本身到底接收多少参数，不关心最后会使用多少参数。因为函数只会接收一个数组，函数可以通过 arguments…",frontmatter:{title:"再探JS函数",date:"2016-01-10",tags:["JS","function"]},html:'<h1>再探JS函数</h1>\n<p>函数是JS的核心概念，主要用来封装语句，封装单独的功能。</p>\n<h2>函数参数</h2>\n<p>函数不在意它本身到底接收多少参数，不关心最后会使用多少参数。因为函数只会接收一个数组，函数可以通过<code>arguments</code>属性来访问这个参数数组。关于这个数组，他其实是个对象，如下:</p>\n<pre><code class="language-js">var a = function () {var b= 1; var c = 0} //a是一个函数\ntypeof a.arguments  // Object\n</code></pre>\n<p>但是为什么又说它是数组呢，因为它本身很数组很像，可以通过方括号加数字的方法来访问具体的参数，同时还有数组对象有的<code>length</code>属性。一个有趣的例子：</p>\n<pre><code class="language-js">function a (){\n  console.log("hello" +　arguments[0] + arguments[1]);\n}\na("hao","xiang"); //hellohaoxiang\n</code></pre>\n<p>这样子依然是有效的，在函数执行的时候，通过<code>arguments</code>对象的<code>length</code>属性可以知道被传递的参数个数，还有个更有趣的例子，是关于<code>arguments</code>的同步性的：</p>\n<pre><code class="language-js">function doAdd (num1,num2){\n  arguments[1]=10;\n  alert(arguments[0] + num2);\n  }\n  doAdd(1,1); //11，arguments[1]和num2是同步的\n</code></pre>\n<p>参数就是局部变量，对于函数来说，传递参数是按值的，基本类型的很好理解，相当于变量的复制。对于引用类型来说，还需要留意到此时依然是按值传递的，这个值依然是指引用的内存地址值。证明方法：需要先创建一个对象，传递函数中，此时在函数内部修改对象的属性，此时内外是一致的，因为他们是一种的一个对象。但是此时如果将参数重新初始化为一个对象，那么也就是说此时参数已经指向另一个变量了，和之前的一切无关。</p>\n<h2>函数相关属性</h2>\n<p><code>arguments</code>属性有一个叫做<code>callee</code>的指针，这个指针指向拥有这个<code>arguments</code>对象的函数。主要用来解除耦合，下面是关于递归算法的例子</p>\n<pre><code class="language-js">function fac (num) {\n    switch (num){\n        case 1 :\n        return 1;\n        default: return num * arguments.callee(num-1);\n    }\n}\n</code></pre>\n<p>函数的另外一个内部属性是<code>this</code>对象，<code>this</code>引用的是函数据以执行的环境对象，<code>this</code>是包含它的函数作为方法被调用是所属的对象 = 包含它的函数 + 作为方法被调用时 + 所属的对象。</p>\n<h2>函数的方法</h2>\n<p>主要有<code>apply</code>,<code>call</code>与<code>bind</code></p>\n<h3><code>apply()</code>与<code>call()</code>：</h3>\n<p>表示在特定的作用域内调用函数，与<code>call()</code>的区别在于<code>call</code>在使用时必须指定参数。</p>\n<h2><code>bind()</code></h2>\n<p>这个方法可以用来创建一个新的实例，实例的<code>this</code>值会被绑定到传给<code>bind()</code>的值上</p>\n<h2>细碎的小点</h2>\n<ul>\n<li><code>return</code>语句，一旦<code>return</code>，后续的语句不会继续执行了，不加<code>return</code>的话，函数默认的返回值是<code>undefined</code>。</li>\n</ul>',fields:{slug:"/js-function-2/"}}],os:[{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/os-1.md absPath of file >>> MarkdownRemark",excerpt:"操作系统（一） 按下电源之后，如何加载操作系统？ 操作系统如何与外设、应用程序交互？ BIOS、BootLoader、OS的关系 BIOS即基本输入输出系统，存在CMOS中，OS即操作系统，操作系统存在硬盘中。硬盘中还存另一个简单的小程序BootLoader，它可以将OS…",frontmatter:{title:"操作系统（一）",date:"2018-01-10",tags:["os","Bootloader"]},html:'<h1>操作系统（一）</h1>\n<ol>\n<li>按下电源之后，如何加载操作系统？</li>\n<li>操作系统如何与外设、应用程序交互？</li>\n</ol>\n<h2>BIOS、BootLoader、OS的关系</h2>\n<p>BIOS即基本输入输出系统，存在CMOS中，OS即操作系统，操作系统存在硬盘中。硬盘中还存另一个简单的小程序BootLoader，它可以将OS从硬盘放到内存中去，使cpu可以执行OS相关的代码。</p>\n<ol>\n<li>一开始加电，CPU从一个预先约定的地址处开始执行BIOS程序，进行加电自检（显卡，键鼠，硬盘），检查成功，即外设均可正常工作，接着要将BootLoader程序放到内存中去。</li>\n<li>BootLoader放在硬盘内的某个指定位置，BIOS从这位置开始，连续读取其后的512B的代码和数据，放入内存之中，CPU按照BootLoader的代码开始执行。</li>\n<li>此时CPU的控制权由BootLoader掌控，该程序会找到硬盘中OS程序的起始扇区和长度，将这块区域从硬盘中读到内存中去，CPU调到OS的起始代码处开始。</li>\n</ol>\n<h2>操作系统如何与设备和程序交互</h2>\n<table>\n<thead>\n<tr>\n<th>对象</th>\n<th>交互方式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>面向外设</td>\n<td>中断、I/O</td>\n</tr>\n<tr>\n<td>面向程序</td>\n<td>系统调用、异常</td>\n</tr>\n</tbody>\n</table>\n<h3>基本概念</h3>\n<ul>\n<li>系统调用：系统的资源由操作系统统一掌控，应用程序需要这些资源时，要向系统主动提出服务请求，之后由操作系统来完成相应的功能。</li>\n<li>异常：同样由应用程序产生的，但是并非主动产生，而是在执行过程中，出现了意想不到的事情，必须由操作系统解救。</li>\n<li>中断：来源于外设，当外设执行完上一轮CPU分配的任务后，请求下一轮的任务，通过中断机制，使操作系统能感知外设发出的请求。</li>\n</ul>\n<h3>为什么应用程序不能直接找外设？</h3>\n<ul>\n<li>安全：操作系统是特殊的软件，是可信程序，而应用程序则不是。</li>\n<li>抽象：操作系统为应用提供简单一致的接口，不需要针对不同的外设开发不同的软件，屏蔽底层设备的差异性，提供统一的接口。</li>\n</ul>\n<h3>区别联系</h3>\n<table>\n<thead>\n<tr>\n<th align="left">源头</th>\n<th></th>\n<th align="left">处理时间</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align="left">中  断</td>\n<td>非CPU执行指令时产生的，由设备产生，例如设备上一轮的I/O处理完成了，希望再为分配下一轮的任务</td>\n<td align="left">异步,即不知道外设什么时候发出中断，什么时候返回给外设下一轮任务也未知</td>\n</tr>\n<tr>\n<td align="left">异  常</td>\n<td>CPU执行应用程序的指令时产生，被动产生的，举例：越界访问，非法操作码等</td>\n<td align="left">同步，即执行到特定的指令一定会发生，且要立即处理</td>\n</tr>\n<tr>\n<td align="left">系统调用</td>\n<td>CPU执行应用程序的指令时产生，主动产生的，举例：对文件的增删改查</td>\n<td align="left">同步和异步，即执行到特定的指令，应用程序发出调用，比如网络请求这是同步的，但之后可以继续执行其余指令，不必一直等待</td>\n</tr>\n</tbody>\n</table>\n<h3>处理过程</h3>\n<h4>中断处理过程</h4>\n<ol>\n<li>外设完成任务，在某个寄存器或者某个特定的位置设置一个中断标记。</li>\n<li>CPU在下一个时间片开始之前会先检测这个位置，CPU发现标记后便可判断为哪种中断，得出中断号，根据中断表查出这类中断对应的处理程序地址。</li>\n<li>带着参数执行这个地址处的程序。</li>\n<li>操作系统在跳转前还需要保存被打断程序的现场状态，以便后续恢复后能继续运行，在执行完后同样要继续恢复。</li>\n</ol>\n<p><strong>特点</strong>：对于正在执行的应用程序来说是透明的，应用程序无感知</p>\n<h4>异常处理过程</h4>\n<ol>\n<li>CPU正在执行应用程序代码时，发现了非法指令，CPU无法继续执行了，产生一个异常ID（硬件实现：改变某个寄存器的值），转而执行操作系统的代码。</li>\n<li>操作系统通过异常ID确定异常号，保存好当前上下文，再确定异常处理程序的地址。</li>\n<li>异常处理判断直接杀死当前程序，还是为其分配必要的资源后重新执行一次（这种情况下对应用程序是透明的，好像不曾产生异常）。</li>\n</ol>\n<h4>系统调用过程</h4>\n<p>应用程序无法直接完成某项任务，需要操作系统作为中介提供服务。</p>\n<blockquote>\n<p>windows系统提供了Win32 API，应用程序可以为这些接口提供参数来申请系统调用。\nPOSIX-based systems系统（Linux，MacOS等系统）提供了POSIX API，可以实现应用程序的系统调用。\n人们都知道JAVA虚拟机会提供JAVA API，通过JAVA API实现的是库函数的调用，再通过JAVA虚拟机来代为实现系统调用，其实是多了一层封装的，但也就是因为多了一层JAVA虚拟机，所以JAVA程序有非常好的跨平台性，JAVA虚拟机实现了对不同操作系统差异的屏蔽。不过这并没有什么了不起的，现在大部分编程语言都是跨平台的，社区或者公司都提供了不同平台的解释或者编译程序，也可以一次编写到处运行。\n应用程序编写时，只要掌握对应OS提供的API与API具有的功能即可。</p>\n</blockquote>\n<p>应用程序直接或者间接（通过库函数）访问OS系统提供的API，会触发了CPU从用户态到内核态的切换。\n用户态就是CPU执行应用程序的状态，仅能执行有限指令，不能直接操纵外设，无法完全控制整个计算机。\n内核态指CPU执行OS程序的状态，可以执行特权和访问I/O的指令，可以完全控制整个计算机。\n完成转换后就将控制权交到了操作系统，操作系统可以对系统调用做标识，识别，完成服务。</p>\n<h4>函数调用与系统调用的区别</h4>\n<p>函数调用其实是在一个栈空间完成了参数的传递和返回。而系统调用时，应用程序和内核程序有各自的堆栈，发出系统调用，要切换执行内核程序，就要先切换堆栈，同时转换特权集（用户态到内核态），切换堆栈和转换是有开销的，还包括系统调用的参数检查，两个堆栈之间的拷贝（堆栈的切换不能仅仅通过修改指针）。总体而言开销大很多，但换来的回报是安全。</p>',fields:{slug:"/os-1/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/os-2.md absPath of file >>> MarkdownRemark",excerpt:"操作系统（二） 操作系统如何管理物理主存？ 计算机体系结构、主存结构分层 CPU芯片内部有寄存器和Cache…",frontmatter:{title:"操作系统（二）",date:"2018-01-12",tags:["os","memory"]},html:"<h1>操作系统（二）</h1>\n<ol>\n<li>操作系统如何管理物理主存？</li>\n</ol>\n<h2>计算机体系结构、主存结构分层</h2>\n<ol>\n<li>CPU芯片内部有寄存器和Cache，操作系统无法直接访问管理，这一层次的主存容量小但是数据很快。</li>\n<li>在主存结构中有一块很大的区域，即主存或者物理主存。这块区域可以用来放置操作系统本身代码以及其他要运行的程序，主存容量大，速度慢。</li>\n<li>计算机中可以在主存中存放着多个可运行的程序，若CPU的运行速度很快，且这些可运行的程序都需要很大的主存，那么CPU运行完主存中可运行的程序（假想当前主存中的可运行的所有程序都需要接收到网络响应后才能恢复运行），那么CPU就闲置下来了。为了避免CPU浪费，操作系统就需要发挥作用，将临时用不到的程序和数据放到硬盘中。</li>\n<li>主存在计算机掉电之后其内的数据就丢失了，在主存结构的底层，就是硬盘，它用来保存数据。</li>\n</ol>\n<p><strong>特点</strong>：上述主存结构分层，从上到下速度依次降低，存储容量依次增大。数据访问很快，数据的存储空间很大。有了操作系统的帮助，操作系统如何管理物理主存，如何完成这个任务？</p>\n<h2>操作系统为配合应用程序需要完成的任务</h2>\n<p>为了配合程序，操作系统需要完成以下任务：</p>\n<ul>\n<li>抽象：我们希望应用程序在主存中运行时，不需要考虑物理主存和外设在什么地方，只需要访问一个连续的地址空间（逻辑地址空间）即可。</li>\n<li>保护：在主存中可以运行多个不同的应用程序，某个程序可能会访问别的程序的地址空间，这时就需要一种机制来隔离和保护被访问程序的地址空间。</li>\n<li>共享：除了隔离外，程序之间如何交互、共享各自的数据。</li>\n<li>虚拟化：当需要在主存中运行的应用程序很多时，会出现主存不够用的情况。我们将暂时不用的数据临时放入硬盘，用的时候再拿出来，整个过程要对应用程序透明，这也是操作系统的任务。</li>\n</ul>\n<p><strong>注</strong>：上面提到了两个地址空间，主存和硬盘是物理地址空间，而应用程序在操作系统的作用下看到的是逻辑地址空间。</p>\n<h2>地址空间与地址生成</h2>\n<h3>地址空间定义</h3>\n<p>地址空间分为物理地址空间和逻辑地址空间。</p>\n<ul>\n<li>物理地址空间：与硬件直接对应，主存条代表的主存和硬盘代表的另一种存储空间，物理地址空间的管理由硬件来完成。</li>\n<li>逻辑地址空间：是运行程序所见到的一维线性的地址空间，应用程序非常容易控制和访问逻辑地址空间。</li>\n<li>两者对应关系：某条程序指令指向某个一维逻辑地址，这个逻辑地址可能是该程序堆栈的某个位置，但最终这个位置可能是主存中甚至是硬盘中，操作系统完成了两者的映射关系。</li>\n</ul>\n<h3>逻辑地址生成</h3>\n<ol>\n<li>C程序通过编译变为汇编程序，在C程序中，函数的位置和变量的名字就是地址，只不过以一种更容易人理解的方式存在。</li>\n<li>汇编程序更贴近机器语言，但是函数和变量仍然通过符号表示，相比机器语言，汇编语言更易让人阅读。</li>\n<li>将汇编程序汇编成机器语言，即.o程序，.o程序的起始地址从0开始，此时变量和函数已经被转成了特定的地址。</li>\n<li>一个大程序会由多个小程序组成，小程序之间往往具有复杂的依赖关系，通过链接可以将多个.o小程序最终变成一个单一的可执行程序.exe，.exe程序已经可以在主存中执行的，但是目前还放在硬盘中。</li>\n<li>多个点.o程序中地址已经在.exe程序中有了相应的映射，但这个定义并非主存中的位置，再通过载入程序，将.exe程序放入到主存中执行，这一步为.exe程序分配在主存中的逻辑地址，使得应用程序在主存中正常的跑，.exe程序的地址做了相应的偏远，通过这个偏移量，程序就会依照这个偏移量进行执行。</li>\n</ol>\n<p><strong>特点</strong>：从函数和变量到最终可以在主存中执行的逻辑地址，通过了很多步骤，但这些步骤基本都不需要操作系统做任何的帮助，最终放入内存后，应用程序看到的地址仍然不是物理地址。</p>\n<p><strong>题目</strong>\n在内存管理中，地址变换机构将逻辑地址变为物理地址，形成该逻辑地址的阶段是编辑、编译、链接还是装载？\n答：链接。在编译、汇编后，一个程序可能形成了多个.o文件，这是已经具有了逻辑地址，但只是相对于该模块的逻辑地址，并不能直接用于后续的地址变换。多个.h文件再经过链接，组合为.exe文件，便形成了相对于整个程序的逻辑地址。这个地址可用于后续的地址变换。</p>\n<h3><del>逻辑地址如何对应物理地址（需要组成原理的内容做铺垫）</del></h3>\n<p>指令放在物理内存的什么地方，指令的逻辑地址在什么地方，CPU有MMU，它有一块区域存着映射关系，查表可以完成具体的物理地址，硬件就可以从相应的物理地址中取出。</p>\n<p>操作系统先生成一个逻辑地址和物理地址的映射关系，将该映射关系存在内存中，CPU可以在MMU中缓存这个映射关系。（<strong>如何完成预先生成，后续谈</strong>）</p>\n<ol>\n<li>CPU执行某条指令，ALU需要得到该指令逻辑地址上的内容，ALU首先将该逻辑地址作为参数，向存储管理单元MMU发出查物理地址的请求。</li>\n<li>CPU的MMU查找对应的映射表，判断是否有对应的物理地址。</li>\n<li>若没有这个物理地址，就到内存中的映射表上找</li>\n<li>找到后CPU的控制器向主存发出请求，需要某个物理地址的内容，主存将内存的内容通过总线传给CPU，CPU拿到内容就可以进行执行了</li>\n</ol>\n<h2>如何确保内存中的程序不相互干扰</h2>\n<p>操作系统首先确认每个程序可以访问的地址空间，第一部分是起始地址，第二个部分是该程序可访问的区域。这张表由操作系统建立和维护，CPU在执行某条指令时，CPU要查表确定是否合法，合法之后才根据地址取指令。</p>",fields:{slug:"/os-2/"}}],Bootloader:[{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/os-1.md absPath of file >>> MarkdownRemark",excerpt:"操作系统（一） 按下电源之后，如何加载操作系统？ 操作系统如何与外设、应用程序交互？ BIOS、BootLoader、OS的关系 BIOS即基本输入输出系统，存在CMOS中，OS即操作系统，操作系统存在硬盘中。硬盘中还存另一个简单的小程序BootLoader，它可以将OS…",frontmatter:{title:"操作系统（一）",date:"2018-01-10",tags:["os","Bootloader"]},html:'<h1>操作系统（一）</h1>\n<ol>\n<li>按下电源之后，如何加载操作系统？</li>\n<li>操作系统如何与外设、应用程序交互？</li>\n</ol>\n<h2>BIOS、BootLoader、OS的关系</h2>\n<p>BIOS即基本输入输出系统，存在CMOS中，OS即操作系统，操作系统存在硬盘中。硬盘中还存另一个简单的小程序BootLoader，它可以将OS从硬盘放到内存中去，使cpu可以执行OS相关的代码。</p>\n<ol>\n<li>一开始加电，CPU从一个预先约定的地址处开始执行BIOS程序，进行加电自检（显卡，键鼠，硬盘），检查成功，即外设均可正常工作，接着要将BootLoader程序放到内存中去。</li>\n<li>BootLoader放在硬盘内的某个指定位置，BIOS从这位置开始，连续读取其后的512B的代码和数据，放入内存之中，CPU按照BootLoader的代码开始执行。</li>\n<li>此时CPU的控制权由BootLoader掌控，该程序会找到硬盘中OS程序的起始扇区和长度，将这块区域从硬盘中读到内存中去，CPU调到OS的起始代码处开始。</li>\n</ol>\n<h2>操作系统如何与设备和程序交互</h2>\n<table>\n<thead>\n<tr>\n<th>对象</th>\n<th>交互方式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>面向外设</td>\n<td>中断、I/O</td>\n</tr>\n<tr>\n<td>面向程序</td>\n<td>系统调用、异常</td>\n</tr>\n</tbody>\n</table>\n<h3>基本概念</h3>\n<ul>\n<li>系统调用：系统的资源由操作系统统一掌控，应用程序需要这些资源时，要向系统主动提出服务请求，之后由操作系统来完成相应的功能。</li>\n<li>异常：同样由应用程序产生的，但是并非主动产生，而是在执行过程中，出现了意想不到的事情，必须由操作系统解救。</li>\n<li>中断：来源于外设，当外设执行完上一轮CPU分配的任务后，请求下一轮的任务，通过中断机制，使操作系统能感知外设发出的请求。</li>\n</ul>\n<h3>为什么应用程序不能直接找外设？</h3>\n<ul>\n<li>安全：操作系统是特殊的软件，是可信程序，而应用程序则不是。</li>\n<li>抽象：操作系统为应用提供简单一致的接口，不需要针对不同的外设开发不同的软件，屏蔽底层设备的差异性，提供统一的接口。</li>\n</ul>\n<h3>区别联系</h3>\n<table>\n<thead>\n<tr>\n<th align="left">源头</th>\n<th></th>\n<th align="left">处理时间</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align="left">中  断</td>\n<td>非CPU执行指令时产生的，由设备产生，例如设备上一轮的I/O处理完成了，希望再为分配下一轮的任务</td>\n<td align="left">异步,即不知道外设什么时候发出中断，什么时候返回给外设下一轮任务也未知</td>\n</tr>\n<tr>\n<td align="left">异  常</td>\n<td>CPU执行应用程序的指令时产生，被动产生的，举例：越界访问，非法操作码等</td>\n<td align="left">同步，即执行到特定的指令一定会发生，且要立即处理</td>\n</tr>\n<tr>\n<td align="left">系统调用</td>\n<td>CPU执行应用程序的指令时产生，主动产生的，举例：对文件的增删改查</td>\n<td align="left">同步和异步，即执行到特定的指令，应用程序发出调用，比如网络请求这是同步的，但之后可以继续执行其余指令，不必一直等待</td>\n</tr>\n</tbody>\n</table>\n<h3>处理过程</h3>\n<h4>中断处理过程</h4>\n<ol>\n<li>外设完成任务，在某个寄存器或者某个特定的位置设置一个中断标记。</li>\n<li>CPU在下一个时间片开始之前会先检测这个位置，CPU发现标记后便可判断为哪种中断，得出中断号，根据中断表查出这类中断对应的处理程序地址。</li>\n<li>带着参数执行这个地址处的程序。</li>\n<li>操作系统在跳转前还需要保存被打断程序的现场状态，以便后续恢复后能继续运行，在执行完后同样要继续恢复。</li>\n</ol>\n<p><strong>特点</strong>：对于正在执行的应用程序来说是透明的，应用程序无感知</p>\n<h4>异常处理过程</h4>\n<ol>\n<li>CPU正在执行应用程序代码时，发现了非法指令，CPU无法继续执行了，产生一个异常ID（硬件实现：改变某个寄存器的值），转而执行操作系统的代码。</li>\n<li>操作系统通过异常ID确定异常号，保存好当前上下文，再确定异常处理程序的地址。</li>\n<li>异常处理判断直接杀死当前程序，还是为其分配必要的资源后重新执行一次（这种情况下对应用程序是透明的，好像不曾产生异常）。</li>\n</ol>\n<h4>系统调用过程</h4>\n<p>应用程序无法直接完成某项任务，需要操作系统作为中介提供服务。</p>\n<blockquote>\n<p>windows系统提供了Win32 API，应用程序可以为这些接口提供参数来申请系统调用。\nPOSIX-based systems系统（Linux，MacOS等系统）提供了POSIX API，可以实现应用程序的系统调用。\n人们都知道JAVA虚拟机会提供JAVA API，通过JAVA API实现的是库函数的调用，再通过JAVA虚拟机来代为实现系统调用，其实是多了一层封装的，但也就是因为多了一层JAVA虚拟机，所以JAVA程序有非常好的跨平台性，JAVA虚拟机实现了对不同操作系统差异的屏蔽。不过这并没有什么了不起的，现在大部分编程语言都是跨平台的，社区或者公司都提供了不同平台的解释或者编译程序，也可以一次编写到处运行。\n应用程序编写时，只要掌握对应OS提供的API与API具有的功能即可。</p>\n</blockquote>\n<p>应用程序直接或者间接（通过库函数）访问OS系统提供的API，会触发了CPU从用户态到内核态的切换。\n用户态就是CPU执行应用程序的状态，仅能执行有限指令，不能直接操纵外设，无法完全控制整个计算机。\n内核态指CPU执行OS程序的状态，可以执行特权和访问I/O的指令，可以完全控制整个计算机。\n完成转换后就将控制权交到了操作系统，操作系统可以对系统调用做标识，识别，完成服务。</p>\n<h4>函数调用与系统调用的区别</h4>\n<p>函数调用其实是在一个栈空间完成了参数的传递和返回。而系统调用时，应用程序和内核程序有各自的堆栈，发出系统调用，要切换执行内核程序，就要先切换堆栈，同时转换特权集（用户态到内核态），切换堆栈和转换是有开销的，还包括系统调用的参数检查，两个堆栈之间的拷贝（堆栈的切换不能仅仅通过修改指针）。总体而言开销大很多，但换来的回报是安全。</p>',fields:{slug:"/os-1/"}}],opensauce:[{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/opensauce.md absPath of file >>> MarkdownRemark",excerpt:"opensauce单元测试 为开源项目提供免费的云测试\n https://saucelabs.com/opensauce/ 推荐文章 https://philipwalton.com/articles/learning-how-to-set-up-automated-cross…",frontmatter:{title:"opensauce单元测试",date:"2016-05-03",tags:["opensauce","unit testing"]},html:'<h1>opensauce单元测试</h1>\n<p>为开源项目提供免费的云测试\n<a href="https://saucelabs.com/opensauce/">https://saucelabs.com/opensauce/</a></p>\n<p>推荐文章<a href="https://philipwalton.com/articles/learning-how-to-set-up-automated-cross-browser-javascript-unit-testing/">https://philipwalton.com/articles/learning-how-to-set-up-automated-cross-browser-javascript-unit-testing/</a></p>\n<p>中文版\n<a href="http://www.jianshu.com/p/d079b9c61450">http://www.jianshu.com/p/d079b9c61450</a></p>',fields:{slug:"/opensauce/"}}],"unit testing":[{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/opensauce.md absPath of file >>> MarkdownRemark",excerpt:"opensauce单元测试 为开源项目提供免费的云测试\n https://saucelabs.com/opensauce/ 推荐文章 https://philipwalton.com/articles/learning-how-to-set-up-automated-cross…",frontmatter:{title:"opensauce单元测试",date:"2016-05-03",tags:["opensauce","unit testing"]},html:'<h1>opensauce单元测试</h1>\n<p>为开源项目提供免费的云测试\n<a href="https://saucelabs.com/opensauce/">https://saucelabs.com/opensauce/</a></p>\n<p>推荐文章<a href="https://philipwalton.com/articles/learning-how-to-set-up-automated-cross-browser-javascript-unit-testing/">https://philipwalton.com/articles/learning-how-to-set-up-automated-cross-browser-javascript-unit-testing/</a></p>\n<p>中文版\n<a href="http://www.jianshu.com/p/d079b9c61450">http://www.jianshu.com/p/d079b9c61450</a></p>',fields:{slug:"/opensauce/"}}],CSS:[{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/pixel-layout.md absPath of file >>> MarkdownRemark",excerpt:"布局像素的辨析 下文主要介绍了一些关于分辨率的基础概念。 物理分辨率 所谓物理分辨率，是指一块屏幕上，横向有多少个像素点，纵向有多少个像素点，比如苹果5的分辨率是640x1136，代表它横向有640个像素点，纵向拥有113…",frontmatter:{title:"布局像素的辨析",date:"2016-08-12",tags:["CSS"]},html:"<h1>布局像素的辨析</h1>\n<p>下文主要介绍了一些关于分辨率的基础概念。</p>\n<h2>物理分辨率</h2>\n<p>所谓物理分辨率，是指一块屏幕上，横向有多少个像素点，纵向有多少个像素点，比如苹果5的分辨率是640x1136，代表它横向有640个像素点，纵向拥有1136个像素点。看官也听出来了，这个物理分辨率是屏幕自带的固定参数，无法更改。</p>\n<h2>屏幕尺寸</h2>\n<p>屏幕尺寸指屏幕对角线的长度，根据横向长度和纵向长度进一步计算得到，使用英寸为单位，比如苹果5的尺寸为4.0英寸。</p>\n<h2>像素密度</h2>\n<p>像素密度是一个重要的概念，指每英寸上有多少像素点，通过这个参数可以很明确的表示屏幕清晰程度。计算公式为屏幕上所有的物理像素点，除以屏幕尺寸(对角线长度，英寸)。</p>\n<p>常见的一个临界值是300ppi，这个数字来自于苹果4发布会，乔布斯宣称达到这个分辨率的手机，如果正常距离使用，人眼已经无法分辨屏幕上细微的方格了，苹果一向是善于包装旧概念的，retina display 一词就是被乔布斯创造出来，翻译过来就是这几年经常听到的视网膜显示屏。</p>\n<h2>逻辑像素</h2>\n<p>逻辑像素对于开发人员极其重要，是开发过程中表示界面尺寸的一种尺寸，这个需要和物理像素，即物理分辨率做区分。经常听到的一句话就是——物理像素是设备硬件支持的，逻辑像素是软件可以达到的。</p>\n<p>这句话很好理解，举个简单的例子，之前的苹果3gs，分辨率是480x320，3.5英寸，风靡世界的苹果4，分辨率为它的2倍，960x640。注意，这里表达的分辨率就是指物理像素。</p>\n<p>在苹果4上，纵向有960个像素点组成，横向则为640个像素点。\n此时如果在这两部手机上开发，继续使用px布局，即使用物理像素进行开发，就会遇到一些问题，在苹果3gs上开发的布局，在苹果4上无法充满屏幕。</p>\n<p>苹果此时引入一个概念，pt，即点(point)，在这之前，1pt是等于一个像素的，逻辑像素与物理像素是相同的。</p>\n<p>在苹果4上出现了不同，1pt = 2px，也就是说，一个英寸上的物理像素数目，是逻辑像素的二倍。举个例子，在开发过程中，我们使用14pt的高度，在3gs上面，显示就是14px，也即上面说的物理像素和逻辑像素是相同的，但是在苹果4上面，显示为28px，他们所占的物理尺寸是相同的(我们肉眼看到的尺寸)，我们可以可以看到14pt的逻辑尺寸，既充满了3gs，也充满了苹果4，但事实上每单位物理尺寸上的物理像素已经不同了。\n物理分辨率可以不同，但是他们通过逻辑像素这个概念(pt)，在显示结果上得到了统一。</p>\n<h2>DPI</h2>\n<p>如果明确了上面的这些概念，那么对于dpi的概念就手到擒来了，所谓dpi，是指每英寸上点的数目，这里的点自然是指pt了，于是很容易理解这样的现象：</p>\n<p>在3gs上，使用20x20个像素来表示20x20个点，但是到了4上，使用40x40个像素来表示这20x20个点，他们所用到的物理像素数量不同，但是表示点的数目是相同的，而dpi是指每英寸上具有点的数目，于是我们可以得到3gs和4的dpi是相同的，均为162dpi。</p>\n<p>以上</p>",fields:{slug:"/pixel-layout/"}}],memory:[{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/os-2.md absPath of file >>> MarkdownRemark",excerpt:"操作系统（二） 操作系统如何管理物理主存？ 计算机体系结构、主存结构分层 CPU芯片内部有寄存器和Cache…",frontmatter:{title:"操作系统（二）",date:"2018-01-12",tags:["os","memory"]},html:"<h1>操作系统（二）</h1>\n<ol>\n<li>操作系统如何管理物理主存？</li>\n</ol>\n<h2>计算机体系结构、主存结构分层</h2>\n<ol>\n<li>CPU芯片内部有寄存器和Cache，操作系统无法直接访问管理，这一层次的主存容量小但是数据很快。</li>\n<li>在主存结构中有一块很大的区域，即主存或者物理主存。这块区域可以用来放置操作系统本身代码以及其他要运行的程序，主存容量大，速度慢。</li>\n<li>计算机中可以在主存中存放着多个可运行的程序，若CPU的运行速度很快，且这些可运行的程序都需要很大的主存，那么CPU运行完主存中可运行的程序（假想当前主存中的可运行的所有程序都需要接收到网络响应后才能恢复运行），那么CPU就闲置下来了。为了避免CPU浪费，操作系统就需要发挥作用，将临时用不到的程序和数据放到硬盘中。</li>\n<li>主存在计算机掉电之后其内的数据就丢失了，在主存结构的底层，就是硬盘，它用来保存数据。</li>\n</ol>\n<p><strong>特点</strong>：上述主存结构分层，从上到下速度依次降低，存储容量依次增大。数据访问很快，数据的存储空间很大。有了操作系统的帮助，操作系统如何管理物理主存，如何完成这个任务？</p>\n<h2>操作系统为配合应用程序需要完成的任务</h2>\n<p>为了配合程序，操作系统需要完成以下任务：</p>\n<ul>\n<li>抽象：我们希望应用程序在主存中运行时，不需要考虑物理主存和外设在什么地方，只需要访问一个连续的地址空间（逻辑地址空间）即可。</li>\n<li>保护：在主存中可以运行多个不同的应用程序，某个程序可能会访问别的程序的地址空间，这时就需要一种机制来隔离和保护被访问程序的地址空间。</li>\n<li>共享：除了隔离外，程序之间如何交互、共享各自的数据。</li>\n<li>虚拟化：当需要在主存中运行的应用程序很多时，会出现主存不够用的情况。我们将暂时不用的数据临时放入硬盘，用的时候再拿出来，整个过程要对应用程序透明，这也是操作系统的任务。</li>\n</ul>\n<p><strong>注</strong>：上面提到了两个地址空间，主存和硬盘是物理地址空间，而应用程序在操作系统的作用下看到的是逻辑地址空间。</p>\n<h2>地址空间与地址生成</h2>\n<h3>地址空间定义</h3>\n<p>地址空间分为物理地址空间和逻辑地址空间。</p>\n<ul>\n<li>物理地址空间：与硬件直接对应，主存条代表的主存和硬盘代表的另一种存储空间，物理地址空间的管理由硬件来完成。</li>\n<li>逻辑地址空间：是运行程序所见到的一维线性的地址空间，应用程序非常容易控制和访问逻辑地址空间。</li>\n<li>两者对应关系：某条程序指令指向某个一维逻辑地址，这个逻辑地址可能是该程序堆栈的某个位置，但最终这个位置可能是主存中甚至是硬盘中，操作系统完成了两者的映射关系。</li>\n</ul>\n<h3>逻辑地址生成</h3>\n<ol>\n<li>C程序通过编译变为汇编程序，在C程序中，函数的位置和变量的名字就是地址，只不过以一种更容易人理解的方式存在。</li>\n<li>汇编程序更贴近机器语言，但是函数和变量仍然通过符号表示，相比机器语言，汇编语言更易让人阅读。</li>\n<li>将汇编程序汇编成机器语言，即.o程序，.o程序的起始地址从0开始，此时变量和函数已经被转成了特定的地址。</li>\n<li>一个大程序会由多个小程序组成，小程序之间往往具有复杂的依赖关系，通过链接可以将多个.o小程序最终变成一个单一的可执行程序.exe，.exe程序已经可以在主存中执行的，但是目前还放在硬盘中。</li>\n<li>多个点.o程序中地址已经在.exe程序中有了相应的映射，但这个定义并非主存中的位置，再通过载入程序，将.exe程序放入到主存中执行，这一步为.exe程序分配在主存中的逻辑地址，使得应用程序在主存中正常的跑，.exe程序的地址做了相应的偏远，通过这个偏移量，程序就会依照这个偏移量进行执行。</li>\n</ol>\n<p><strong>特点</strong>：从函数和变量到最终可以在主存中执行的逻辑地址，通过了很多步骤，但这些步骤基本都不需要操作系统做任何的帮助，最终放入内存后，应用程序看到的地址仍然不是物理地址。</p>\n<p><strong>题目</strong>\n在内存管理中，地址变换机构将逻辑地址变为物理地址，形成该逻辑地址的阶段是编辑、编译、链接还是装载？\n答：链接。在编译、汇编后，一个程序可能形成了多个.o文件，这是已经具有了逻辑地址，但只是相对于该模块的逻辑地址，并不能直接用于后续的地址变换。多个.h文件再经过链接，组合为.exe文件，便形成了相对于整个程序的逻辑地址。这个地址可用于后续的地址变换。</p>\n<h3><del>逻辑地址如何对应物理地址（需要组成原理的内容做铺垫）</del></h3>\n<p>指令放在物理内存的什么地方，指令的逻辑地址在什么地方，CPU有MMU，它有一块区域存着映射关系，查表可以完成具体的物理地址，硬件就可以从相应的物理地址中取出。</p>\n<p>操作系统先生成一个逻辑地址和物理地址的映射关系，将该映射关系存在内存中，CPU可以在MMU中缓存这个映射关系。（<strong>如何完成预先生成，后续谈</strong>）</p>\n<ol>\n<li>CPU执行某条指令，ALU需要得到该指令逻辑地址上的内容，ALU首先将该逻辑地址作为参数，向存储管理单元MMU发出查物理地址的请求。</li>\n<li>CPU的MMU查找对应的映射表，判断是否有对应的物理地址。</li>\n<li>若没有这个物理地址，就到内存中的映射表上找</li>\n<li>找到后CPU的控制器向主存发出请求，需要某个物理地址的内容，主存将内存的内容通过总线传给CPU，CPU拿到内容就可以进行执行了</li>\n</ol>\n<h2>如何确保内存中的程序不相互干扰</h2>\n<p>操作系统首先确认每个程序可以访问的地址空间，第一部分是起始地址，第二个部分是该程序可访问的区域。这张表由操作系统建立和维护，CPU在执行某条指令时，CPU要查表确定是否合法，合法之后才根据地址取指令。</p>",fields:{slug:"/os-2/"}}],"regular expression":[{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/regular-expression-1.md absPath of file >>> MarkdownRemark",excerpt:"正则表达式核心 若有多个字符串，其中一个字符串中包含部分内容，我们使用正则来进行匹配，匹配的结果到底什么？是包含匹配内容的那个字符串？还是只有匹配的内容？ Go Ahead…",frontmatter:{title:"正则表达式核心",date:"2016-04-05",tags:["regular expression"]},html:'<h1>正则表达式核心</h1>\n<p>若有多个字符串，其中一个字符串中包含部分内容，我们使用正则来进行匹配，匹配的结果到底什么？是包含匹配内容的那个字符串？还是只有匹配的内容？</p>\n<p>Go Ahead~</p>\n<p>正则表达式的核心概念就是元字符，它一点也不复杂，掌握了元字符，就可以正则表达式的能力有所了解。</p>\n<p>接下来的每一节，我都会介绍数个元字符，最终本文结束时，读者就会对正则表达式的核心元字符有大概的了解。</p>\n<h2>从 hi, Hao 开始</h2>\n<p><code>hi, Hao</code>这样一个字符串，如果使用正则表达式匹配到<code>hi</code>？这非常简单，我们使用<code>js</code>来作为实现语言：</p>\n<pre><code class="language-js">let p = /hi/;\nlet s = `hi, HAO`;\ns.match(p); // ["hi", index: 0, input: "hi,Hao"]\n</code></pre>\n<p>逐行分析：</p>\n<ol>\n<li>使用<code>/code/</code>这样的语法，告诉<code>js</code>解释引擎，这是一个正则表达式，其中的<code>hi</code>就是正则表达式的实际内容</li>\n<li>声明赋值一个字符串</li>\n<li>使用<code>match</code>方法匹配，它将返回一个数组，其中存放了与它找到的匹配文本有关的信息。该数组的第<code>0</code>个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本。除了这些常规的数组元素之外，返回的数组还含有两个对象属性。<code>index</code>属性声明的是匹配文本的起始字符在原字符串中的位置，<code>input</code>属性声明的是对原字符串的引用。</li>\n</ol>\n<p>上面太简单了，但如果遇到这样的情况呢？</p>\n<pre><code class="language-js">let s = `hi,this is Hao. hi, this is Liu.`;\n</code></pre>\n<p>这里面的<code>hi</code>，我全都要，该如何匹配？之前的正则表达式是否可行呢？</p>\n<pre><code class="language-js">s.match(/hi/) // ["hi", index: 0, input: "hi,this is Hao. hi, this is Liu."]\n</code></pre>\n<p>很明显，没有用了，仍然只捕捉到一个结果。为了解决这个问题，我们引入全局标志<code>g</code>，使用<code>g</code>，<code>match</code>方法将执行全局检索，找到原字符串中所有匹配子字符串。若没有找到任何匹配的子串，则返回<code>null</code>。如果找到了一个或多个匹配子串，则返回一个数组。不过全局匹配返回的数组的内容与前者大不相同，它的数组元素中存放的是原字符串中所有的匹配子串，而且也没有<code>index</code>属性和<code>input</code>属性。</p>\n<pre><code class="language-js">s.match(/hi/g) // (4) ["hi", "hi", "hi", "hi"]\n</code></pre>\n<p>成功了。</p>\n<p>挑剔的人来了，如果只想匹配到下面这个字符串最中间的<code>hi</code>呢？</p>\n<pre><code class="language-js">let s = `this is Hao. hi this is Liu.`;\n</code></pre>\n<p>我们这里就需要用正则表达式的核心内容，元字符了，直接看例子，</p>\n<pre><code class="language-js">s.match(/hi/) // ["hi", index: 1, input: "this is Hao. hi this is Liu."]\ns.match(/\\bhi\\b/) //["hi", index: 13, input: "this is Hao. hi this is Liu."]\n</code></pre>\n<p>逐行分析：</p>\n<ol>\n<li>第一行使用了老方法妄图匹配中间的<code>hi</code>，但在遇到索引位置<code>1</code>开始的<code>hi</code>时，就匹配完成了，老方法显然无法满足要求</li>\n<li>第二种方法从结果上看匹配成功了，匹配到了索引位置<code>13</code>处开始的<code>hi</code>，我们分析一下这个正则表达式中有什么。抛除熟悉的<code>\\ hi \\</code>，我们发现了<code>hi</code>左右的<code>\\b \\b</code>，这便是元字符，<code>\\</code>用来告诉计算机这是元字符，区别于普通的字符串。<code>b</code>元字符可以匹配这样的位置，这个位置的前一个字符和后一个字符不全是字母、数字、下划线、汉字。分析一下会发现第一个<code>hi</code>在<code>this</code>中，很明显，子串<code>hi</code>的前后字符都是字母，不满足要求。到了索引为<code>13</code>出的<code>hi</code>，它的前后是空格，不是字母、数字、下划线或者汉字，<code>b</code>元字符要求<code>hi</code>的前一个字符和后一个字符不全是字母、数字、下划线、汉字。这里都是空格，这可高于要求的<code>不全是</code>，都已经<code>全都不是</code>了，当然满足了，匹配成功。</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>元字符</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>b</td>\n<td>所匹配的位置，前一个字符和后一个字符不全是\n<code>w</code>\n(\n<code>w</code>\n用来匹配字母、数字、下划线、汉字)</td>\n</tr>\n</tbody>\n</table>\n<h2>.*元字符</h2>\n<p>匹配<code>hi</code>还是容易的，但如果想匹配一大段内容呢？比如</p>\n<pre><code class="language-js">let s = `hi! .................... I\'m Lucy! I may be a pink ostrich but I\'m still a kid just like you! I love  tell jokes, laugh, sing, watch cartoons and learn! And I get to do all these things in class with Sr. Grace! She\'s my favorite teacher in the whole world. `;\n</code></pre>\n<p>上面的省略号代表非常多的内容。假如我想要匹配<code>hi</code>与<code>Lucy</code>连同它中间的内容呢？我总不能都放到正则表达式吧，那多丑！\n我们这里又要使用元字符了</p>\n<pre><code class="language-js">s.match(/\\bhi\\b.*\\bLucy\\b/) //succ\n</code></pre>\n<p>这里面的有两三点要说明：</p>\n<ol>\n<li><code>.*</code>也算元字符？是的，这是两个元字符，只不过他们没有加<code>\\</code>而已。</li>\n<li>为什么不加<code>\\</code>标志符？因为他们太常用了，干脆就省略<code>\\</code>了，反而专门要匹配字符串<code>.</code>与<code>*</code>的场合却很少，干脆将正则表达式与字符串的表示反一下，如果想要匹配<code>.</code>这个字符串，那么为它加上<code>\\</code>，即<code>\\.</code>，<code>\\*</code>也是同理。</li>\n<li><code>.*</code>代表什么含义？请看下面的表格</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>元字符</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>.</td>\n<td>匹配除了换行符之外的任何字符</td>\n</tr>\n<tr>\n<td>*</td>\n<td>用来指定这个元字符 * 前面的内容可以连续重复使用任意多次，可以使得整个表达式得到匹配</td>\n</tr>\n</tbody>\n</table>\n<p>看到这个表格你应该明了了，<code>.*</code>用来表示任何数量的字符，只要字符里边不包括换行，于是 \\bhi\\b.*\\bLucy\\b 就表示先有个单词<code>hi</code>，接着允许出现很多字符，除了换行，之后有一个单词<code>Lucy</code>。</p>\n<h2>电话号码的匹配实例</h2>\n<p><code>0\\d\\d\\d-\\d\\d\\d\\d\\d\\d\\d\\d</code> 用来匹配<code>0</code>开头，之后3位数字加<code>-</code>，之后8位数字的电话号码。使用这么多的<code>\\d</code>是一件很让人上头的事情，可以使用这样的写法：<code>0\\d{3}-\\d{8}</code>。</p>\n<table>\n<thead>\n<tr>\n<th>元字符</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>d</td>\n<td>匹配一位数字,比如 0 ，1 ，2 等任意的一位数字</td>\n</tr>\n<tr>\n<td>{n}</td>\n<td>用来指定这个元字符\n<code>*</code>\n前面的内容可以连续重复使用任意多次，可以使得整个表达式得到匹配</td>\n</tr>\n</tbody>\n</table>\n<h2>其他常用元字符</h2>\n<table>\n<thead>\n<tr>\n<th>元字符</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>/s</td>\n<td>匹配任意多的空白符</td>\n</tr>\n<tr>\n<td>/w</td>\n<td>代表着可用文字，包含字母，数字，下划线，汉字</td>\n</tr>\n<tr>\n<td>/s</td>\n<td>匹配任意多的空白符</td>\n</tr>\n<tr>\n<td>+</td>\n<td>与\n<code>{n}</code>\n、\n<code>*</code>\n类似，指定当前元字符前面的内容重复多次，\n<code>+</code>\n专指重复\n<code>1</code>\n次以上</td>\n</tr>\n</tbody>\n</table>\n<h2>番外</h2>\n<p>现在好多内容在讲正则的时候都不注意区分哪些是核心内容，在很多环境下，编程语言会对正则做出拓展，引入了很多新符号，引入了很多的复杂度，对初学者不友好。下面推荐一些文章</p>\n<ul>\n<li>谷歌大牛的文章：<a href="http://blog.youxu.info/2009/03/05/ree1/">编程珠玑番外篇-C.正则表达式精义-1</a></li>\n<li>进阶：<a href="http://www.cppblog.com/vczh/archive/2014/01/19/205468.html">跟vczh看实例学编译原理——零：序言</a></li>\n<li>这是一个图形化的在线正则展示网页，可以用来测试正则：<a href="https://regexper.com/">Regexper</a></li>\n</ul>',fields:{slug:"/regular-expression-1/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/regular-expression-2.md absPath of file >>> MarkdownRemark",excerpt:"正则表达式进阶 接上一篇内容，上一篇主要介绍了正则表达式的核心内容，非常的简单易懂，现在对核心内容进行拓展。 界定符 表示正则表达式的开始和结束，具体的由解析器决定 /[0-9]/ #[0-…",frontmatter:{title:"正则表达式进阶",date:"2016-04-06",tags:["regular expression"]},html:"<h1>正则表达式进阶</h1>\n<p>接上一篇内容，上一篇主要介绍了正则表达式的核心内容，非常的简单易懂，现在对核心内容进行拓展。</p>\n<h2>界定符</h2>\n<p>表示正则表达式的开始和结束，具体的由解析器决定</p>\n<ul>\n<li><code>/[0-9]/</code></li>\n<li><code>#[0-9]#</code></li>\n</ul>\n<h2>元字符</h2>\n<p>元字符定义了原子的筛选方式，可以将某一类原子归类，并且给出缩写，简化正则：</p>\n<ul>\n<li><code>|</code>匹配两个或者多个分支</li>\n<li><code>[]</code>中括号内部的任意一个原子</li>\n<li><code>[^]</code>匹配除括号内部原子之外的任何字符</li>\n</ul>\n<h3>原子的筛选</h3>\n<p>使用<code>[]</code>可以进行原子的筛选，代表或者的关系，<code>[^]</code>代表非的关系</p>\n<ul>\n<li><code>[Dd]uang</code></li>\n<li><code>(D|d)uang</code></li>\n</ul>\n<p>这两种方法都可以匹配到想要的内容，但具体有什么区别呢？\n请注意在<code>[]</code>中出现的，只能是单个原子，每个原子之间都是或的关系，而使用<code>|</code>元字符，两边可以由多个原子组成来进行匹配。</p>\n<h3>原子集合</h3>\n<p>之所以定义了原子集合，主要是为了用来简化书写，一般原子集合，都可以通过原子筛选的方式给出，除了换行符的原子:</p>\n<ul>\n<li><code>\\d</code>数字<code>[0-9]</code></li>\n<li><code>\\D</code>非数字<code>[^0-9]</code></li>\n<li><code>\\s</code>不可见原子<code>[\\f\\n\\r\\t]</code></li>\n<li><code>\\S</code>可见的原子</li>\n<li><code>\\w</code>数字字母下划线<code>[0-9a-zA-Z_]</code></li>\n<li><code>\\W</code>任意一个非下划线，数字字母<code>[^0-9a-zA-Z_]</code></li>\n</ul>\n<h2>量词</h2>\n<p>所谓量词，就是表示它前面的原子重复多少次</p>\n<ul>\n<li><code>{d}</code>重复<code>d</code>次</li>\n<li><code>{d,}</code> 最少重复<code>d</code>次</li>\n<li><code>{d,b}</code> 重复<code>d</code>到<code>b</code>次</li>\n</ul>\n<h3>量词集合</h3>\n<p>参考原子集合，是为了简化筛选元素。量词集合的出现也是同样的道理</p>\n<ul>\n<li><code>{0,}</code> 最少重复<code>0</code>次，包含<code>0</code>次</li>\n<li><code>{1,}</code> 最少重复<code>1</code>次，包含<code>1</code>次</li>\n<li><code>{0,1}</code> 重复<code>0</code>次或者<code>1</code>次</li>\n</ul>\n<h3>修正模式</h3>\n<ul>\n<li><code>U</code>表示贪婪模式</li>\n<li><code>i</code>忽略大小写，用在正则中</li>\n<li><code>x</code>忽略正则中的空格，<code>tab</code>制表符</li>\n</ul>\n<h2>转义</h2>\n<p>转译，当正则占用了需要的输入</p>\n<ul>\n<li><code>\\</code></li>\n</ul>",fields:{slug:"/regular-expression-2/"}}],React:[{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/react-summary.md absPath of file >>> MarkdownRemark",excerpt:"React学习总结 参考官方文档，整理一些应该被重视的知识点 React中的事件相关 类似HTML中事件的使用方法，可以直接将事件处理函数作为属性值，赋给用驼峰式命名的事件属性。之后的事情交给React，React…",frontmatter:{title:"React学习总结",date:"2016-04-21",tags:["React","JS"]},html:'<h1>React学习总结</h1>\n<p>参考官方文档，整理一些应该被重视的知识点</p>\n<h2>React中的事件相关</h2>\n<p>类似HTML中事件的使用方法，可以直接将事件处理函数作为属性值，赋给用驼峰式命名的事件属性。之后的事情交给React，React自己有一个事件系统，它可以保证事件在所有浏览器中的一致性，React知道如何去冒泡和捕获事件，这个实现是根据w3c的规范，不管使用的是什么浏览器</p>\n<h2>State 相关</h2>\n<p>State是可以用来动态渲染，和props是一对好基友。</p>\n<h3>State 的异步工作方式</h3>\n<p><code>setState</code> 方法本身是异步的，有一种常见的方式是当React数据改变时，通过 setState(data,callback) 这个方法会将新数据合并到this.state对象上，之后重新渲染组件。当组件结束了重新渲染(re-render），可选的第二个参数callback会被执行。</p>\n<h3>组件在什么时候需要State</h3>\n<p>大多数的组件应该简单的通过props获取数据，之后渲染组件，然而有时候会需要一些复杂的数据处理，比如说响应用户的操作，一个请求，此时需要用到state。但尽可能多的让组件无状态话，减少冗余。一种常见的模式是创建许多无状态的组件，它们仅仅负责渲染数据，有一个拥有状态组件在它们层级之上，经过一系列的逻辑处理，通过props将state传递给它的子组件。有状态的组件囊括了尽可能多的逻辑，而无状态的组件仅仅负责渲染数据。</p>\n<h3>哪些数据应该作为State</h3>\n<p>尽量使用 props 作为唯一的数据源，事件处理函数会响应用户的事件，此时可能会更新影响用户界面的数据，这些数据应该被 State 包含。真实环境下，这个数据应该很小且可以被 JSON 序列化 。\n在创建包含状态的组件时，让它尽可能少的包含状态，并且将这些状态存入 this.state 对象中，后续的 render 方法再根据可能有的状态来计算出需要的其他数据，逻辑处理在 render ，通过状态来计算 render 的内容。</p>\n<h2>组件复用</h2>\n<p>React 因为新的 render 而导致 DOM 发生更新的过程称为组件校正，这个校正过程是根据组件的顺序决定，比如</p>\n<pre><code class="language-html">// Render Pass 1\n&#x3C;Card>\n    &#x3C;p>Paragraph 1&#x3C;/p>\n    &#x3C;p>Paragraph 2&#x3C;/p>\n&#x3C;/Card>\n// Render Pass 2\n&#x3C;Card>\n    &#x3C;p>Paragraph 2&#x3C;/p>\n&#x3C;/Card>\n</code></pre>\n<p>看起来像是 React 通过 diff 删除了第一个标签，但实际上 React 按照组件的顺序，修改了第一个标签的文本，删除了第二个组件。考虑一个组件由很多状态决定，内部的DOM需要来回的切换，由于组件校正的原理，可能会有些性能问题。此时可以选择为组件添加 <code>display: none</code> ，而不是直接选择删除。有些情况可能比较复杂，比如说有一个很长的列表，需要不断的重排序或者向首尾插入删除新子组件，这种情况如果按照顺序来校正，可能会出现性能问题，此时可以为这些子组件指定独一无二的key。当 React 校正这些组件的时候，就会直接重排序或者销毁，而不是按照顺序，修改子组件的内容来校正。</p>\n<h2>PropTypes</h2>\n<p>当项目越来越大，组件的复用越来越频繁，为了确保每次复用接收到的 props 是可用的，需要指定PropTypes。</p>\n<p>类似于 export，React.PropTypes 对象导出很多验证器，这些验证器可以保证传递来的 props 是正确的。\n当一个不可用的值被传递给当前组件的 props，那么在控制台中就会显示异常。\n具体的属性可以参考这个<a href="http://facebook.github.io/react/docs/reusable-components.html">页面</a>，可以为对象或者数组指定具体的内部 Child。</p>',fields:{slug:"/react-summary/"}}],Git:[{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-08-20---git-add/index.md absPath of file >>> MarkdownRemark",excerpt:"Git 学习小记之 add 所谓 add 操作，就是 add file into staged area 。下面针对两种情况进行讨论： 新建的文件 旧文件 新建的文件 我们了解 add…",frontmatter:{title:"Git 学习小记之 add",date:"2016-08-20",tags:["Git"]},html:"<h1>Git 学习小记之 add</h1>\n<p>所谓<code>add</code>操作，就是<code>add file into staged area</code>。下面针对两种情况进行讨论：</p>\n<ul>\n<li>新建的文件</li>\n<li>旧文件</li>\n</ul>\n<h2>新建的文件</h2>\n<p>我们了解<code>add</code>是一个重要的操作。假设有一个空目录，此时里面没有任何文件。\n我们新建一个文件，这个文件就是处于<code>untrack</code>状态的，可以理解为未被跟踪状态。</p>\n<p>此时修改这个文件，依然是处于<code>untrack</code>状态。在此时使用<code>add</code>操作，有两个作用：</p>\n<ol>\n<li>将新文件添加到暂存区(<code>staged</code>)</li>\n<li>将文件标记为 <code>track</code></li>\n</ol>\n<p>我们再使用<code>commit</code>操作，生成快照，同时<code>clean</code>暂存区，初始化一切。</p>\n<h2>旧文件</h2>\n<p>另外一种情况，假设已经有了旧文件，文件处于<code>track</code>状态。</p>\n<p>此时修改文件，如果使用<code>status</code>命令查看，会提示<code>Changes not staged for commit</code>，大意就是此时已经更新文件了，但是更新的内容还没有暂存起来，提示使用<code>add</code>操作进行暂存。</p>\n<p>按照提示使用<code>add</code>操作后，使用<code>status</code>命令查看，会发现处于已暂存状态。<code>Changes to be committed</code>，如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。</p>\n<h2>与 <code>commit</code> 搭配使用</h2>\n<p>如果发现不断的<code>add</code>、<code>commit</code>比较麻烦，可以使用<code>commit</code>命令加<code>-a</code>参数，Git会自动更新已经跟踪过的文件，更新暂存区。但这里有个地方需要留意，<code>-a</code> 参数并不会更新未跟踪的文件。</p>\n<h2>总结</h2>\n<p>关于<code>add</code>，最值得留意的就是一旦修改文件，必须重新暂存，否则生成快照(<code>commit</code>)的依然是上次<code>add</code>时的状态，快照只从暂存区来。</p>\n<p>总结起来，对于新文件，<code>add</code>会跟踪文件，同时将文件存入暂存区，如果是旧文件，可以按照本地文件更新暂存区的文件。除了上面提到的，还有一种常见的情况，当文件出现冲突时，经常需要人为解决冲突，在修改之后，可以使用<code>add</code>操作将有冲突的文件标记为已经解决状态。</p>",fields:{slug:"/2016-08-20---git-add/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/2016-09-01---git-branch/index.md absPath of file >>> MarkdownRemark",excerpt:"Git学习小记之分支原理 如果想要熟练使用 Git，没有分支理念是绝对行不通的，在用 Git 管理项目的时候，经常需要使用 commit 这个命令，那么这个 commit 到底是指什么呢？ 按照官方的解释，这应该成为一个对象，它包含着一个指向暂存内容(被add…",frontmatter:{title:"Git学习小记之分支原理",date:"2016-09-01",tags:["Git"]},html:'<h1>Git学习小记之分支原理</h1>\n<p>如果想要熟练使用 Git，没有分支理念是绝对行不通的，在用 Git 管理项目的时候，经常需要使用 commit 这个命令，那么这个 commit 到底是指什么呢？</p>\n<p>按照官方的解释，这应该成为一个对象，它包含着一个指向暂存内容(被add的文件)快照的指针，包含本次提交的附属信息，比如说作者等等，指向父 commit 对象(如果被 merge 而成，可能有多个父 commit 对象)的指针。</p>\n<p>举下面这个例子来分析：</p>\n<pre><code class="language-bash">git add README test.rb LICENSE\ngit commit -m \'initial commit of my project\'\n</code></pre>\n<ul>\n<li>add：暂存操作会对文件计算校验和(SHA-1哈希字串)，然后与当前版本的文件快照(用 blob 对象存储)一起存入到暂存区域中。</li>\n<li>commit：正式建立提交对象前：Git 先计算出每一个子目录的校验和，然后在 Git 仓库中，将这些目录保存为树对象。</li>\n</ul>\n<p>建立提交对象的过程主要如下：\n携带相关提交信息，包含一个指向该树的指针，这样就代表如果将来需要，可以重现此次快照内容。\n来看看现在仓库中有什么：\n一个表示文件快照内容的 blob 对象，一个记录着目录树内容，以及其中各个文件具体对应哪个 blob 对象的索引 tree 对象。以及一个包含着指向索引 tree 对象，以及其他提交信息元数据的 commit 对象。如图：</p>\n<p><img src="a.png"></p>',fields:{slug:"/2016-09-01---git-branch/"}}],css:[{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/2015-10-05---css-summary/index.md absPath of file >>> MarkdownRemark",excerpt:"CSS 总结 计划总结常用的CSS…",frontmatter:{title:"CSS 总结",date:"2015-10-5",tags:["css"]},html:"<h1>CSS 总结</h1>\n<p>计划总结常用的CSS知识</p>\n<h2>基本布局</h2>\n<p>下面汇总了传统的绝对，浮动，表格与凝胶等布局方式的优缺点</p>\n<h3>绝对布局</h3>\n<ul>\n<li>优点：主内容随页面宽度，固定边栏</li>\n<li>缺点：浏览器变宽的时候，页脚可能会遮住边栏，同时浏览器变宽后，主内容区和边栏的比例会不协调。</li>\n</ul>\n<h3>表格显示布局</h3>\n<ul>\n<li>优点：使用<code>table</code>标签，随窗口缩放</li>\n<li>缺点：对于语义化不利</li>\n</ul>\n<h3>凝胶布局</h3>\n<ul>\n<li>优点：主内容区建立后，设置左右margin为0</li>\n<li>缺点：对于页面的利用率不充足</li>\n</ul>\n<h2>盒子模型</h2>\n<p>边框折叠指两个垂直外边距相遇时，会碰到一起，即便是元素嵌套也不例外会进行折叠，下面有一些特殊情况：</p>\n<ol>\n<li>\n<p>上面的div有20px的边距，下面的有10px的边距，此时折叠，依然是20px的边距。但是如果此时把下面的元素设置为float，那么两者的边框不会折叠。</p>\n</li>\n<li>\n<p>考虑这种情况，一个元素嵌套一个元素，此时依然是折叠的，但如果此时为外边的元素设置了边框，那么内外元素边距不折叠</p>\n</li>\n<li>\n<p>box-sizing的用法</p>\n</li>\n</ol>\n<h2>选择器优先级</h2>\n<p>计算方法如下：计算模型分三个位置，其中，选择器若包含id，则计算模型第一位加一，第二个位置为class、伪类则加一。第三个位置为元素名，每个元素名加一，最后按照结果大小排序，对于依然冲突的规则，按照先后顺序，后出现的覆盖之前的。</p>",
fields:{slug:"/2015-10-05---css-summary/"}}]},post:[{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/os-1.md absPath of file >>> MarkdownRemark",excerpt:"操作系统（一） 按下电源之后，如何加载操作系统？ 操作系统如何与外设、应用程序交互？ BIOS、BootLoader、OS的关系 BIOS即基本输入输出系统，存在CMOS中，OS即操作系统，操作系统存在硬盘中。硬盘中还存另一个简单的小程序BootLoader，它可以将OS…",frontmatter:{title:"操作系统（一）",date:"2018-01-10",tags:["os","Bootloader"]},html:'<h1>操作系统（一）</h1>\n<ol>\n<li>按下电源之后，如何加载操作系统？</li>\n<li>操作系统如何与外设、应用程序交互？</li>\n</ol>\n<h2>BIOS、BootLoader、OS的关系</h2>\n<p>BIOS即基本输入输出系统，存在CMOS中，OS即操作系统，操作系统存在硬盘中。硬盘中还存另一个简单的小程序BootLoader，它可以将OS从硬盘放到内存中去，使cpu可以执行OS相关的代码。</p>\n<ol>\n<li>一开始加电，CPU从一个预先约定的地址处开始执行BIOS程序，进行加电自检（显卡，键鼠，硬盘），检查成功，即外设均可正常工作，接着要将BootLoader程序放到内存中去。</li>\n<li>BootLoader放在硬盘内的某个指定位置，BIOS从这位置开始，连续读取其后的512B的代码和数据，放入内存之中，CPU按照BootLoader的代码开始执行。</li>\n<li>此时CPU的控制权由BootLoader掌控，该程序会找到硬盘中OS程序的起始扇区和长度，将这块区域从硬盘中读到内存中去，CPU调到OS的起始代码处开始。</li>\n</ol>\n<h2>操作系统如何与设备和程序交互</h2>\n<table>\n<thead>\n<tr>\n<th>对象</th>\n<th>交互方式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>面向外设</td>\n<td>中断、I/O</td>\n</tr>\n<tr>\n<td>面向程序</td>\n<td>系统调用、异常</td>\n</tr>\n</tbody>\n</table>\n<h3>基本概念</h3>\n<ul>\n<li>系统调用：系统的资源由操作系统统一掌控，应用程序需要这些资源时，要向系统主动提出服务请求，之后由操作系统来完成相应的功能。</li>\n<li>异常：同样由应用程序产生的，但是并非主动产生，而是在执行过程中，出现了意想不到的事情，必须由操作系统解救。</li>\n<li>中断：来源于外设，当外设执行完上一轮CPU分配的任务后，请求下一轮的任务，通过中断机制，使操作系统能感知外设发出的请求。</li>\n</ul>\n<h3>为什么应用程序不能直接找外设？</h3>\n<ul>\n<li>安全：操作系统是特殊的软件，是可信程序，而应用程序则不是。</li>\n<li>抽象：操作系统为应用提供简单一致的接口，不需要针对不同的外设开发不同的软件，屏蔽底层设备的差异性，提供统一的接口。</li>\n</ul>\n<h3>区别联系</h3>\n<table>\n<thead>\n<tr>\n<th align="left">源头</th>\n<th></th>\n<th align="left">处理时间</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align="left">中  断</td>\n<td>非CPU执行指令时产生的，由设备产生，例如设备上一轮的I/O处理完成了，希望再为分配下一轮的任务</td>\n<td align="left">异步,即不知道外设什么时候发出中断，什么时候返回给外设下一轮任务也未知</td>\n</tr>\n<tr>\n<td align="left">异  常</td>\n<td>CPU执行应用程序的指令时产生，被动产生的，举例：越界访问，非法操作码等</td>\n<td align="left">同步，即执行到特定的指令一定会发生，且要立即处理</td>\n</tr>\n<tr>\n<td align="left">系统调用</td>\n<td>CPU执行应用程序的指令时产生，主动产生的，举例：对文件的增删改查</td>\n<td align="left">同步和异步，即执行到特定的指令，应用程序发出调用，比如网络请求这是同步的，但之后可以继续执行其余指令，不必一直等待</td>\n</tr>\n</tbody>\n</table>\n<h3>处理过程</h3>\n<h4>中断处理过程</h4>\n<ol>\n<li>外设完成任务，在某个寄存器或者某个特定的位置设置一个中断标记。</li>\n<li>CPU在下一个时间片开始之前会先检测这个位置，CPU发现标记后便可判断为哪种中断，得出中断号，根据中断表查出这类中断对应的处理程序地址。</li>\n<li>带着参数执行这个地址处的程序。</li>\n<li>操作系统在跳转前还需要保存被打断程序的现场状态，以便后续恢复后能继续运行，在执行完后同样要继续恢复。</li>\n</ol>\n<p><strong>特点</strong>：对于正在执行的应用程序来说是透明的，应用程序无感知</p>\n<h4>异常处理过程</h4>\n<ol>\n<li>CPU正在执行应用程序代码时，发现了非法指令，CPU无法继续执行了，产生一个异常ID（硬件实现：改变某个寄存器的值），转而执行操作系统的代码。</li>\n<li>操作系统通过异常ID确定异常号，保存好当前上下文，再确定异常处理程序的地址。</li>\n<li>异常处理判断直接杀死当前程序，还是为其分配必要的资源后重新执行一次（这种情况下对应用程序是透明的，好像不曾产生异常）。</li>\n</ol>\n<h4>系统调用过程</h4>\n<p>应用程序无法直接完成某项任务，需要操作系统作为中介提供服务。</p>\n<blockquote>\n<p>windows系统提供了Win32 API，应用程序可以为这些接口提供参数来申请系统调用。\nPOSIX-based systems系统（Linux，MacOS等系统）提供了POSIX API，可以实现应用程序的系统调用。\n人们都知道JAVA虚拟机会提供JAVA API，通过JAVA API实现的是库函数的调用，再通过JAVA虚拟机来代为实现系统调用，其实是多了一层封装的，但也就是因为多了一层JAVA虚拟机，所以JAVA程序有非常好的跨平台性，JAVA虚拟机实现了对不同操作系统差异的屏蔽。不过这并没有什么了不起的，现在大部分编程语言都是跨平台的，社区或者公司都提供了不同平台的解释或者编译程序，也可以一次编写到处运行。\n应用程序编写时，只要掌握对应OS提供的API与API具有的功能即可。</p>\n</blockquote>\n<p>应用程序直接或者间接（通过库函数）访问OS系统提供的API，会触发了CPU从用户态到内核态的切换。\n用户态就是CPU执行应用程序的状态，仅能执行有限指令，不能直接操纵外设，无法完全控制整个计算机。\n内核态指CPU执行OS程序的状态，可以执行特权和访问I/O的指令，可以完全控制整个计算机。\n完成转换后就将控制权交到了操作系统，操作系统可以对系统调用做标识，识别，完成服务。</p>\n<h4>函数调用与系统调用的区别</h4>\n<p>函数调用其实是在一个栈空间完成了参数的传递和返回。而系统调用时，应用程序和内核程序有各自的堆栈，发出系统调用，要切换执行内核程序，就要先切换堆栈，同时转换特权集（用户态到内核态），切换堆栈和转换是有开销的，还包括系统调用的参数检查，两个堆栈之间的拷贝（堆栈的切换不能仅仅通过修改指针）。总体而言开销大很多，但换来的回报是安全。</p>',fields:{slug:"/os-1/"}},{id:"C:/Users/hao/center/gatsbyblog/src/pages/posts/os-2.md absPath of file >>> MarkdownRemark",excerpt:"操作系统（二） 操作系统如何管理物理主存？ 计算机体系结构、主存结构分层 CPU芯片内部有寄存器和Cache…",frontmatter:{title:"操作系统（二）",date:"2018-01-12",tags:["os","memory"]},html:"<h1>操作系统（二）</h1>\n<ol>\n<li>操作系统如何管理物理主存？</li>\n</ol>\n<h2>计算机体系结构、主存结构分层</h2>\n<ol>\n<li>CPU芯片内部有寄存器和Cache，操作系统无法直接访问管理，这一层次的主存容量小但是数据很快。</li>\n<li>在主存结构中有一块很大的区域，即主存或者物理主存。这块区域可以用来放置操作系统本身代码以及其他要运行的程序，主存容量大，速度慢。</li>\n<li>计算机中可以在主存中存放着多个可运行的程序，若CPU的运行速度很快，且这些可运行的程序都需要很大的主存，那么CPU运行完主存中可运行的程序（假想当前主存中的可运行的所有程序都需要接收到网络响应后才能恢复运行），那么CPU就闲置下来了。为了避免CPU浪费，操作系统就需要发挥作用，将临时用不到的程序和数据放到硬盘中。</li>\n<li>主存在计算机掉电之后其内的数据就丢失了，在主存结构的底层，就是硬盘，它用来保存数据。</li>\n</ol>\n<p><strong>特点</strong>：上述主存结构分层，从上到下速度依次降低，存储容量依次增大。数据访问很快，数据的存储空间很大。有了操作系统的帮助，操作系统如何管理物理主存，如何完成这个任务？</p>\n<h2>操作系统为配合应用程序需要完成的任务</h2>\n<p>为了配合程序，操作系统需要完成以下任务：</p>\n<ul>\n<li>抽象：我们希望应用程序在主存中运行时，不需要考虑物理主存和外设在什么地方，只需要访问一个连续的地址空间（逻辑地址空间）即可。</li>\n<li>保护：在主存中可以运行多个不同的应用程序，某个程序可能会访问别的程序的地址空间，这时就需要一种机制来隔离和保护被访问程序的地址空间。</li>\n<li>共享：除了隔离外，程序之间如何交互、共享各自的数据。</li>\n<li>虚拟化：当需要在主存中运行的应用程序很多时，会出现主存不够用的情况。我们将暂时不用的数据临时放入硬盘，用的时候再拿出来，整个过程要对应用程序透明，这也是操作系统的任务。</li>\n</ul>\n<p><strong>注</strong>：上面提到了两个地址空间，主存和硬盘是物理地址空间，而应用程序在操作系统的作用下看到的是逻辑地址空间。</p>\n<h2>地址空间与地址生成</h2>\n<h3>地址空间定义</h3>\n<p>地址空间分为物理地址空间和逻辑地址空间。</p>\n<ul>\n<li>物理地址空间：与硬件直接对应，主存条代表的主存和硬盘代表的另一种存储空间，物理地址空间的管理由硬件来完成。</li>\n<li>逻辑地址空间：是运行程序所见到的一维线性的地址空间，应用程序非常容易控制和访问逻辑地址空间。</li>\n<li>两者对应关系：某条程序指令指向某个一维逻辑地址，这个逻辑地址可能是该程序堆栈的某个位置，但最终这个位置可能是主存中甚至是硬盘中，操作系统完成了两者的映射关系。</li>\n</ul>\n<h3>逻辑地址生成</h3>\n<ol>\n<li>C程序通过编译变为汇编程序，在C程序中，函数的位置和变量的名字就是地址，只不过以一种更容易人理解的方式存在。</li>\n<li>汇编程序更贴近机器语言，但是函数和变量仍然通过符号表示，相比机器语言，汇编语言更易让人阅读。</li>\n<li>将汇编程序汇编成机器语言，即.o程序，.o程序的起始地址从0开始，此时变量和函数已经被转成了特定的地址。</li>\n<li>一个大程序会由多个小程序组成，小程序之间往往具有复杂的依赖关系，通过链接可以将多个.o小程序最终变成一个单一的可执行程序.exe，.exe程序已经可以在主存中执行的，但是目前还放在硬盘中。</li>\n<li>多个点.o程序中地址已经在.exe程序中有了相应的映射，但这个定义并非主存中的位置，再通过载入程序，将.exe程序放入到主存中执行，这一步为.exe程序分配在主存中的逻辑地址，使得应用程序在主存中正常的跑，.exe程序的地址做了相应的偏远，通过这个偏移量，程序就会依照这个偏移量进行执行。</li>\n</ol>\n<p><strong>特点</strong>：从函数和变量到最终可以在主存中执行的逻辑地址，通过了很多步骤，但这些步骤基本都不需要操作系统做任何的帮助，最终放入内存后，应用程序看到的地址仍然不是物理地址。</p>\n<p><strong>题目</strong>\n在内存管理中，地址变换机构将逻辑地址变为物理地址，形成该逻辑地址的阶段是编辑、编译、链接还是装载？\n答：链接。在编译、汇编后，一个程序可能形成了多个.o文件，这是已经具有了逻辑地址，但只是相对于该模块的逻辑地址，并不能直接用于后续的地址变换。多个.h文件再经过链接，组合为.exe文件，便形成了相对于整个程序的逻辑地址。这个地址可用于后续的地址变换。</p>\n<h3><del>逻辑地址如何对应物理地址（需要组成原理的内容做铺垫）</del></h3>\n<p>指令放在物理内存的什么地方，指令的逻辑地址在什么地方，CPU有MMU，它有一块区域存着映射关系，查表可以完成具体的物理地址，硬件就可以从相应的物理地址中取出。</p>\n<p>操作系统先生成一个逻辑地址和物理地址的映射关系，将该映射关系存在内存中，CPU可以在MMU中缓存这个映射关系。（<strong>如何完成预先生成，后续谈</strong>）</p>\n<ol>\n<li>CPU执行某条指令，ALU需要得到该指令逻辑地址上的内容，ALU首先将该逻辑地址作为参数，向存储管理单元MMU发出查物理地址的请求。</li>\n<li>CPU的MMU查找对应的映射表，判断是否有对应的物理地址。</li>\n<li>若没有这个物理地址，就到内存中的映射表上找</li>\n<li>找到后CPU的控制器向主存发出请求，需要某个物理地址的内容，主存将内存的内容通过总线传给CPU，CPU拿到内容就可以进行执行了</li>\n</ol>\n<h2>如何确保内存中的程序不相互干扰</h2>\n<p>操作系统首先确认每个程序可以访问的地址空间，第一部分是起始地址，第二个部分是该程序可访问的区域。这张表由操作系统建立和维护，CPU在执行某条指令时，CPU要查表确定是否合法，合法之后才根据地址取指令。</p>",fields:{slug:"/os-2/"}}],tag:"os"}}}});
//# sourceMappingURL=path---tags-os-25913b0203b7da63674e.js.map