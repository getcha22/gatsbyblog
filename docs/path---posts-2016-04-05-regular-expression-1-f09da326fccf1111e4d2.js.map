{"version":3,"sources":["webpack:///path---posts-2016-04-05-regular-expression-1-f09da326fccf1111e4d2.js","webpack:///./.cache/json/posts-2016-04-05-regular-expression-1.json"],"names":["webpackJsonp","436","module","exports","data","markdownRemark","html","frontmatter","title","date","tags","pathContext","slug"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,wzPAAm+OC,aAA8hBC,MAAA,UAAAC,KAAA,aAAAC,MAAA,yBAAsEC,aAAgBC,KAAA","file":"path---posts-2016-04-05-regular-expression-1-f09da326fccf1111e4d2.js","sourcesContent":["webpackJsonp([176956630309340],{\n\n/***/ 436:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h1>正则表达式核心</h1>\\n<p>若有多个字符串，其中一个字符串中包含部分内容，我们使用正则来进行匹配，匹配的结果到底什么？是包含匹配内容的那个字符串？还是只有匹配的内容？</p>\\n<p>Go Ahead~</p>\\n<p>正则表达式的核心概念就是元字符，它一点也不复杂，掌握了元字符，就可以正则表达式的能力有所了解。</p>\\n<p>接下来的每一节，我都会介绍数个元字符，最终本文结束时，读者就会对正则表达式的核心元字符有大概的了解。</p>\\n<h2>从 hi, Hao 开始</h2>\\n<p><code>hi, Hao</code>这样一个字符串，如果使用正则表达式匹配到<code>hi</code>？这非常简单，我们使用<code>js</code>来作为实现语言：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">let</span> p <span class=\\\"token operator\\\">=</span> <span class=\\\"token regex\\\">/hi/</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">let</span> s <span class=\\\"token operator\\\">=</span> <span class=\\\"token template-string\\\"><span class=\\\"token string\\\">`hi, HAO`</span></span><span class=\\\"token punctuation\\\">;</span>\\ns<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">match</span><span class=\\\"token punctuation\\\">(</span>p<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// [\\\"hi\\\", index: 0, input: \\\"hi,Hao\\\"]</span>\\n</code></pre>\\n      </div>\\n<p>逐行分析：</p>\\n<ol>\\n<li>使用<code>/code/</code>这样的语法，告诉<code>js</code>解释引擎，这是一个正则表达式，其中的<code>hi</code>就是正则表达式的实际内容</li>\\n<li>声明赋值一个字符串</li>\\n<li>使用<code>match</code>方法匹配，它将返回一个数组，其中存放了与它找到的匹配文本有关的信息。该数组的第<code>0</code>个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本。除了这些常规的数组元素之外，返回的数组还含有两个对象属性。<code>index</code>属性声明的是匹配文本的起始字符在原字符串中的位置，<code>input</code>属性声明的是对原字符串的引用。</li>\\n</ol>\\n<p>上面太简单了，但如果遇到这样的情况呢？</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">let</span> s <span class=\\\"token operator\\\">=</span> <span class=\\\"token template-string\\\"><span class=\\\"token string\\\">`hi,this is Hao. hi, this is Liu.`</span></span><span class=\\\"token punctuation\\\">;</span>\\n</code></pre>\\n      </div>\\n<p>这里面的<code>hi</code>，我全都要，该如何匹配？之前的正则表达式是否可行呢？</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code>s<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">match</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token regex\\\">/hi/</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">// [\\\"hi\\\", index: 0, input: \\\"hi,this is Hao. hi, this is Liu.\\\"]</span>\\n</code></pre>\\n      </div>\\n<p>很明显，没有用了，仍然只捕捉到一个结果。为了解决这个问题，我们引入全局标志<code>g</code>，使用<code>g</code>，<code>match</code>方法将执行全局检索，找到原字符串中所有匹配子字符串。若没有找到任何匹配的子串，则返回<code>null</code>。如果找到了一个或多个匹配子串，则返回一个数组。不过全局匹配返回的数组的内容与前者大不相同，它的数组元素中存放的是原字符串中所有的匹配子串，而且也没有<code>index</code>属性和<code>input</code>属性。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code>s<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">match</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token regex\\\">/hi/g</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">// (4) [\\\"hi\\\", \\\"hi\\\", \\\"hi\\\", \\\"hi\\\"]</span>\\n</code></pre>\\n      </div>\\n<p>成功了。</p>\\n<p>挑剔的人来了，如果只想匹配到下面这个字符串最中间的<code>hi</code>呢？</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">let</span> s <span class=\\\"token operator\\\">=</span> <span class=\\\"token template-string\\\"><span class=\\\"token string\\\">`this is Hao. hi this is Liu.`</span></span><span class=\\\"token punctuation\\\">;</span>\\n</code></pre>\\n      </div>\\n<p>我们这里就需要用正则表达式的核心内容，元字符了，直接看例子，</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code>s<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">match</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token regex\\\">/hi/</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">// [\\\"hi\\\", index: 1, input: \\\"this is Hao. hi this is Liu.\\\"]</span>\\ns<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">match</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token regex\\\">/\\\\bhi\\\\b/</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">//[\\\"hi\\\", index: 13, input: \\\"this is Hao. hi this is Liu.\\\"]</span>\\n</code></pre>\\n      </div>\\n<p>逐行分析：</p>\\n<ol>\\n<li>第一行使用了老方法妄图匹配中间的<code>hi</code>，但在遇到索引位置<code>1</code>开始的<code>hi</code>时，就匹配完成了，老方法显然无法满足要求</li>\\n<li>第二种方法从结果上看匹配成功了，匹配到了索引位置<code>13</code>处开始的<code>hi</code>，我们分析一下这个正则表达式中有什么。抛除熟悉的<code>\\\\ hi \\\\</code>，我们发现了<code>hi</code>左右的<code>\\\\b \\\\b</code>，这便是元字符，<code>\\\\</code>用来告诉计算机这是元字符，区别于普通的字符串。<code>b</code>元字符可以匹配这样的位置，这个位置的前一个字符和后一个字符不全是字母、数字、下划线、汉字。分析一下会发现第一个<code>hi</code>在<code>this</code>中，很明显，子串<code>hi</code>的前后字符都是字母，不满足要求。到了索引为<code>13</code>出的<code>hi</code>，它的前后是空格，不是字母、数字、下划线或者汉字，<code>b</code>元字符要求<code>hi</code>的前一个字符和后一个字符不全是字母、数字、下划线、汉字。这里都是空格，这可高于要求的<code>不全是</code>，都已经<code>全都不是</code>了，当然满足了，匹配成功。</li>\\n</ol>\\n<table>\\n<thead>\\n<tr>\\n<th>元字符</th>\\n<th>作用</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>b</td>\\n<td>所匹配的位置，前一个字符和后一个字符不全是\\n<code>w</code>\\n(\\n<code>w</code>\\n用来匹配字母、数字、下划线、汉字)</td>\\n</tr>\\n</tbody>\\n</table>\\n<h2>.*元字符</h2>\\n<p>匹配<code>hi</code>还是容易的，但如果想匹配一大段内容呢？比如</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">let</span> s <span class=\\\"token operator\\\">=</span> <span class=\\\"token template-string\\\"><span class=\\\"token string\\\">`hi! .................... I'm Lucy! I may be a pink ostrich but I'm still a kid just like you! I love  tell jokes, laugh, sing, watch cartoons and learn! And I get to do all these things in class with Sr. Grace! She's my favorite teacher in the whole world. `</span></span><span class=\\\"token punctuation\\\">;</span>\\n</code></pre>\\n      </div>\\n<p>上面的省略号代表非常多的内容。假如我想要匹配<code>hi</code>与<code>Lucy</code>连同它中间的内容呢？我总不能都放到正则表达式吧，那多丑！\\n我们这里又要使用元字符了</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code>s<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">match</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token regex\\\">/\\\\bhi\\\\b.*\\\\bLucy\\\\b/</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">//succ</span>\\n</code></pre>\\n      </div>\\n<p>这里面的有两三点要说明：</p>\\n<ol>\\n<li><code>.*</code>也算元字符？是的，这是两个元字符，只不过他们没有加<code>\\\\</code>而已。</li>\\n<li>为什么不加<code>\\\\</code>标志符？因为他们太常用了，干脆就省略<code>\\\\</code>了，反而专门要匹配字符串<code>.</code>与<code>*</code>的场合却很少，干脆将正则表达式与字符串的表示反一下，如果想要匹配<code>.</code>这个字符串，那么为它加上<code>\\\\</code>，即<code>\\\\.</code>，<code>\\\\*</code>也是同理。</li>\\n<li><code>.*</code>代表什么含义？请看下面的表格</li>\\n</ol>\\n<table>\\n<thead>\\n<tr>\\n<th>元字符</th>\\n<th>作用</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>.</td>\\n<td>匹配除了换行符之外的任何字符</td>\\n</tr>\\n<tr>\\n<td>*</td>\\n<td>用来指定这个元字符 * 前面的内容可以连续重复使用任意多次，可以使得整个表达式得到匹配</td>\\n</tr>\\n</tbody>\\n</table>\\n<p>看到这个表格你应该明了了，<code>.*</code>用来表示任何数量的字符，只要字符里边不包括换行，于是 \\\\bhi\\\\b.*\\\\bLucy\\\\b 就表示先有个单词<code>hi</code>，接着允许出现很多字符，除了换行，之后有一个单词<code>Lucy</code>。</p>\\n<h2>电话号码的匹配实例</h2>\\n<p><code>0\\\\d\\\\d\\\\d-\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d</code> 用来匹配<code>0</code>开头，之后3位数字加<code>-</code>，之后8位数字的电话号码。使用这么多的<code>\\\\d</code>是一件很让人上头的事情，可以使用这样的写法：<code>0\\\\d{3}-\\\\d{8}</code>。</p>\\n<table>\\n<thead>\\n<tr>\\n<th>元字符</th>\\n<th>作用</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>d</td>\\n<td>匹配一位数字,比如 0 ，1 ，2 等任意的一位数字</td>\\n</tr>\\n<tr>\\n<td>{n}</td>\\n<td>用来指定这个元字符\\n<code>*</code>\\n前面的内容可以连续重复使用任意多次，可以使得整个表达式得到匹配</td>\\n</tr>\\n</tbody>\\n</table>\\n<h2>其他常用元字符</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>元字符</th>\\n<th>作用</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>/s</td>\\n<td>匹配任意多的空白符</td>\\n</tr>\\n<tr>\\n<td>/w</td>\\n<td>代表着可用文字，包含字母，数字，下划线，汉字</td>\\n</tr>\\n<tr>\\n<td>/s</td>\\n<td>匹配任意多的空白符</td>\\n</tr>\\n<tr>\\n<td>+</td>\\n<td>与\\n<code>{n}</code>\\n、\\n<code>*</code>\\n类似，指定当前元字符前面的内容重复多次，\\n<code>+</code>\\n专指重复\\n<code>1</code>\\n次以上</td>\\n</tr>\\n</tbody>\\n</table>\\n<h2>番外</h2>\\n<p>现在好多内容在讲正则的时候都不注意区分哪些是核心内容，在很多环境下，编程语言会对正则做出拓展，引入了很多新符号，引入了很多的复杂度，对初学者不友好。下面推荐一些文章</p>\\n<ul>\\n<li>谷歌大牛的文章：<a href=\\\"http://blog.youxu.info/2009/03/05/ree1/\\\">编程珠玑番外篇-C.正则表达式精义-1</a></li>\\n<li>进阶：<a href=\\\"http://www.cppblog.com/vczh/archive/2014/01/19/205468.html\\\">跟vczh看实例学编译原理——零：序言</a></li>\\n<li>这是一个图形化的在线正则展示网页，可以用来测试正则：<a href=\\\"https://regexper.com/\\\">Regexper</a></li>\\n</ul>\",\"frontmatter\":{\"title\":\"正则表达式核心\",\"date\":\"2016-04-05\",\"tags\":[\"regular expression\"]}}},\"pathContext\":{\"slug\":\"/2016-04-05---regular-expression-1/\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---posts-2016-04-05-regular-expression-1-f09da326fccf1111e4d2.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h1>正则表达式核心</h1>\\n<p>若有多个字符串，其中一个字符串中包含部分内容，我们使用正则来进行匹配，匹配的结果到底什么？是包含匹配内容的那个字符串？还是只有匹配的内容？</p>\\n<p>Go Ahead~</p>\\n<p>正则表达式的核心概念就是元字符，它一点也不复杂，掌握了元字符，就可以正则表达式的能力有所了解。</p>\\n<p>接下来的每一节，我都会介绍数个元字符，最终本文结束时，读者就会对正则表达式的核心元字符有大概的了解。</p>\\n<h2>从 hi, Hao 开始</h2>\\n<p><code>hi, Hao</code>这样一个字符串，如果使用正则表达式匹配到<code>hi</code>？这非常简单，我们使用<code>js</code>来作为实现语言：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">let</span> p <span class=\\\"token operator\\\">=</span> <span class=\\\"token regex\\\">/hi/</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">let</span> s <span class=\\\"token operator\\\">=</span> <span class=\\\"token template-string\\\"><span class=\\\"token string\\\">`hi, HAO`</span></span><span class=\\\"token punctuation\\\">;</span>\\ns<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">match</span><span class=\\\"token punctuation\\\">(</span>p<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// [\\\"hi\\\", index: 0, input: \\\"hi,Hao\\\"]</span>\\n</code></pre>\\n      </div>\\n<p>逐行分析：</p>\\n<ol>\\n<li>使用<code>/code/</code>这样的语法，告诉<code>js</code>解释引擎，这是一个正则表达式，其中的<code>hi</code>就是正则表达式的实际内容</li>\\n<li>声明赋值一个字符串</li>\\n<li>使用<code>match</code>方法匹配，它将返回一个数组，其中存放了与它找到的匹配文本有关的信息。该数组的第<code>0</code>个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本。除了这些常规的数组元素之外，返回的数组还含有两个对象属性。<code>index</code>属性声明的是匹配文本的起始字符在原字符串中的位置，<code>input</code>属性声明的是对原字符串的引用。</li>\\n</ol>\\n<p>上面太简单了，但如果遇到这样的情况呢？</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">let</span> s <span class=\\\"token operator\\\">=</span> <span class=\\\"token template-string\\\"><span class=\\\"token string\\\">`hi,this is Hao. hi, this is Liu.`</span></span><span class=\\\"token punctuation\\\">;</span>\\n</code></pre>\\n      </div>\\n<p>这里面的<code>hi</code>，我全都要，该如何匹配？之前的正则表达式是否可行呢？</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code>s<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">match</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token regex\\\">/hi/</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">// [\\\"hi\\\", index: 0, input: \\\"hi,this is Hao. hi, this is Liu.\\\"]</span>\\n</code></pre>\\n      </div>\\n<p>很明显，没有用了，仍然只捕捉到一个结果。为了解决这个问题，我们引入全局标志<code>g</code>，使用<code>g</code>，<code>match</code>方法将执行全局检索，找到原字符串中所有匹配子字符串。若没有找到任何匹配的子串，则返回<code>null</code>。如果找到了一个或多个匹配子串，则返回一个数组。不过全局匹配返回的数组的内容与前者大不相同，它的数组元素中存放的是原字符串中所有的匹配子串，而且也没有<code>index</code>属性和<code>input</code>属性。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code>s<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">match</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token regex\\\">/hi/g</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">// (4) [\\\"hi\\\", \\\"hi\\\", \\\"hi\\\", \\\"hi\\\"]</span>\\n</code></pre>\\n      </div>\\n<p>成功了。</p>\\n<p>挑剔的人来了，如果只想匹配到下面这个字符串最中间的<code>hi</code>呢？</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">let</span> s <span class=\\\"token operator\\\">=</span> <span class=\\\"token template-string\\\"><span class=\\\"token string\\\">`this is Hao. hi this is Liu.`</span></span><span class=\\\"token punctuation\\\">;</span>\\n</code></pre>\\n      </div>\\n<p>我们这里就需要用正则表达式的核心内容，元字符了，直接看例子，</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code>s<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">match</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token regex\\\">/hi/</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">// [\\\"hi\\\", index: 1, input: \\\"this is Hao. hi this is Liu.\\\"]</span>\\ns<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">match</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token regex\\\">/\\\\bhi\\\\b/</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">//[\\\"hi\\\", index: 13, input: \\\"this is Hao. hi this is Liu.\\\"]</span>\\n</code></pre>\\n      </div>\\n<p>逐行分析：</p>\\n<ol>\\n<li>第一行使用了老方法妄图匹配中间的<code>hi</code>，但在遇到索引位置<code>1</code>开始的<code>hi</code>时，就匹配完成了，老方法显然无法满足要求</li>\\n<li>第二种方法从结果上看匹配成功了，匹配到了索引位置<code>13</code>处开始的<code>hi</code>，我们分析一下这个正则表达式中有什么。抛除熟悉的<code>\\\\ hi \\\\</code>，我们发现了<code>hi</code>左右的<code>\\\\b \\\\b</code>，这便是元字符，<code>\\\\</code>用来告诉计算机这是元字符，区别于普通的字符串。<code>b</code>元字符可以匹配这样的位置，这个位置的前一个字符和后一个字符不全是字母、数字、下划线、汉字。分析一下会发现第一个<code>hi</code>在<code>this</code>中，很明显，子串<code>hi</code>的前后字符都是字母，不满足要求。到了索引为<code>13</code>出的<code>hi</code>，它的前后是空格，不是字母、数字、下划线或者汉字，<code>b</code>元字符要求<code>hi</code>的前一个字符和后一个字符不全是字母、数字、下划线、汉字。这里都是空格，这可高于要求的<code>不全是</code>，都已经<code>全都不是</code>了，当然满足了，匹配成功。</li>\\n</ol>\\n<table>\\n<thead>\\n<tr>\\n<th>元字符</th>\\n<th>作用</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>b</td>\\n<td>所匹配的位置，前一个字符和后一个字符不全是\\n<code>w</code>\\n(\\n<code>w</code>\\n用来匹配字母、数字、下划线、汉字)</td>\\n</tr>\\n</tbody>\\n</table>\\n<h2>.*元字符</h2>\\n<p>匹配<code>hi</code>还是容易的，但如果想匹配一大段内容呢？比如</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code><span class=\\\"token keyword\\\">let</span> s <span class=\\\"token operator\\\">=</span> <span class=\\\"token template-string\\\"><span class=\\\"token string\\\">`hi! .................... I'm Lucy! I may be a pink ostrich but I'm still a kid just like you! I love  tell jokes, laugh, sing, watch cartoons and learn! And I get to do all these things in class with Sr. Grace! She's my favorite teacher in the whole world. `</span></span><span class=\\\"token punctuation\\\">;</span>\\n</code></pre>\\n      </div>\\n<p>上面的省略号代表非常多的内容。假如我想要匹配<code>hi</code>与<code>Lucy</code>连同它中间的内容呢？我总不能都放到正则表达式吧，那多丑！\\n我们这里又要使用元字符了</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-js\\\"><code>s<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">match</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token regex\\\">/\\\\bhi\\\\b.*\\\\bLucy\\\\b/</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">//succ</span>\\n</code></pre>\\n      </div>\\n<p>这里面的有两三点要说明：</p>\\n<ol>\\n<li><code>.*</code>也算元字符？是的，这是两个元字符，只不过他们没有加<code>\\\\</code>而已。</li>\\n<li>为什么不加<code>\\\\</code>标志符？因为他们太常用了，干脆就省略<code>\\\\</code>了，反而专门要匹配字符串<code>.</code>与<code>*</code>的场合却很少，干脆将正则表达式与字符串的表示反一下，如果想要匹配<code>.</code>这个字符串，那么为它加上<code>\\\\</code>，即<code>\\\\.</code>，<code>\\\\*</code>也是同理。</li>\\n<li><code>.*</code>代表什么含义？请看下面的表格</li>\\n</ol>\\n<table>\\n<thead>\\n<tr>\\n<th>元字符</th>\\n<th>作用</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>.</td>\\n<td>匹配除了换行符之外的任何字符</td>\\n</tr>\\n<tr>\\n<td>*</td>\\n<td>用来指定这个元字符 * 前面的内容可以连续重复使用任意多次，可以使得整个表达式得到匹配</td>\\n</tr>\\n</tbody>\\n</table>\\n<p>看到这个表格你应该明了了，<code>.*</code>用来表示任何数量的字符，只要字符里边不包括换行，于是 \\\\bhi\\\\b.*\\\\bLucy\\\\b 就表示先有个单词<code>hi</code>，接着允许出现很多字符，除了换行，之后有一个单词<code>Lucy</code>。</p>\\n<h2>电话号码的匹配实例</h2>\\n<p><code>0\\\\d\\\\d\\\\d-\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d</code> 用来匹配<code>0</code>开头，之后3位数字加<code>-</code>，之后8位数字的电话号码。使用这么多的<code>\\\\d</code>是一件很让人上头的事情，可以使用这样的写法：<code>0\\\\d{3}-\\\\d{8}</code>。</p>\\n<table>\\n<thead>\\n<tr>\\n<th>元字符</th>\\n<th>作用</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>d</td>\\n<td>匹配一位数字,比如 0 ，1 ，2 等任意的一位数字</td>\\n</tr>\\n<tr>\\n<td>{n}</td>\\n<td>用来指定这个元字符\\n<code>*</code>\\n前面的内容可以连续重复使用任意多次，可以使得整个表达式得到匹配</td>\\n</tr>\\n</tbody>\\n</table>\\n<h2>其他常用元字符</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>元字符</th>\\n<th>作用</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>/s</td>\\n<td>匹配任意多的空白符</td>\\n</tr>\\n<tr>\\n<td>/w</td>\\n<td>代表着可用文字，包含字母，数字，下划线，汉字</td>\\n</tr>\\n<tr>\\n<td>/s</td>\\n<td>匹配任意多的空白符</td>\\n</tr>\\n<tr>\\n<td>+</td>\\n<td>与\\n<code>{n}</code>\\n、\\n<code>*</code>\\n类似，指定当前元字符前面的内容重复多次，\\n<code>+</code>\\n专指重复\\n<code>1</code>\\n次以上</td>\\n</tr>\\n</tbody>\\n</table>\\n<h2>番外</h2>\\n<p>现在好多内容在讲正则的时候都不注意区分哪些是核心内容，在很多环境下，编程语言会对正则做出拓展，引入了很多新符号，引入了很多的复杂度，对初学者不友好。下面推荐一些文章</p>\\n<ul>\\n<li>谷歌大牛的文章：<a href=\\\"http://blog.youxu.info/2009/03/05/ree1/\\\">编程珠玑番外篇-C.正则表达式精义-1</a></li>\\n<li>进阶：<a href=\\\"http://www.cppblog.com/vczh/archive/2014/01/19/205468.html\\\">跟vczh看实例学编译原理——零：序言</a></li>\\n<li>这是一个图形化的在线正则展示网页，可以用来测试正则：<a href=\\\"https://regexper.com/\\\">Regexper</a></li>\\n</ul>\",\"frontmatter\":{\"title\":\"正则表达式核心\",\"date\":\"2016-04-05\",\"tags\":[\"regular expression\"]}}},\"pathContext\":{\"slug\":\"/2016-04-05---regular-expression-1/\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/posts-2016-04-05-regular-expression-1.json\n// module id = 436\n// module chunks = 176956630309340"],"sourceRoot":""}